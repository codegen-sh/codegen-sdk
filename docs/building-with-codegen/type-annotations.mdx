---
title: "Working with Type Annotations"
sidebarTitle: "Type Annotations"
icon: "code"
iconType: "solid"
---

This guide covers the core APIs and patterns for working with type annotations in Codegen.

## Core Interfaces

Type annotations in Codegen are built on two key interfaces:

- [Typeable](/api-reference/core/Typeable) - The base interface for any node that can have a type annotation (parameters, variables, functions, etc). Provides `.type` and `.is_typed`.
- [Type](/api-reference/core/Type) - The base class for all type annotations. Provides type resolution and dependency tracking.

Any node that inherits from `Typeable` will have a `.type` property that returns a `Type` object, which can be used to inspect and modify type annotations.

<Tip>Learn more about [inheritable behaviors](/building-with-codegen/inheritable-behaviors) like Typeable here</Tip>

## Core Type APIs

Type annotations can be accessed and modified through several key APIs:

### Function Types

The main APIs for function types are [Function.return_type](/api-reference/python/PyFunction#return-type) and [Function.set_return_type](/api-reference/python/PyFunction#set-return-type):

```python
# Get return type
return_type = function.return_type  # -> TypeAnnotation
print(return_type.source)  # "List[str]"
print(return_type.is_typed)  # True/False

# Set return type
function.set_return_type("List[str]")
function.set_return_type(None)  # Removes type annotation
```

### Parameter Types

Parameters use [Parameter.type](/api-reference/core/Parameter#type) and [Parameter.set_type_annotation](/api-reference/core/Parameter#set-type-annotation):

```python
for param in function.parameters:
    # Get parameter type
    param_type = param.type  # -> TypeAnnotation
    print(param_type.source)  # "int"
    print(param_type.is_typed)  # True/False

    # Set parameter type
    param.set_type("int")
    param.set_type(None)  # Removes type annotation
```

### Variable Types

Variables and attributes use [Assignment.type](/api-reference/core/Assignment#type) and [Assignment.set_type_annotation](/api-reference/core/Assignment#set-type-annotation). This applies to:
- Global variables
- Local variables
- Class attributes (via [Class.attributes](/api-reference/core/Class#attributes))

```python
# For global/local assignments
assignment = file.get_assignment("my_var")
var_type = assignment.type  # -> TypeAnnotation
print(var_type.source)  # "str"

# Set variable type
assignment.set_type("str")
assignment.set_type(None)  # Removes type annotation

# For class attributes
class_def = file.get_class("MyClass")
for attr in class_def.attributes:
    # Each attribute has an assignment property
    attr_type = attr.assignment.type  # -> TypeAnnotation
    print(f"{attr.name}: {attr_type.source}")  # e.g. "x: int"
    
    # Set attribute type
    attr.assignment.set_type("int")

# You can also access attributes directly by index
first_attr = class_def.attributes[0]
first_attr.assignment.set_type("str")
```

## Working with Complex Types

### Union Types

Union types ([UnionType](/api-reference/core/UnionType)) can be manipulated as collections:

```python
# Get union type
union_type = function.return_type  # -> A | B 
print(union_type.symbols)  # ["A", "B"]

# Add/remove options
union_type.append("float")
union_type.remove("None")

# Check contents
if "str" in union_type.options:
    print("String is a possible type")
```
<Tip>Learn more about [working with collections here](/building-with-codegen/collections)</Tip>

### Generic Types

Generic types ([`GenericType`](/api-reference/core/GenericType)) expose their parameters:

```python
# Get generic type
generic_type = function.return_type  # -> GenericType
print(generic_type.base)  # "List"
print(generic_type.parameters)  # ["str"]

# Modify parameters
generic_type.parameters.append("int")
generic_type.parameters[0] = "float"

# Create new generic
function.set_return_type("List[str]")
```

### Type Resolution

Type resolution uses [`TypeAnnotation.resolved_types`](/api-reference/core/TypeAnnotation#resolved-types):

```python
# Get the actual symbol for a type
type_annotation = function.return_type
resolved_symbol = type_annotation.resolved_types  # -> Symbol

# For generic types, resolve parameters
for param in type_annotation.parameters:
    resolved_param = param.resolved_types
```

## Common Patterns

### Checking Type Presence

Using [`is_typed`](/api-reference/core/TypeAnnotation#is-typed) to check for type annotations:

```python
def needs_type_annotation(function):
    # Check if return type exists
    if not function.return_type or not function.return_type.is_typed:
        return True
    
    # Check if all parameters are typed
    return any(
        not param.type or not param.type.is_typed
        for param in function.parameters
    )
```

### Adding Missing Types

```python
def ensure_return_type(function, default_type="Any"):
    if not function.return_type or not function.return_type.is_typed:
        function.set_return_type(default_type)
```

### Type Inference

Using [`ReturnStatement.value`](/api-reference/core/ReturnStatement#value) to infer types:

```python
def infer_return_type(function):
    # Look at return statements
    return_types = set()
    for stmt in function.return_statements:
        if stmt.value and stmt.value.type:
            return_types.add(stmt.value.type.source)
    
    # If consistent type found, use it
    if len(return_types) == 1:
        function.set_return_type(return_types.pop())
```

### Importing Types

Using [`File.add_symbol_import`](/api-reference/core/File#add-symbol-import) to import types:

```python
def add_type_with_import(target_file, symbol_to_type):
    # First ensure type is imported
    target_file.add_symbol_import(symbol_to_type)
    
    # Then use in type annotation
    function = target_file.get_function("my_func")
    function.set_return_type(symbol_to_type.name)
```

## Best Practices

1. **Check Before Setting**: Always verify if a type annotation exists and is typed before modifying
2. **Import Management**: When adding types, ensure required imports exist
3. **Type Resolution**: Use `resolved_types` when you need the actual symbol rather than just the type string
4. **Careful Modification**: When modifying generic/union types, preserve existing type parameters where appropriate

## Related Resources
- [Increasing Type Coverage](/tutorials/increase-type-coverage) - Guide for applying these patterns
- [Dependencies and Usages](/building-with-codegen/dependencies-and-usages) - Understanding symbol relationships
- [Class API](/building-with-codegen/class-api) - Working with class attributes 