diff --git a/packages/vite/src/node/__tests__/build.spec.ts b/packages/vite/src/node/__tests__/build.spec.ts
index 2dad85578..ae345af1c 100644
--- a/packages/vite/src/node/__tests__/build.spec.ts
+++ b/packages/vite/src/node/__tests__/build.spec.ts
@@ -1,10 +1,17 @@
+import { LibraryFormats } from 'packages/vite/src/node/build/BuildOptions';
+import { LibraryOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { LibraryFormats } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { LibraryOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { build } from 'packages/vite/src/node/build/build';
+import { LibraryFormats } from 'packages/vite/src/node/build/resolveBuildOutputs';
+import { LibraryOptions } from 'packages/vite/src/node/build/resolveBuildOutputs';
+import { resolveBuildOutputs } from 'packages/vite/src/node/build/resolveBuildOutputs';
 import { basename, resolve } from 'node:path'
 import { fileURLToPath } from 'node:url'
 import colors from 'picocolors'
 import { describe, expect, test, vi } from 'vitest'
 import type { OutputChunk, OutputOptions, RollupOutput } from 'rollup'
-import type { LibraryFormats, LibraryOptions } from '../build'
-import { build, resolveBuildOutputs, resolveLibFilename } from '../build'
+import { resolveLibFilename } from '../build'
 import type { Logger } from '../logger'
 import { createLogger } from '../logger'
 
diff --git a/packages/vite/src/node/__tests__/config.spec.ts b/packages/vite/src/node/__tests__/config.spec.ts
index 9fbbdd61f..d37fe9703 100644
--- a/packages/vite/src/node/__tests__/config.spec.ts
+++ b/packages/vite/src/node/__tests__/config.spec.ts
@@ -1,8 +1,14 @@
+import { PluginOption } from 'packages/vite/src/node/config/UserConfig';
+import { UserConfig } from 'packages/vite/src/node/config/UserConfig';
+import { PluginOption } from 'packages/vite/src/node/config/resolveConfig';
+import { UserConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { PluginOption } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { UserConfig } from 'packages/vite/src/node/config/loadConfigFromFile';
 import http from 'node:http'
 import { describe, expect, test } from 'vitest'
 import type { InlineConfig } from '..'
-import type { PluginOption, UserConfig, UserConfigExport } from '../config'
-import { defineConfig, resolveConfig } from '../config'
+import { defineConfig } from '../config'
 import { resolveEnvPrefix } from '../env'
 import { createLogger, mergeConfig } from '../publicUtils'
 
diff --git a/packages/vite/src/node/__tests__/plugins/css.spec.ts b/packages/vite/src/node/__tests__/plugins/css.spec.ts
index e1c435211..b6629ec1b 100644
--- a/packages/vite/src/node/__tests__/plugins/css.spec.ts
+++ b/packages/vite/src/node/__tests__/plugins/css.spec.ts
@@ -1,12 +1,14 @@
+import { InlineConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { cssPlugin } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { cssUrlRE } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { cssUrlRE } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { cssUrlRE } from 'packages/vite/src/node/plugins/css/lessProcessor';
 import fs from 'node:fs'
 import path from 'node:path'
 import { describe, expect, test, vi } from 'vitest'
-import { resolveConfig } from '../../config'
-import type { InlineConfig } from '../../config'
 import {
   convertTargets,
-  cssPlugin,
-  cssUrlRE,
   getEmptyChunkReplacer,
   hoistAtRules,
   preprocessCSS,
diff --git a/packages/vite/src/node/__tests__/plugins/define.spec.ts b/packages/vite/src/node/__tests__/plugins/define.spec.ts
index 2165461c7..83c22cd05 100644
--- a/packages/vite/src/node/__tests__/plugins/define.spec.ts
+++ b/packages/vite/src/node/__tests__/plugins/define.spec.ts
@@ -1,6 +1,6 @@
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
 import { describe, expect, test } from 'vitest'
 import { definePlugin } from '../../plugins/define'
-import { resolveConfig } from '../../config'
 
 async function createDefinePluginTransform(
   define: Record<string, any> = {},
diff --git a/packages/vite/src/node/__tests__/plugins/esbuild.spec.ts b/packages/vite/src/node/__tests__/plugins/esbuild.spec.ts
index 936415f9c..bcbd1358c 100644
--- a/packages/vite/src/node/__tests__/plugins/esbuild.spec.ts
+++ b/packages/vite/src/node/__tests__/plugins/esbuild.spec.ts
@@ -1,5 +1,8 @@
+import { UserConfig } from 'packages/vite/src/node/config/UserConfig';
+import { UserConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { UserConfig } from 'packages/vite/src/node/config/loadConfigFromFile';
 import { describe, expect, test } from 'vitest'
-import type { ResolvedConfig, UserConfig } from '../../config'
 import {
   resolveEsbuildTranspileOptions,
   transformWithEsbuild,
diff --git a/packages/vite/src/node/__tests__/plugins/modulePreloadPolyfill/modulePreloadPolyfill.spec.ts b/packages/vite/src/node/__tests__/plugins/modulePreloadPolyfill/modulePreloadPolyfill.spec.ts
index 3b24fbd52..695b7cf6a 100644
--- a/packages/vite/src/node/__tests__/plugins/modulePreloadPolyfill/modulePreloadPolyfill.spec.ts
+++ b/packages/vite/src/node/__tests__/plugins/modulePreloadPolyfill/modulePreloadPolyfill.spec.ts
@@ -1,6 +1,6 @@
+import { build } from 'packages/vite/src/node/build/build';
 import { describe, it } from 'vitest'
 import type { ModuleFormat, RollupOutput } from 'rollup'
-import { build } from '../../../build'
 import { modulePreloadPolyfillId } from '../../../plugins/modulePreloadPolyfill'
 
 const buildProject = ({ format = 'es' as ModuleFormat } = {}) =>
diff --git a/packages/vite/src/node/build.ts b/packages/vite/src/node/build.ts
index d86393d36..daf2573d3 100644
--- a/packages/vite/src/node/build.ts
+++ b/packages/vite/src/node/build.ts
@@ -1,3 +1,25 @@
+import { LibraryOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { ResolveModulePreloadDependenciesFn } from 'packages/vite/src/node/build/BuildOptions';
+import { ModulePreloadOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { BuildOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { BuildOptions } from 'packages/vite/src/node/build';
+import { LibraryOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { ResolveModulePreloadDependenciesFn } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { BuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { ResolvedBuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { resolveBuildOptions } from 'packages/vite/src/node/build';
+import { build } from 'packages/vite/src/node/build';
+import { LibraryOptions } from 'packages/vite/src/node/build/resolveBuildOutputs';
+import { resolveBuildOutputs } from 'packages/vite/src/node/build/resolveBuildOutputs';
+import { resolveBuildOutputs } from 'packages/vite/src/node/build';
+import { warningIgnoreList } from 'packages/vite/src/node/build/onRollupWarning';
+import { dynamicImportWarningIgnoreList } from 'packages/vite/src/node/build/onRollupWarning';
+import { clearLine } from 'packages/vite/src/node/build/onRollupWarning';
+import { onRollupWarning } from 'packages/vite/src/node/build/onRollupWarning';
+import { onRollupWarning } from 'packages/vite/src/node/build';
+import { InlineConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
 import fs from 'node:fs'
 import path from 'node:path'
 import colors from 'picocolors'
@@ -27,8 +49,6 @@ import {
   ESBUILD_MODULES_TARGET,
   VERSION,
 } from './constants'
-import type { InlineConfig, ResolvedConfig } from './config'
-import { resolveConfig } from './config'
 import { buildReporterPlugin } from './plugins/reporter'
 import { buildEsbuildPlugin } from './plugins/esbuild'
 import { type TerserOptions, terserPlugin } from './plugins/terser'
@@ -61,369 +81,6 @@ import { mergeConfig } from './publicUtils'
 import { webWorkerPostPlugin } from './plugins/worker'
 import { getHookHandler } from './plugins'
 
-export interface BuildOptions {
-  /**
-   * Compatibility transform target. The transform is performed with esbuild
-   * and the lowest supported target is es2015/es6. Note this only handles
-   * syntax transformation and does not cover polyfills (except for dynamic
-   * import)
-   *
-   * Default: 'modules' - Similar to `@babel/preset-env`'s targets.esmodules,
-   * transpile targeting browsers that natively support dynamic es module imports.
-   * https://caniuse.com/es6-module-dynamic-import
-   *
-   * Another special value is 'esnext' - which only performs minimal transpiling
-   * (for minification compat) and assumes native dynamic imports support.
-   *
-   * For custom targets, see https://esbuild.github.io/api/#target and
-   * https://esbuild.github.io/content-types/#javascript for more details.
-   * @default 'modules'
-   */
-  target?: 'modules' | TransformOptions['target'] | false
-  /**
-   * whether to inject module preload polyfill.
-   * Note: does not apply to library mode.
-   * @default true
-   * @deprecated use `modulePreload.polyfill` instead
-   */
-  polyfillModulePreload?: boolean
-  /**
-   * Configure module preload
-   * Note: does not apply to library mode.
-   * @default true
-   */
-  modulePreload?: boolean | ModulePreloadOptions
-  /**
-   * Directory relative from `root` where build output will be placed. If the
-   * directory exists, it will be removed before the build.
-   * @default 'dist'
-   */
-  outDir?: string
-  /**
-   * Directory relative from `outDir` where the built js/css/image assets will
-   * be placed.
-   * @default 'assets'
-   */
-  assetsDir?: string
-  /**
-   * Static asset files smaller than this number (in bytes) will be inlined as
-   * base64 strings. Default limit is `4096` (4 KiB). Set to `0` to disable.
-   * @default 4096
-   */
-  assetsInlineLimit?:
-    | number
-    | ((filePath: string, content: Buffer) => boolean | undefined)
-  /**
-   * Whether to code-split CSS. When enabled, CSS in async chunks will be
-   * inlined as strings in the chunk and inserted via dynamically created
-   * style tags when the chunk is loaded.
-   * @default true
-   */
-  cssCodeSplit?: boolean
-  /**
-   * An optional separate target for CSS minification.
-   * As esbuild only supports configuring targets to mainstream
-   * browsers, users may need this option when they are targeting
-   * a niche browser that comes with most modern JavaScript features
-   * but has poor CSS support, e.g. Android WeChat WebView, which
-   * doesn't support the #RGBA syntax.
-   * @default target
-   */
-  cssTarget?: TransformOptions['target'] | false
-  /**
-   * Override CSS minification specifically instead of defaulting to `build.minify`,
-   * so you can configure minification for JS and CSS separately.
-   * @default 'esbuild'
-   */
-  cssMinify?: boolean | 'esbuild' | 'lightningcss'
-  /**
-   * If `true`, a separate sourcemap file will be created. If 'inline', the
-   * sourcemap will be appended to the resulting output file as data URI.
-   * 'hidden' works like `true` except that the corresponding sourcemap
-   * comments in the bundled files are suppressed.
-   * @default false
-   */
-  sourcemap?: boolean | 'inline' | 'hidden'
-  /**
-   * Set to `false` to disable minification, or specify the minifier to use.
-   * Available options are 'terser' or 'esbuild'.
-   * @default 'esbuild'
-   */
-  minify?: boolean | 'terser' | 'esbuild'
-  /**
-   * Options for terser
-   * https://terser.org/docs/api-reference#minify-options
-   *
-   * In addition, you can also pass a `maxWorkers: number` option to specify the
-   * max number of workers to spawn. Defaults to the number of CPUs minus 1.
-   */
-  terserOptions?: TerserOptions
-  /**
-   * Will be merged with internal rollup options.
-   * https://rollupjs.org/configuration-options/
-   */
-  rollupOptions?: RollupOptions
-  /**
-   * Options to pass on to `@rollup/plugin-commonjs`
-   */
-  commonjsOptions?: RollupCommonJSOptions
-  /**
-   * Options to pass on to `@rollup/plugin-dynamic-import-vars`
-   */
-  dynamicImportVarsOptions?: RollupDynamicImportVarsOptions
-  /**
-   * Whether to write bundle to disk
-   * @default true
-   */
-  write?: boolean
-  /**
-   * Empty outDir on write.
-   * @default true when outDir is a sub directory of project root
-   */
-  emptyOutDir?: boolean | null
-  /**
-   * Copy the public directory to outDir on write.
-   * @default true
-   */
-  copyPublicDir?: boolean
-  /**
-   * Whether to emit a .vite/manifest.json under assets dir to map hash-less filenames
-   * to their hashed versions. Useful when you want to generate your own HTML
-   * instead of using the one generated by Vite.
-   *
-   * Example:
-   *
-   * ```json
-   * {
-   *   "main.js": {
-   *     "file": "main.68fe3fad.js",
-   *     "css": "main.e6b63442.css",
-   *     "imports": [...],
-   *     "dynamicImports": [...]
-   *   }
-   * }
-   * ```
-   * @default false
-   */
-  manifest?: boolean | string
-  /**
-   * Build in library mode. The value should be the global name of the lib in
-   * UMD mode. This will produce esm + cjs + umd bundle formats with default
-   * configurations that are suitable for distributing libraries.
-   * @default false
-   */
-  lib?: LibraryOptions | false
-  /**
-   * Produce SSR oriented build. Note this requires specifying SSR entry via
-   * `rollupOptions.input`.
-   * @default false
-   */
-  ssr?: boolean | string
-  /**
-   * Generate SSR manifest for determining style links and asset preload
-   * directives in production.
-   * @default false
-   */
-  ssrManifest?: boolean | string
-  /**
-   * Emit assets during SSR.
-   * @default false
-   */
-  ssrEmitAssets?: boolean
-  /**
-   * Set to false to disable reporting compressed chunk sizes.
-   * Can slightly improve build speed.
-   * @default true
-   */
-  reportCompressedSize?: boolean
-  /**
-   * Adjust chunk size warning limit (in kB).
-   * @default 500
-   */
-  chunkSizeWarningLimit?: number
-  /**
-   * Rollup watch options
-   * https://rollupjs.org/configuration-options/#watch
-   * @default null
-   */
-  watch?: WatcherOptions | null
-}
-
-export interface LibraryOptions {
-  /**
-   * Path of library entry
-   */
-  entry: InputOption
-  /**
-   * The name of the exposed global variable. Required when the `formats` option includes
-   * `umd` or `iife`
-   */
-  name?: string
-  /**
-   * Output bundle formats
-   * @default ['es', 'umd']
-   */
-  formats?: LibraryFormats[]
-  /**
-   * The name of the package file output. The default file name is the name option
-   * of the project package.json. It can also be defined as a function taking the
-   * format as an argument.
-   */
-  fileName?: string | ((format: ModuleFormat, entryName: string) => string)
-}
-
-export type LibraryFormats = 'es' | 'cjs' | 'umd' | 'iife' | 'system'
-
-export interface ModulePreloadOptions {
-  /**
-   * Whether to inject a module preload polyfill.
-   * Note: does not apply to library mode.
-   * @default true
-   */
-  polyfill?: boolean
-  /**
-   * Resolve the list of dependencies to preload for a given dynamic import
-   * @experimental
-   */
-  resolveDependencies?: ResolveModulePreloadDependenciesFn
-}
-export interface ResolvedModulePreloadOptions {
-  polyfill: boolean
-  resolveDependencies?: ResolveModulePreloadDependenciesFn
-}
-
-export type ResolveModulePreloadDependenciesFn = (
-  filename: string,
-  deps: string[],
-  context: {
-    hostId: string
-    hostType: 'html' | 'js'
-  },
-) => string[]
-
-export interface ResolvedBuildOptions
-  extends Required<Omit<BuildOptions, 'polyfillModulePreload'>> {
-  modulePreload: false | ResolvedModulePreloadOptions
-}
-
-export function resolveBuildOptions(
-  raw: BuildOptions | undefined,
-  logger: Logger,
-  root: string,
-): ResolvedBuildOptions {
-  const deprecatedPolyfillModulePreload = raw?.polyfillModulePreload
-  if (raw) {
-    const { polyfillModulePreload, ...rest } = raw
-    raw = rest
-    if (deprecatedPolyfillModulePreload !== undefined) {
-      logger.warn(
-        'polyfillModulePreload is deprecated. Use modulePreload.polyfill instead.',
-      )
-    }
-    if (
-      deprecatedPolyfillModulePreload === false &&
-      raw.modulePreload === undefined
-    ) {
-      raw.modulePreload = { polyfill: false }
-    }
-  }
-
-  const modulePreload = raw?.modulePreload
-  const defaultModulePreload = {
-    polyfill: true,
-  }
-
-  const defaultBuildOptions: BuildOptions = {
-    outDir: 'dist',
-    assetsDir: 'assets',
-    assetsInlineLimit: DEFAULT_ASSETS_INLINE_LIMIT,
-    cssCodeSplit: !raw?.lib,
-    sourcemap: false,
-    rollupOptions: {},
-    minify: raw?.ssr ? false : 'esbuild',
-    terserOptions: {},
-    write: true,
-    emptyOutDir: null,
-    copyPublicDir: true,
-    manifest: false,
-    lib: false,
-    ssr: false,
-    ssrManifest: false,
-    ssrEmitAssets: false,
-    reportCompressedSize: true,
-    chunkSizeWarningLimit: 500,
-    watch: null,
-  }
-
-  const userBuildOptions = raw
-    ? mergeConfig(defaultBuildOptions, raw)
-    : defaultBuildOptions
-
-  // @ts-expect-error Fallback options instead of merging
-  const resolved: ResolvedBuildOptions = {
-    target: 'modules',
-    cssTarget: false,
-    ...userBuildOptions,
-    commonjsOptions: {
-      include: [/node_modules/],
-      extensions: ['.js', '.cjs'],
-      ...userBuildOptions.commonjsOptions,
-    },
-    dynamicImportVarsOptions: {
-      warnOnError: true,
-      exclude: [/node_modules/],
-      ...userBuildOptions.dynamicImportVarsOptions,
-    },
-    // Resolve to false | object
-    modulePreload:
-      modulePreload === false
-        ? false
-        : typeof modulePreload === 'object'
-          ? {
-              ...defaultModulePreload,
-              ...modulePreload,
-            }
-          : defaultModulePreload,
-  }
-
-  // handle special build targets
-  if (resolved.target === 'modules') {
-    resolved.target = ESBUILD_MODULES_TARGET
-  } else if (resolved.target === 'esnext' && resolved.minify === 'terser') {
-    try {
-      const terserPackageJsonPath = requireResolveFromRootWithFallback(
-        root,
-        'terser/package.json',
-      )
-      const terserPackageJson = JSON.parse(
-        fs.readFileSync(terserPackageJsonPath, 'utf-8'),
-      )
-      const v = terserPackageJson.version.split('.')
-      if (v[0] === '5' && v[1] < 16) {
-        // esnext + terser 5.16<: limit to es2021 so it can be minified by terser
-        resolved.target = 'es2021'
-      }
-    } catch {}
-  }
-
-  if (!resolved.cssTarget) {
-    resolved.cssTarget = resolved.target
-  }
-
-  // normalize false string into actual false
-  if ((resolved.minify as string) === 'false') {
-    resolved.minify = false
-  } else if (resolved.minify === true) {
-    resolved.minify = 'esbuild'
-  }
-
-  if (resolved.cssMinify == null) {
-    resolved.cssMinify = !!resolved.minify
-  }
-
-  return resolved
-}
-
 export async function resolveBuildPlugins(config: ResolvedConfig): Promise<{
   pre: Plugin[]
   post: Plugin[]
@@ -460,329 +117,6 @@ export async function resolveBuildPlugins(config: ResolvedConfig): Promise<{
   }
 }
 
-/**
- * Bundles the app for production.
- * Returns a Promise containing the build result.
- */
-export async function build(
-  inlineConfig: InlineConfig = {},
-): Promise<RollupOutput | RollupOutput[] | RollupWatcher> {
-  const config = await resolveConfig(
-    inlineConfig,
-    'build',
-    'production',
-    'production',
-  )
-  const options = config.build
-  const { logger } = config
-  const ssr = !!options.ssr
-  const libOptions = options.lib
-
-  logger.info(
-    colors.cyan(
-      `vite v${VERSION} ${colors.green(
-        `building ${ssr ? `SSR bundle ` : ``}for ${config.mode}...`,
-      )}`,
-    ),
-  )
-
-  const resolve = (p: string) => path.resolve(config.root, p)
-  const input = libOptions
-    ? options.rollupOptions?.input ||
-      (typeof libOptions.entry === 'string'
-        ? resolve(libOptions.entry)
-        : Array.isArray(libOptions.entry)
-          ? libOptions.entry.map(resolve)
-          : Object.fromEntries(
-              Object.entries(libOptions.entry).map(([alias, file]) => [
-                alias,
-                resolve(file),
-              ]),
-            ))
-    : typeof options.ssr === 'string'
-      ? resolve(options.ssr)
-      : options.rollupOptions?.input || resolve('index.html')
-
-  if (ssr && typeof input === 'string' && input.endsWith('.html')) {
-    throw new Error(
-      `rollupOptions.input should not be an html file when building for SSR. ` +
-        `Please specify a dedicated SSR entry.`,
-    )
-  }
-  if (config.build.cssCodeSplit === false) {
-    const inputs =
-      typeof input === 'string'
-        ? [input]
-        : Array.isArray(input)
-          ? input
-          : Object.values(input)
-    if (inputs.some((input) => input.endsWith('.css'))) {
-      throw new Error(
-        `When "build.cssCodeSplit: false" is set, "rollupOptions.input" should not include CSS files.`,
-      )
-    }
-  }
-
-  const outDir = resolve(options.outDir)
-
-  // inject ssr arg to plugin load/transform hooks
-  const plugins = (
-    ssr ? config.plugins.map((p) => injectSsrFlagToHooks(p)) : config.plugins
-  ) as Plugin[]
-
-  const rollupOptions: RollupOptions = {
-    preserveEntrySignatures: ssr
-      ? 'allow-extension'
-      : libOptions
-        ? 'strict'
-        : false,
-    cache: config.build.watch ? undefined : false,
-    ...options.rollupOptions,
-    input,
-    plugins,
-    external: options.rollupOptions?.external,
-    onwarn(warning, warn) {
-      onRollupWarning(warning, warn, config)
-    },
-  }
-
-  /**
-   * The stack string usually contains a copy of the message at the start of the stack.
-   * If the stack starts with the message, we remove it and just return the stack trace
-   * portion. Otherwise the original stack trace is used.
-   */
-  function extractStack(e: RollupError) {
-    const { stack, name = 'Error', message } = e
-
-    // If we don't have a stack, not much we can do.
-    if (!stack) {
-      return stack
-    }
-
-    const expectedPrefix = `${name}: ${message}\n`
-    if (stack.startsWith(expectedPrefix)) {
-      return stack.slice(expectedPrefix.length)
-    }
-
-    return stack
-  }
-
-  /**
-   * Esbuild code frames have newlines at the start and end of the frame, rollup doesn't
-   * This function normalizes the frame to match the esbuild format which has more pleasing padding
-   */
-  const normalizeCodeFrame = (frame: string) => {
-    const trimmedPadding = frame.replace(/^\n|\n$/g, '')
-    return `\n${trimmedPadding}\n`
-  }
-
-  const enhanceRollupError = (e: RollupError) => {
-    const stackOnly = extractStack(e)
-
-    let msg = colors.red((e.plugin ? `[${e.plugin}] ` : '') + e.message)
-    if (e.id) {
-      msg += `\nfile: ${colors.cyan(
-        e.id + (e.loc ? `:${e.loc.line}:${e.loc.column}` : ''),
-      )}`
-    }
-    if (e.frame) {
-      msg += `\n` + colors.yellow(normalizeCodeFrame(e.frame))
-    }
-
-    e.message = msg
-
-    // We are rebuilding the stack trace to include the more detailed message at the top.
-    // Previously this code was relying on mutating e.message changing the generated stack
-    // when it was accessed, but we don't have any guarantees that the error we are working
-    // with hasn't already had its stack accessed before we get here.
-    if (stackOnly !== undefined) {
-      e.stack = `${e.message}\n${stackOnly}`
-    }
-  }
-
-  const outputBuildError = (e: RollupError) => {
-    enhanceRollupError(e)
-    clearLine()
-    logger.error(e.message, { error: e })
-  }
-
-  let bundle: RollupBuild | undefined
-  let startTime: number | undefined
-  try {
-    const buildOutputOptions = (output: OutputOptions = {}): OutputOptions => {
-      // @ts-expect-error See https://github.com/vitejs/vite/issues/5812#issuecomment-984345618
-      if (output.output) {
-        logger.warn(
-          `You've set "rollupOptions.output.output" in your config. ` +
-            `This is deprecated and will override all Vite.js default output options. ` +
-            `Please use "rollupOptions.output" instead.`,
-        )
-      }
-      if (output.file) {
-        throw new Error(
-          `Vite does not support "rollupOptions.output.file". ` +
-            `Please use "rollupOptions.output.dir" and "rollupOptions.output.entryFileNames" instead.`,
-        )
-      }
-      if (output.sourcemap) {
-        logger.warnOnce(
-          colors.yellow(
-            `Vite does not support "rollupOptions.output.sourcemap". ` +
-              `Please use "build.sourcemap" instead.`,
-          ),
-        )
-      }
-
-      const ssrNodeBuild = ssr && config.ssr.target === 'node'
-      const ssrWorkerBuild = ssr && config.ssr.target === 'webworker'
-
-      const format = output.format || 'es'
-      const jsExt =
-        ssrNodeBuild || libOptions
-          ? resolveOutputJsExtension(
-              format,
-              findNearestPackageData(config.root, config.packageCache)?.data
-                .type,
-            )
-          : 'js'
-      return {
-        dir: outDir,
-        // Default format is 'es' for regular and for SSR builds
-        format,
-        exports: 'auto',
-        sourcemap: options.sourcemap,
-        name: libOptions ? libOptions.name : undefined,
-        hoistTransitiveImports: libOptions ? false : undefined,
-        // es2015 enables `generatedCode.symbols`
-        // - #764 add `Symbol.toStringTag` when build es module into cjs chunk
-        // - #1048 add `Symbol.toStringTag` for module default export
-        generatedCode: 'es2015',
-        entryFileNames: ssr
-          ? `[name].${jsExt}`
-          : libOptions
-            ? ({ name }) =>
-                resolveLibFilename(
-                  libOptions,
-                  format,
-                  name,
-                  config.root,
-                  jsExt,
-                  config.packageCache,
-                )
-            : path.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
-        chunkFileNames: libOptions
-          ? `[name]-[hash].${jsExt}`
-          : path.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
-        assetFileNames: libOptions
-          ? `[name].[ext]`
-          : path.posix.join(options.assetsDir, `[name]-[hash].[ext]`),
-        inlineDynamicImports:
-          output.format === 'umd' ||
-          output.format === 'iife' ||
-          (ssrWorkerBuild &&
-            (typeof input === 'string' || Object.keys(input).length === 1)),
-        ...output,
-      }
-    }
-
-    // resolve lib mode outputs
-    const outputs = resolveBuildOutputs(
-      options.rollupOptions?.output,
-      libOptions,
-      logger,
-    )
-    const normalizedOutputs: OutputOptions[] = []
-
-    if (Array.isArray(outputs)) {
-      for (const resolvedOutput of outputs) {
-        normalizedOutputs.push(buildOutputOptions(resolvedOutput))
-      }
-    } else {
-      normalizedOutputs.push(buildOutputOptions(outputs))
-    }
-
-    const resolvedOutDirs = getResolvedOutDirs(
-      config.root,
-      options.outDir,
-      options.rollupOptions?.output,
-    )
-    const emptyOutDir = resolveEmptyOutDir(
-      options.emptyOutDir,
-      config.root,
-      resolvedOutDirs,
-      logger,
-    )
-
-    // watch file changes with rollup
-    if (config.build.watch) {
-      logger.info(colors.cyan(`\nwatching for file changes...`))
-
-      const resolvedChokidarOptions = resolveChokidarOptions(
-        config,
-        config.build.watch.chokidar,
-        resolvedOutDirs,
-        emptyOutDir,
-      )
-
-      const { watch } = await import('rollup')
-      const watcher = watch({
-        ...rollupOptions,
-        output: normalizedOutputs,
-        watch: {
-          ...config.build.watch,
-          chokidar: resolvedChokidarOptions,
-        },
-      })
-
-      watcher.on('event', (event) => {
-        if (event.code === 'BUNDLE_START') {
-          logger.info(colors.cyan(`\nbuild started...`))
-          if (options.write) {
-            prepareOutDir(resolvedOutDirs, emptyOutDir, config)
-          }
-        } else if (event.code === 'BUNDLE_END') {
-          event.result.close()
-          logger.info(colors.cyan(`built in ${event.duration}ms.`))
-        } else if (event.code === 'ERROR') {
-          outputBuildError(event.error)
-        }
-      })
-
-      return watcher
-    }
-
-    // write or generate files with rollup
-    const { rollup } = await import('rollup')
-    startTime = Date.now()
-    bundle = await rollup(rollupOptions)
-
-    if (options.write) {
-      prepareOutDir(resolvedOutDirs, emptyOutDir, config)
-    }
-
-    const res: RollupOutput[] = []
-    for (const output of normalizedOutputs) {
-      res.push(await bundle[options.write ? 'write' : 'generate'](output))
-    }
-    logger.info(
-      `${colors.green(`✓ built in ${displayTime(Date.now() - startTime)}`)}`,
-    )
-    return Array.isArray(outputs) ? res : res[0]
-  } catch (e) {
-    enhanceRollupError(e)
-    clearLine()
-    if (startTime) {
-      logger.error(
-        `${colors.red('x')} Build failed in ${displayTime(Date.now() - startTime)}`,
-      )
-      startTime = undefined
-    }
-    throw e
-  } finally {
-    if (bundle) await bundle.close()
-  }
-}
-
 function prepareOutDir(
   outDirs: Set<string>,
   emptyOutDir: boolean | null,
@@ -880,139 +214,6 @@ export function resolveLibFilename(
   return `${name}.${format}.${extension}`
 }
 
-export function resolveBuildOutputs(
-  outputs: OutputOptions | OutputOptions[] | undefined,
-  libOptions: LibraryOptions | false,
-  logger: Logger,
-): OutputOptions | OutputOptions[] | undefined {
-  if (libOptions) {
-    const libHasMultipleEntries =
-      typeof libOptions.entry !== 'string' &&
-      Object.values(libOptions.entry).length > 1
-    const libFormats =
-      libOptions.formats ||
-      (libHasMultipleEntries ? ['es', 'cjs'] : ['es', 'umd'])
-
-    if (!Array.isArray(outputs)) {
-      if (libFormats.includes('umd') || libFormats.includes('iife')) {
-        if (libHasMultipleEntries) {
-          throw new Error(
-            'Multiple entry points are not supported when output formats include "umd" or "iife".',
-          )
-        }
-
-        if (!libOptions.name) {
-          throw new Error(
-            'Option "build.lib.name" is required when output formats include "umd" or "iife".',
-          )
-        }
-      }
-
-      return libFormats.map((format) => ({ ...outputs, format }))
-    }
-
-    // By this point, we know "outputs" is an Array.
-    if (libOptions.formats) {
-      logger.warn(
-        colors.yellow(
-          '"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format.',
-        ),
-      )
-    }
-
-    outputs.forEach((output) => {
-      if (
-        (output.format === 'umd' || output.format === 'iife') &&
-        !output.name
-      ) {
-        throw new Error(
-          'Entries in "build.rollupOptions.output" must specify "name" when the format is "umd" or "iife".',
-        )
-      }
-    })
-  }
-
-  return outputs
-}
-
-const warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`]
-const dynamicImportWarningIgnoreList = [
-  `Unsupported expression`,
-  `statically analyzed`,
-]
-
-function clearLine() {
-  const tty = process.stdout.isTTY && !process.env.CI
-  if (tty) {
-    process.stdout.clearLine(0)
-    process.stdout.cursorTo(0)
-  }
-}
-
-export function onRollupWarning(
-  warning: RollupLog,
-  warn: LoggingFunction,
-  config: ResolvedConfig,
-): void {
-  const viteWarn: LoggingFunction = (warnLog) => {
-    let warning: string | RollupLog
-
-    if (typeof warnLog === 'function') {
-      warning = warnLog()
-    } else {
-      warning = warnLog
-    }
-
-    if (typeof warning === 'object') {
-      if (warning.code === 'UNRESOLVED_IMPORT') {
-        const id = warning.id
-        const exporter = warning.exporter
-        // throw unless it's commonjs external...
-        if (!id || !id.endsWith('?commonjs-external')) {
-          throw new Error(
-            `[vite]: Rollup failed to resolve import "${exporter}" from "${id}".\n` +
-              `This is most likely unintended because it can break your application at runtime.\n` +
-              `If you do want to externalize this module explicitly add it to\n` +
-              `\`build.rollupOptions.external\``,
-          )
-        }
-      }
-
-      if (
-        warning.plugin === 'rollup-plugin-dynamic-import-variables' &&
-        dynamicImportWarningIgnoreList.some((msg) =>
-          warning.message.includes(msg),
-        )
-      ) {
-        return
-      }
-
-      if (warningIgnoreList.includes(warning.code!)) {
-        return
-      }
-
-      if (warning.code === 'PLUGIN_WARNING') {
-        config.logger.warn(
-          `${colors.bold(
-            colors.yellow(`[plugin:${warning.plugin}]`),
-          )} ${colors.yellow(warning.message)}`,
-        )
-        return
-      }
-    }
-
-    warn(warnLog)
-  }
-
-  clearLine()
-  const userOnWarn = config.build.rollupOptions?.onwarn
-  if (userOnWarn) {
-    userOnWarn(warning, viteWarn)
-  } else {
-    viteWarn(warning)
-  }
-}
-
 export function resolveUserExternal(
   user: ExternalOption,
   id: string,
diff --git a/packages/vite/src/node/build/BuildOptions.ts b/packages/vite/src/node/build/BuildOptions.ts
new file mode 100644
index 000000000..7a1707a02
--- /dev/null
+++ b/packages/vite/src/node/build/BuildOptions.ts
@@ -0,0 +1,257 @@
+import type {
+  ExternalOption,
+  InputOption,
+  InternalModuleFormat,
+  LoggingFunction,
+  ModuleFormat,
+  OutputOptions,
+  Plugin,
+  RollupBuild,
+  RollupError,
+  RollupLog,
+  RollupOptions,
+  RollupOutput,
+  RollupWatcher,
+  WatcherOptions,
+} from 'rollup'
+import type { RollupCommonJSOptions } from 'dep-types/commonjs'
+import type { RollupDynamicImportVarsOptions } from 'dep-types/dynamicImportVars'
+import type { TransformOptions } from 'esbuild'
+import { TerserOptions } from 'packages/vite/src/node/plugins/terser';
+
+
+export type LibraryFormats = 'es' | 'cjs' | 'umd' | 'iife' | 'system'
+
+export interface LibraryOptions {
+  /**
+   * Path of library entry
+   */
+  entry: InputOption
+  /**
+   * The name of the exposed global variable. Required when the `formats` option includes
+   * `umd` or `iife`
+   */
+  name?: string
+  /**
+   * Output bundle formats
+   * @default ['es', 'umd']
+   */
+  formats?: LibraryFormats[]
+  /**
+   * The name of the package file output. The default file name is the name option
+   * of the project package.json. It can also be defined as a function taking the
+   * format as an argument.
+   */
+  fileName?: string | ((format: ModuleFormat, entryName: string) => string)
+}
+
+export type ResolveModulePreloadDependenciesFn = (
+  filename: string,
+  deps: string[],
+  context: {
+    hostId: string
+    hostType: 'html' | 'js'
+  },
+) => string[]
+
+export interface ModulePreloadOptions {
+  /**
+   * Whether to inject a module preload polyfill.
+   * Note: does not apply to library mode.
+   * @default true
+   */
+  polyfill?: boolean
+  /**
+   * Resolve the list of dependencies to preload for a given dynamic import
+   * @experimental
+   */
+  resolveDependencies?: ResolveModulePreloadDependenciesFn
+}
+
+export interface BuildOptions {
+  /**
+   * Compatibility transform target. The transform is performed with esbuild
+   * and the lowest supported target is es2015/es6. Note this only handles
+   * syntax transformation and does not cover polyfills (except for dynamic
+   * import)
+   *
+   * Default: 'modules' - Similar to `@babel/preset-env`'s targets.esmodules,
+   * transpile targeting browsers that natively support dynamic es module imports.
+   * https://caniuse.com/es6-module-dynamic-import
+   *
+   * Another special value is 'esnext' - which only performs minimal transpiling
+   * (for minification compat) and assumes native dynamic imports support.
+   *
+   * For custom targets, see https://esbuild.github.io/api/#target and
+   * https://esbuild.github.io/content-types/#javascript for more details.
+   * @default 'modules'
+   */
+  target?: 'modules' | TransformOptions['target'] | false
+  /**
+   * whether to inject module preload polyfill.
+   * Note: does not apply to library mode.
+   * @default true
+   * @deprecated use `modulePreload.polyfill` instead
+   */
+  polyfillModulePreload?: boolean
+  /**
+   * Configure module preload
+   * Note: does not apply to library mode.
+   * @default true
+   */
+  modulePreload?: boolean | ModulePreloadOptions
+  /**
+   * Directory relative from `root` where build output will be placed. If the
+   * directory exists, it will be removed before the build.
+   * @default 'dist'
+   */
+  outDir?: string
+  /**
+   * Directory relative from `outDir` where the built js/css/image assets will
+   * be placed.
+   * @default 'assets'
+   */
+  assetsDir?: string
+  /**
+   * Static asset files smaller than this number (in bytes) will be inlined as
+   * base64 strings. Default limit is `4096` (4 KiB). Set to `0` to disable.
+   * @default 4096
+   */
+  assetsInlineLimit?:
+    | number
+    | ((filePath: string, content: Buffer) => boolean | undefined)
+  /**
+   * Whether to code-split CSS. When enabled, CSS in async chunks will be
+   * inlined as strings in the chunk and inserted via dynamically created
+   * style tags when the chunk is loaded.
+   * @default true
+   */
+  cssCodeSplit?: boolean
+  /**
+   * An optional separate target for CSS minification.
+   * As esbuild only supports configuring targets to mainstream
+   * browsers, users may need this option when they are targeting
+   * a niche browser that comes with most modern JavaScript features
+   * but has poor CSS support, e.g. Android WeChat WebView, which
+   * doesn't support the #RGBA syntax.
+   * @default target
+   */
+  cssTarget?: TransformOptions['target'] | false
+  /**
+   * Override CSS minification specifically instead of defaulting to `build.minify`,
+   * so you can configure minification for JS and CSS separately.
+   * @default 'esbuild'
+   */
+  cssMinify?: boolean | 'esbuild' | 'lightningcss'
+  /**
+   * If `true`, a separate sourcemap file will be created. If 'inline', the
+   * sourcemap will be appended to the resulting output file as data URI.
+   * 'hidden' works like `true` except that the corresponding sourcemap
+   * comments in the bundled files are suppressed.
+   * @default false
+   */
+  sourcemap?: boolean | 'inline' | 'hidden'
+  /**
+   * Set to `false` to disable minification, or specify the minifier to use.
+   * Available options are 'terser' or 'esbuild'.
+   * @default 'esbuild'
+   */
+  minify?: boolean | 'terser' | 'esbuild'
+  /**
+   * Options for terser
+   * https://terser.org/docs/api-reference#minify-options
+   *
+   * In addition, you can also pass a `maxWorkers: number` option to specify the
+   * max number of workers to spawn. Defaults to the number of CPUs minus 1.
+   */
+  terserOptions?: TerserOptions
+  /**
+   * Will be merged with internal rollup options.
+   * https://rollupjs.org/configuration-options/
+   */
+  rollupOptions?: RollupOptions
+  /**
+   * Options to pass on to `@rollup/plugin-commonjs`
+   */
+  commonjsOptions?: RollupCommonJSOptions
+  /**
+   * Options to pass on to `@rollup/plugin-dynamic-import-vars`
+   */
+  dynamicImportVarsOptions?: RollupDynamicImportVarsOptions
+  /**
+   * Whether to write bundle to disk
+   * @default true
+   */
+  write?: boolean
+  /**
+   * Empty outDir on write.
+   * @default true when outDir is a sub directory of project root
+   */
+  emptyOutDir?: boolean | null
+  /**
+   * Copy the public directory to outDir on write.
+   * @default true
+   */
+  copyPublicDir?: boolean
+  /**
+   * Whether to emit a .vite/manifest.json under assets dir to map hash-less filenames
+   * to their hashed versions. Useful when you want to generate your own HTML
+   * instead of using the one generated by Vite.
+   *
+   * Example:
+   *
+   * ```json
+   * {
+   *   "main.js": {
+   *     "file": "main.68fe3fad.js",
+   *     "css": "main.e6b63442.css",
+   *     "imports": [...],
+   *     "dynamicImports": [...]
+   *   }
+   * }
+   * ```
+   * @default false
+   */
+  manifest?: boolean | string
+  /**
+   * Build in library mode. The value should be the global name of the lib in
+   * UMD mode. This will produce esm + cjs + umd bundle formats with default
+   * configurations that are suitable for distributing libraries.
+   * @default false
+   */
+  lib?: LibraryOptions | false
+  /**
+   * Produce SSR oriented build. Note this requires specifying SSR entry via
+   * `rollupOptions.input`.
+   * @default false
+   */
+  ssr?: boolean | string
+  /**
+   * Generate SSR manifest for determining style links and asset preload
+   * directives in production.
+   * @default false
+   */
+  ssrManifest?: boolean | string
+  /**
+   * Emit assets during SSR.
+   * @default false
+   */
+  ssrEmitAssets?: boolean
+  /**
+   * Set to false to disable reporting compressed chunk sizes.
+   * Can slightly improve build speed.
+   * @default true
+   */
+  reportCompressedSize?: boolean
+  /**
+   * Adjust chunk size warning limit (in kB).
+   * @default 500
+   */
+  chunkSizeWarningLimit?: number
+  /**
+   * Rollup watch options
+   * https://rollupjs.org/configuration-options/#watch
+   * @default null
+   */
+  watch?: WatcherOptions | null
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/build/build.ts b/packages/vite/src/node/build/build.ts
new file mode 100644
index 000000000..c61e47ba3
--- /dev/null
+++ b/packages/vite/src/node/build/build.ts
@@ -0,0 +1,350 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import type {
+  ExternalOption,
+  InputOption,
+  InternalModuleFormat,
+  LoggingFunction,
+  ModuleFormat,
+  OutputOptions,
+  Plugin,
+  RollupBuild,
+  RollupError,
+  RollupLog,
+  RollupOptions,
+  RollupOutput,
+  RollupWatcher,
+  WatcherOptions,
+} from 'rollup'
+import { VERSION } from 'packages/vite/src/node/constants';
+import { InlineConfig } from 'packages/vite/src/node/config';
+import { resolveConfig } from 'packages/vite/src/node/config';
+import { displayTime } from 'packages/vite/src/node/utils';
+import { findNearestPackageData } from 'packages/vite/src/node/packages';
+import { getResolvedOutDirs } from 'packages/vite/src/node/watch';
+import { resolveEmptyOutDir } from 'packages/vite/src/node/watch';
+import { resolveChokidarOptions } from 'packages/vite/src/node/watch';
+
+
+/**
+ * Bundles the app for production.
+ * Returns a Promise containing the build result.
+ */
+export async function build(
+  inlineConfig: InlineConfig = {},
+): Promise<RollupOutput | RollupOutput[] | RollupWatcher> {
+  const config = await resolveConfig(
+    inlineConfig,
+    'build',
+    'production',
+    'production',
+  )
+  const options = config.build
+  const { logger } = config
+  const ssr = !!options.ssr
+  const libOptions = options.lib
+
+  logger.info(
+    colors.cyan(
+      `vite v${VERSION} ${colors.green(
+        `building ${ssr ? `SSR bundle ` : ``}for ${config.mode}...`,
+      )}`,
+    ),
+  )
+
+  const resolve = (p: string) => path.resolve(config.root, p)
+  const input = libOptions
+    ? options.rollupOptions?.input ||
+      (typeof libOptions.entry === 'string'
+        ? resolve(libOptions.entry)
+        : Array.isArray(libOptions.entry)
+          ? libOptions.entry.map(resolve)
+          : Object.fromEntries(
+              Object.entries(libOptions.entry).map(([alias, file]) => [
+                alias,
+                resolve(file),
+              ]),
+            ))
+    : typeof options.ssr === 'string'
+      ? resolve(options.ssr)
+      : options.rollupOptions?.input || resolve('index.html')
+
+  if (ssr && typeof input === 'string' && input.endsWith('.html')) {
+    throw new Error(
+      `rollupOptions.input should not be an html file when building for SSR. ` +
+        `Please specify a dedicated SSR entry.`,
+    )
+  }
+  if (config.build.cssCodeSplit === false) {
+    const inputs =
+      typeof input === 'string'
+        ? [input]
+        : Array.isArray(input)
+          ? input
+          : Object.values(input)
+    if (inputs.some((input) => input.endsWith('.css'))) {
+      throw new Error(
+        `When "build.cssCodeSplit: false" is set, "rollupOptions.input" should not include CSS files.`,
+      )
+    }
+  }
+
+  const outDir = resolve(options.outDir)
+
+  // inject ssr arg to plugin load/transform hooks
+  const plugins = (
+    ssr ? config.plugins.map((p) => injectSsrFlagToHooks(p)) : config.plugins
+  ) as Plugin[]
+
+  const rollupOptions: RollupOptions = {
+    preserveEntrySignatures: ssr
+      ? 'allow-extension'
+      : libOptions
+        ? 'strict'
+        : false,
+    cache: config.build.watch ? undefined : false,
+    ...options.rollupOptions,
+    input,
+    plugins,
+    external: options.rollupOptions?.external,
+    onwarn(warning, warn) {
+      onRollupWarning(warning, warn, config)
+    },
+  }
+
+  /**
+   * The stack string usually contains a copy of the message at the start of the stack.
+   * If the stack starts with the message, we remove it and just return the stack trace
+   * portion. Otherwise the original stack trace is used.
+   */
+  function extractStack(e: RollupError) {
+    const { stack, name = 'Error', message } = e
+
+    // If we don't have a stack, not much we can do.
+    if (!stack) {
+      return stack
+    }
+
+    const expectedPrefix = `${name}: ${message}\n`
+    if (stack.startsWith(expectedPrefix)) {
+      return stack.slice(expectedPrefix.length)
+    }
+
+    return stack
+  }
+
+  /**
+   * Esbuild code frames have newlines at the start and end of the frame, rollup doesn't
+   * This function normalizes the frame to match the esbuild format which has more pleasing padding
+   */
+  const normalizeCodeFrame = (frame: string) => {
+    const trimmedPadding = frame.replace(/^\n|\n$/g, '')
+    return `\n${trimmedPadding}\n`
+  }
+
+  const enhanceRollupError = (e: RollupError) => {
+    const stackOnly = extractStack(e)
+
+    let msg = colors.red((e.plugin ? `[${e.plugin}] ` : '') + e.message)
+    if (e.id) {
+      msg += `\nfile: ${colors.cyan(
+        e.id + (e.loc ? `:${e.loc.line}:${e.loc.column}` : ''),
+      )}`
+    }
+    if (e.frame) {
+      msg += `\n` + colors.yellow(normalizeCodeFrame(e.frame))
+    }
+
+    e.message = msg
+
+    // We are rebuilding the stack trace to include the more detailed message at the top.
+    // Previously this code was relying on mutating e.message changing the generated stack
+    // when it was accessed, but we don't have any guarantees that the error we are working
+    // with hasn't already had its stack accessed before we get here.
+    if (stackOnly !== undefined) {
+      e.stack = `${e.message}\n${stackOnly}`
+    }
+  }
+
+  const outputBuildError = (e: RollupError) => {
+    enhanceRollupError(e)
+    clearLine()
+    logger.error(e.message, { error: e })
+  }
+
+  let bundle: RollupBuild | undefined
+  let startTime: number | undefined
+  try {
+    const buildOutputOptions = (output: OutputOptions = {}): OutputOptions => {
+      // @ts-expect-error See https://github.com/vitejs/vite/issues/5812#issuecomment-984345618
+      if (output.output) {
+        logger.warn(
+          `You've set "rollupOptions.output.output" in your config. ` +
+            `This is deprecated and will override all Vite.js default output options. ` +
+            `Please use "rollupOptions.output" instead.`,
+        )
+      }
+      if (output.file) {
+        throw new Error(
+          `Vite does not support "rollupOptions.output.file". ` +
+            `Please use "rollupOptions.output.dir" and "rollupOptions.output.entryFileNames" instead.`,
+        )
+      }
+      if (output.sourcemap) {
+        logger.warnOnce(
+          colors.yellow(
+            `Vite does not support "rollupOptions.output.sourcemap". ` +
+              `Please use "build.sourcemap" instead.`,
+          ),
+        )
+      }
+
+      const ssrNodeBuild = ssr && config.ssr.target === 'node'
+      const ssrWorkerBuild = ssr && config.ssr.target === 'webworker'
+
+      const format = output.format || 'es'
+      const jsExt =
+        ssrNodeBuild || libOptions
+          ? resolveOutputJsExtension(
+              format,
+              findNearestPackageData(config.root, config.packageCache)?.data
+                .type,
+            )
+          : 'js'
+      return {
+        dir: outDir,
+        // Default format is 'es' for regular and for SSR builds
+        format,
+        exports: 'auto',
+        sourcemap: options.sourcemap,
+        name: libOptions ? libOptions.name : undefined,
+        hoistTransitiveImports: libOptions ? false : undefined,
+        // es2015 enables `generatedCode.symbols`
+        // - #764 add `Symbol.toStringTag` when build es module into cjs chunk
+        // - #1048 add `Symbol.toStringTag` for module default export
+        generatedCode: 'es2015',
+        entryFileNames: ssr
+          ? `[name].${jsExt}`
+          : libOptions
+            ? ({ name }) =>
+                resolveLibFilename(
+                  libOptions,
+                  format,
+                  name,
+                  config.root,
+                  jsExt,
+                  config.packageCache,
+                )
+            : path.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
+        chunkFileNames: libOptions
+          ? `[name]-[hash].${jsExt}`
+          : path.posix.join(options.assetsDir, `[name]-[hash].${jsExt}`),
+        assetFileNames: libOptions
+          ? `[name].[ext]`
+          : path.posix.join(options.assetsDir, `[name]-[hash].[ext]`),
+        inlineDynamicImports:
+          output.format === 'umd' ||
+          output.format === 'iife' ||
+          (ssrWorkerBuild &&
+            (typeof input === 'string' || Object.keys(input).length === 1)),
+        ...output,
+      }
+    }
+
+    // resolve lib mode outputs
+    const outputs = resolveBuildOutputs(
+      options.rollupOptions?.output,
+      libOptions,
+      logger,
+    )
+    const normalizedOutputs: OutputOptions[] = []
+
+    if (Array.isArray(outputs)) {
+      for (const resolvedOutput of outputs) {
+        normalizedOutputs.push(buildOutputOptions(resolvedOutput))
+      }
+    } else {
+      normalizedOutputs.push(buildOutputOptions(outputs))
+    }
+
+    const resolvedOutDirs = getResolvedOutDirs(
+      config.root,
+      options.outDir,
+      options.rollupOptions?.output,
+    )
+    const emptyOutDir = resolveEmptyOutDir(
+      options.emptyOutDir,
+      config.root,
+      resolvedOutDirs,
+      logger,
+    )
+
+    // watch file changes with rollup
+    if (config.build.watch) {
+      logger.info(colors.cyan(`\nwatching for file changes...`))
+
+      const resolvedChokidarOptions = resolveChokidarOptions(
+        config,
+        config.build.watch.chokidar,
+        resolvedOutDirs,
+        emptyOutDir,
+      )
+
+      const { watch } = await import('rollup')
+      const watcher = watch({
+        ...rollupOptions,
+        output: normalizedOutputs,
+        watch: {
+          ...config.build.watch,
+          chokidar: resolvedChokidarOptions,
+        },
+      })
+
+      watcher.on('event', (event) => {
+        if (event.code === 'BUNDLE_START') {
+          logger.info(colors.cyan(`\nbuild started...`))
+          if (options.write) {
+            prepareOutDir(resolvedOutDirs, emptyOutDir, config)
+          }
+        } else if (event.code === 'BUNDLE_END') {
+          event.result.close()
+          logger.info(colors.cyan(`built in ${event.duration}ms.`))
+        } else if (event.code === 'ERROR') {
+          outputBuildError(event.error)
+        }
+      })
+
+      return watcher
+    }
+
+    // write or generate files with rollup
+    const { rollup } = await import('rollup')
+    startTime = Date.now()
+    bundle = await rollup(rollupOptions)
+
+    if (options.write) {
+      prepareOutDir(resolvedOutDirs, emptyOutDir, config)
+    }
+
+    const res: RollupOutput[] = []
+    for (const output of normalizedOutputs) {
+      res.push(await bundle[options.write ? 'write' : 'generate'](output))
+    }
+    logger.info(
+      `${colors.green(`✓ built in ${displayTime(Date.now() - startTime)}`)}`,
+    )
+    return Array.isArray(outputs) ? res : res[0]
+  } catch (e) {
+    enhanceRollupError(e)
+    clearLine()
+    if (startTime) {
+      logger.error(
+        `${colors.red('x')} Build failed in ${displayTime(Date.now() - startTime)}`,
+      )
+      startTime = undefined
+    }
+    throw e
+  } finally {
+    if (bundle) await bundle.close()
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/build/onRollupWarning.ts b/packages/vite/src/node/build/onRollupWarning.ts
new file mode 100644
index 000000000..b9697626b
--- /dev/null
+++ b/packages/vite/src/node/build/onRollupWarning.ts
@@ -0,0 +1,98 @@
+import colors from 'picocolors'
+import type {
+  ExternalOption,
+  InputOption,
+  InternalModuleFormat,
+  LoggingFunction,
+  ModuleFormat,
+  OutputOptions,
+  Plugin,
+  RollupBuild,
+  RollupError,
+  RollupLog,
+  RollupOptions,
+  RollupOutput,
+  RollupWatcher,
+  WatcherOptions,
+} from 'rollup'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+
+
+const export warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`]
+
+const export dynamicImportWarningIgnoreList = [
+  `Unsupported expression`,
+  `statically analyzed`,
+]
+
+export function clearLine() {
+  const tty = process.stdout.isTTY && !process.env.CI
+  if (tty) {
+    process.stdout.clearLine(0)
+    process.stdout.cursorTo(0)
+  }
+}
+
+export function onRollupWarning(
+  warning: RollupLog,
+  warn: LoggingFunction,
+  config: ResolvedConfig,
+): void {
+  const viteWarn: LoggingFunction = (warnLog) => {
+    let warning: string | RollupLog
+
+    if (typeof warnLog === 'function') {
+      warning = warnLog()
+    } else {
+      warning = warnLog
+    }
+
+    if (typeof warning === 'object') {
+      if (warning.code === 'UNRESOLVED_IMPORT') {
+        const id = warning.id
+        const exporter = warning.exporter
+        // throw unless it's commonjs external...
+        if (!id || !id.endsWith('?commonjs-external')) {
+          throw new Error(
+            `[vite]: Rollup failed to resolve import "${exporter}" from "${id}".\n` +
+              `This is most likely unintended because it can break your application at runtime.\n` +
+              `If you do want to externalize this module explicitly add it to\n` +
+              `\`build.rollupOptions.external\``,
+          )
+        }
+      }
+
+      if (
+        warning.plugin === 'rollup-plugin-dynamic-import-variables' &&
+        dynamicImportWarningIgnoreList.some((msg) =>
+          warning.message.includes(msg),
+        )
+      ) {
+        return
+      }
+
+      if (warningIgnoreList.includes(warning.code!)) {
+        return
+      }
+
+      if (warning.code === 'PLUGIN_WARNING') {
+        config.logger.warn(
+          `${colors.bold(
+            colors.yellow(`[plugin:${warning.plugin}]`),
+          )} ${colors.yellow(warning.message)}`,
+        )
+        return
+      }
+    }
+
+    warn(warnLog)
+  }
+
+  clearLine()
+  const userOnWarn = config.build.rollupOptions?.onwarn
+  if (userOnWarn) {
+    userOnWarn(warning, viteWarn)
+  } else {
+    viteWarn(warning)
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/build/resolveBuildOptions.ts b/packages/vite/src/node/build/resolveBuildOptions.ts
new file mode 100644
index 000000000..b93e728f4
--- /dev/null
+++ b/packages/vite/src/node/build/resolveBuildOptions.ts
@@ -0,0 +1,391 @@
+import fs from 'node:fs'
+import { DEFAULT_ASSETS_INLINE_LIMIT } from 'packages/vite/src/node/constants';
+import { ESBUILD_MODULES_TARGET } from 'packages/vite/src/node/constants';
+import { requireResolveFromRootWithFallback } from 'packages/vite/src/node/utils';
+import { Logger } from 'packages/vite/src/node/logger';
+import { mergeConfig } from 'packages/vite/src/node/publicUtils';
+import type {
+  ExternalOption,
+  InputOption,
+  InternalModuleFormat,
+  LoggingFunction,
+  ModuleFormat,
+  OutputOptions,
+  Plugin,
+  RollupBuild,
+  RollupError,
+  RollupLog,
+  RollupOptions,
+  RollupOutput,
+  RollupWatcher,
+  WatcherOptions,
+} from 'rollup'
+import type { RollupCommonJSOptions } from 'dep-types/commonjs'
+import type { RollupDynamicImportVarsOptions } from 'dep-types/dynamicImportVars'
+import type { TransformOptions } from 'esbuild'
+import { TerserOptions } from 'packages/vite/src/node/plugins/terser';
+
+
+export type LibraryFormats = 'es' | 'cjs' | 'umd' | 'iife' | 'system'
+
+export interface LibraryOptions {
+  /**
+   * Path of library entry
+   */
+  entry: InputOption
+  /**
+   * The name of the exposed global variable. Required when the `formats` option includes
+   * `umd` or `iife`
+   */
+  name?: string
+  /**
+   * Output bundle formats
+   * @default ['es', 'umd']
+   */
+  formats?: LibraryFormats[]
+  /**
+   * The name of the package file output. The default file name is the name option
+   * of the project package.json. It can also be defined as a function taking the
+   * format as an argument.
+   */
+  fileName?: string | ((format: ModuleFormat, entryName: string) => string)
+}
+
+export type ResolveModulePreloadDependenciesFn = (
+  filename: string,
+  deps: string[],
+  context: {
+    hostId: string
+    hostType: 'html' | 'js'
+  },
+) => string[]
+
+export interface ModulePreloadOptions {
+  /**
+   * Whether to inject a module preload polyfill.
+   * Note: does not apply to library mode.
+   * @default true
+   */
+  polyfill?: boolean
+  /**
+   * Resolve the list of dependencies to preload for a given dynamic import
+   * @experimental
+   */
+  resolveDependencies?: ResolveModulePreloadDependenciesFn
+}
+
+export interface BuildOptions {
+  /**
+   * Compatibility transform target. The transform is performed with esbuild
+   * and the lowest supported target is es2015/es6. Note this only handles
+   * syntax transformation and does not cover polyfills (except for dynamic
+   * import)
+   *
+   * Default: 'modules' - Similar to `@babel/preset-env`'s targets.esmodules,
+   * transpile targeting browsers that natively support dynamic es module imports.
+   * https://caniuse.com/es6-module-dynamic-import
+   *
+   * Another special value is 'esnext' - which only performs minimal transpiling
+   * (for minification compat) and assumes native dynamic imports support.
+   *
+   * For custom targets, see https://esbuild.github.io/api/#target and
+   * https://esbuild.github.io/content-types/#javascript for more details.
+   * @default 'modules'
+   */
+  target?: 'modules' | TransformOptions['target'] | false
+  /**
+   * whether to inject module preload polyfill.
+   * Note: does not apply to library mode.
+   * @default true
+   * @deprecated use `modulePreload.polyfill` instead
+   */
+  polyfillModulePreload?: boolean
+  /**
+   * Configure module preload
+   * Note: does not apply to library mode.
+   * @default true
+   */
+  modulePreload?: boolean | ModulePreloadOptions
+  /**
+   * Directory relative from `root` where build output will be placed. If the
+   * directory exists, it will be removed before the build.
+   * @default 'dist'
+   */
+  outDir?: string
+  /**
+   * Directory relative from `outDir` where the built js/css/image assets will
+   * be placed.
+   * @default 'assets'
+   */
+  assetsDir?: string
+  /**
+   * Static asset files smaller than this number (in bytes) will be inlined as
+   * base64 strings. Default limit is `4096` (4 KiB). Set to `0` to disable.
+   * @default 4096
+   */
+  assetsInlineLimit?:
+    | number
+    | ((filePath: string, content: Buffer) => boolean | undefined)
+  /**
+   * Whether to code-split CSS. When enabled, CSS in async chunks will be
+   * inlined as strings in the chunk and inserted via dynamically created
+   * style tags when the chunk is loaded.
+   * @default true
+   */
+  cssCodeSplit?: boolean
+  /**
+   * An optional separate target for CSS minification.
+   * As esbuild only supports configuring targets to mainstream
+   * browsers, users may need this option when they are targeting
+   * a niche browser that comes with most modern JavaScript features
+   * but has poor CSS support, e.g. Android WeChat WebView, which
+   * doesn't support the #RGBA syntax.
+   * @default target
+   */
+  cssTarget?: TransformOptions['target'] | false
+  /**
+   * Override CSS minification specifically instead of defaulting to `build.minify`,
+   * so you can configure minification for JS and CSS separately.
+   * @default 'esbuild'
+   */
+  cssMinify?: boolean | 'esbuild' | 'lightningcss'
+  /**
+   * If `true`, a separate sourcemap file will be created. If 'inline', the
+   * sourcemap will be appended to the resulting output file as data URI.
+   * 'hidden' works like `true` except that the corresponding sourcemap
+   * comments in the bundled files are suppressed.
+   * @default false
+   */
+  sourcemap?: boolean | 'inline' | 'hidden'
+  /**
+   * Set to `false` to disable minification, or specify the minifier to use.
+   * Available options are 'terser' or 'esbuild'.
+   * @default 'esbuild'
+   */
+  minify?: boolean | 'terser' | 'esbuild'
+  /**
+   * Options for terser
+   * https://terser.org/docs/api-reference#minify-options
+   *
+   * In addition, you can also pass a `maxWorkers: number` option to specify the
+   * max number of workers to spawn. Defaults to the number of CPUs minus 1.
+   */
+  terserOptions?: TerserOptions
+  /**
+   * Will be merged with internal rollup options.
+   * https://rollupjs.org/configuration-options/
+   */
+  rollupOptions?: RollupOptions
+  /**
+   * Options to pass on to `@rollup/plugin-commonjs`
+   */
+  commonjsOptions?: RollupCommonJSOptions
+  /**
+   * Options to pass on to `@rollup/plugin-dynamic-import-vars`
+   */
+  dynamicImportVarsOptions?: RollupDynamicImportVarsOptions
+  /**
+   * Whether to write bundle to disk
+   * @default true
+   */
+  write?: boolean
+  /**
+   * Empty outDir on write.
+   * @default true when outDir is a sub directory of project root
+   */
+  emptyOutDir?: boolean | null
+  /**
+   * Copy the public directory to outDir on write.
+   * @default true
+   */
+  copyPublicDir?: boolean
+  /**
+   * Whether to emit a .vite/manifest.json under assets dir to map hash-less filenames
+   * to their hashed versions. Useful when you want to generate your own HTML
+   * instead of using the one generated by Vite.
+   *
+   * Example:
+   *
+   * ```json
+   * {
+   *   "main.js": {
+   *     "file": "main.68fe3fad.js",
+   *     "css": "main.e6b63442.css",
+   *     "imports": [...],
+   *     "dynamicImports": [...]
+   *   }
+   * }
+   * ```
+   * @default false
+   */
+  manifest?: boolean | string
+  /**
+   * Build in library mode. The value should be the global name of the lib in
+   * UMD mode. This will produce esm + cjs + umd bundle formats with default
+   * configurations that are suitable for distributing libraries.
+   * @default false
+   */
+  lib?: LibraryOptions | false
+  /**
+   * Produce SSR oriented build. Note this requires specifying SSR entry via
+   * `rollupOptions.input`.
+   * @default false
+   */
+  ssr?: boolean | string
+  /**
+   * Generate SSR manifest for determining style links and asset preload
+   * directives in production.
+   * @default false
+   */
+  ssrManifest?: boolean | string
+  /**
+   * Emit assets during SSR.
+   * @default false
+   */
+  ssrEmitAssets?: boolean
+  /**
+   * Set to false to disable reporting compressed chunk sizes.
+   * Can slightly improve build speed.
+   * @default true
+   */
+  reportCompressedSize?: boolean
+  /**
+   * Adjust chunk size warning limit (in kB).
+   * @default 500
+   */
+  chunkSizeWarningLimit?: number
+  /**
+   * Rollup watch options
+   * https://rollupjs.org/configuration-options/#watch
+   * @default null
+   */
+  watch?: WatcherOptions | null
+}
+
+export interface ResolvedModulePreloadOptions {
+  polyfill: boolean
+  resolveDependencies?: ResolveModulePreloadDependenciesFn
+}
+
+export interface ResolvedBuildOptions
+  extends Required<Omit<BuildOptions, 'polyfillModulePreload'>> {
+  modulePreload: false | ResolvedModulePreloadOptions
+}
+
+export function resolveBuildOptions(
+  raw: BuildOptions | undefined,
+  logger: Logger,
+  root: string,
+): ResolvedBuildOptions {
+  const deprecatedPolyfillModulePreload = raw?.polyfillModulePreload
+  if (raw) {
+    const { polyfillModulePreload, ...rest } = raw
+    raw = rest
+    if (deprecatedPolyfillModulePreload !== undefined) {
+      logger.warn(
+        'polyfillModulePreload is deprecated. Use modulePreload.polyfill instead.',
+      )
+    }
+    if (
+      deprecatedPolyfillModulePreload === false &&
+      raw.modulePreload === undefined
+    ) {
+      raw.modulePreload = { polyfill: false }
+    }
+  }
+
+  const modulePreload = raw?.modulePreload
+  const defaultModulePreload = {
+    polyfill: true,
+  }
+
+  const defaultBuildOptions: BuildOptions = {
+    outDir: 'dist',
+    assetsDir: 'assets',
+    assetsInlineLimit: DEFAULT_ASSETS_INLINE_LIMIT,
+    cssCodeSplit: !raw?.lib,
+    sourcemap: false,
+    rollupOptions: {},
+    minify: raw?.ssr ? false : 'esbuild',
+    terserOptions: {},
+    write: true,
+    emptyOutDir: null,
+    copyPublicDir: true,
+    manifest: false,
+    lib: false,
+    ssr: false,
+    ssrManifest: false,
+    ssrEmitAssets: false,
+    reportCompressedSize: true,
+    chunkSizeWarningLimit: 500,
+    watch: null,
+  }
+
+  const userBuildOptions = raw
+    ? mergeConfig(defaultBuildOptions, raw)
+    : defaultBuildOptions
+
+  // @ts-expect-error Fallback options instead of merging
+  const resolved: ResolvedBuildOptions = {
+    target: 'modules',
+    cssTarget: false,
+    ...userBuildOptions,
+    commonjsOptions: {
+      include: [/node_modules/],
+      extensions: ['.js', '.cjs'],
+      ...userBuildOptions.commonjsOptions,
+    },
+    dynamicImportVarsOptions: {
+      warnOnError: true,
+      exclude: [/node_modules/],
+      ...userBuildOptions.dynamicImportVarsOptions,
+    },
+    // Resolve to false | object
+    modulePreload:
+      modulePreload === false
+        ? false
+        : typeof modulePreload === 'object'
+          ? {
+              ...defaultModulePreload,
+              ...modulePreload,
+            }
+          : defaultModulePreload,
+  }
+
+  // handle special build targets
+  if (resolved.target === 'modules') {
+    resolved.target = ESBUILD_MODULES_TARGET
+  } else if (resolved.target === 'esnext' && resolved.minify === 'terser') {
+    try {
+      const terserPackageJsonPath = requireResolveFromRootWithFallback(
+        root,
+        'terser/package.json',
+      )
+      const terserPackageJson = JSON.parse(
+        fs.readFileSync(terserPackageJsonPath, 'utf-8'),
+      )
+      const v = terserPackageJson.version.split('.')
+      if (v[0] === '5' && v[1] < 16) {
+        // esnext + terser 5.16<: limit to es2021 so it can be minified by terser
+        resolved.target = 'es2021'
+      }
+    } catch {}
+  }
+
+  if (!resolved.cssTarget) {
+    resolved.cssTarget = resolved.target
+  }
+
+  // normalize false string into actual false
+  if ((resolved.minify as string) === 'false') {
+    resolved.minify = false
+  } else if (resolved.minify === true) {
+    resolved.minify = 'esbuild'
+  }
+
+  if (resolved.cssMinify == null) {
+    resolved.cssMinify = !!resolved.minify
+  }
+
+  return resolved
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/build/resolveBuildOutputs.ts b/packages/vite/src/node/build/resolveBuildOutputs.ts
new file mode 100644
index 000000000..ac24200f3
--- /dev/null
+++ b/packages/vite/src/node/build/resolveBuildOutputs.ts
@@ -0,0 +1,99 @@
+import colors from 'picocolors'
+import type {
+  ExternalOption,
+  InputOption,
+  InternalModuleFormat,
+  LoggingFunction,
+  ModuleFormat,
+  OutputOptions,
+  Plugin,
+  RollupBuild,
+  RollupError,
+  RollupLog,
+  RollupOptions,
+  RollupOutput,
+  RollupWatcher,
+  WatcherOptions,
+} from 'rollup'
+import { Logger } from 'packages/vite/src/node/logger';
+
+
+export type LibraryFormats = 'es' | 'cjs' | 'umd' | 'iife' | 'system'
+
+export interface LibraryOptions {
+  /**
+   * Path of library entry
+   */
+  entry: InputOption
+  /**
+   * The name of the exposed global variable. Required when the `formats` option includes
+   * `umd` or `iife`
+   */
+  name?: string
+  /**
+   * Output bundle formats
+   * @default ['es', 'umd']
+   */
+  formats?: LibraryFormats[]
+  /**
+   * The name of the package file output. The default file name is the name option
+   * of the project package.json. It can also be defined as a function taking the
+   * format as an argument.
+   */
+  fileName?: string | ((format: ModuleFormat, entryName: string) => string)
+}
+
+export function resolveBuildOutputs(
+  outputs: OutputOptions | OutputOptions[] | undefined,
+  libOptions: LibraryOptions | false,
+  logger: Logger,
+): OutputOptions | OutputOptions[] | undefined {
+  if (libOptions) {
+    const libHasMultipleEntries =
+      typeof libOptions.entry !== 'string' &&
+      Object.values(libOptions.entry).length > 1
+    const libFormats =
+      libOptions.formats ||
+      (libHasMultipleEntries ? ['es', 'cjs'] : ['es', 'umd'])
+
+    if (!Array.isArray(outputs)) {
+      if (libFormats.includes('umd') || libFormats.includes('iife')) {
+        if (libHasMultipleEntries) {
+          throw new Error(
+            'Multiple entry points are not supported when output formats include "umd" or "iife".',
+          )
+        }
+
+        if (!libOptions.name) {
+          throw new Error(
+            'Option "build.lib.name" is required when output formats include "umd" or "iife".',
+          )
+        }
+      }
+
+      return libFormats.map((format) => ({ ...outputs, format }))
+    }
+
+    // By this point, we know "outputs" is an Array.
+    if (libOptions.formats) {
+      logger.warn(
+        colors.yellow(
+          '"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format.',
+        ),
+      )
+    }
+
+    outputs.forEach((output) => {
+      if (
+        (output.format === 'umd' || output.format === 'iife') &&
+        !output.name
+      ) {
+        throw new Error(
+          'Entries in "build.rollupOptions.output" must specify "name" when the format is "umd" or "iife".',
+        )
+      }
+    })
+  }
+
+  return outputs
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/cli.ts b/packages/vite/src/node/cli.ts
index f0fa20921..3be8d25d6 100644
--- a/packages/vite/src/node/cli.ts
+++ b/packages/vite/src/node/cli.ts
@@ -1,15 +1,18 @@
+import { BuildOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { BuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { build } from 'packages/vite/src/node/build/build';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ServerOptions } from 'packages/vite/src/node/server/index/ServerOptions';
+import { ServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
 import path from 'node:path'
 import fs from 'node:fs'
 import { performance } from 'node:perf_hooks'
 import { cac } from 'cac'
 import colors from 'picocolors'
 import { VERSION } from './constants'
-import type { BuildOptions } from './build'
-import type { ServerOptions } from './server'
 import type { CLIShortcut } from './shortcuts'
 import type { LogLevel } from './logger'
 import { createLogger } from './logger'
-import { resolveConfig } from './config'
 
 const cli = cac('vite')
 
@@ -265,7 +268,6 @@ cli
   .option('-w, --watch', `[boolean] rebuilds when modules have changed on disk`)
   .action(async (root: string, options: BuildOptions & GlobalCLIOptions) => {
     filterDuplicateOptions(options)
-    const { build } = await import('./build')
     const buildOptions: BuildOptions = cleanOptions(options)
 
     try {
diff --git a/packages/vite/src/node/config.ts b/packages/vite/src/node/config.ts
index e38e5b595..325205b0f 100644
--- a/packages/vite/src/node/config.ts
+++ b/packages/vite/src/node/config.ts
@@ -1,3 +1,48 @@
+import { BuildOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { BuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { ResolvedBuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { resolveBuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { AppType } from 'packages/vite/src/node/config/UserConfig';
+import { PluginOption } from 'packages/vite/src/node/config/UserConfig';
+import { HTMLOptions } from 'packages/vite/src/node/config/UserConfig';
+import { ExperimentalOptions } from 'packages/vite/src/node/config/UserConfig';
+import { LegacyOptions } from 'packages/vite/src/node/config/UserConfig';
+import { UserConfig } from 'packages/vite/src/node/config/UserConfig';
+import { UserConfig } from 'packages/vite/src/node/config';
+import { ConfigEnv } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedWorkerOptions } from 'packages/vite/src/node/config/resolveConfig';
+import { AppType } from 'packages/vite/src/node/config/resolveConfig';
+import { ExperimentalOptions } from 'packages/vite/src/node/config/resolveConfig';
+import { UserConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { InlineConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { checkBadCharactersInPath } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config';
+import { ConfigEnv } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { AppType } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { ExperimentalOptions } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { UserConfig } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { loadConfigFromFile } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { loadConfigFromFile } from 'packages/vite/src/node/config';
+import { bundleConfigFile } from 'packages/vite/src/node/config/bundleConfigFile';
+import { bundleConfigFile } from 'packages/vite/src/node/config';
+import { DepOptimizationConfig } from 'packages/vite/src/node/optimizer/index/DepOptimizationConfig';
+import { ServerOptions } from 'packages/vite/src/node/server/index/ServerOptions';
+import { ServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { ResolvedServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { resolveServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { resolvePlugin } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { tryNodeResolve } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
 import fs from 'node:fs'
 import fsp from 'node:fs/promises'
 import path from 'node:path'
@@ -21,14 +66,6 @@ import {
   FS_PREFIX,
 } from './constants'
 import type { HookHandler, Plugin, PluginWithRequiredHook } from './plugin'
-import type {
-  BuildOptions,
-  RenderBuiltAssetUrl,
-  ResolvedBuildOptions,
-} from './build'
-import { resolveBuildOptions } from './build'
-import type { ResolvedServerOptions, ServerOptions } from './server'
-import { resolveServerOptions } from './server'
 import type { PreviewOptions, ResolvedPreviewOptions } from './preview'
 import { resolvePreviewOptions } from './preview'
 import {
@@ -59,11 +96,9 @@ import {
   resolvePlugins,
 } from './plugins'
 import type { ESBuildOptions } from './plugins/esbuild'
-import type { InternalResolveOptions, ResolveOptions } from './plugins/resolve'
-import { resolvePlugin, tryNodeResolve } from './plugins/resolve'
 import type { LogLevel, Logger } from './logger'
 import { createLogger } from './logger'
-import type { DepOptimizationConfig, DepOptimizationOptions } from './optimizer'
+import type { DepOptimizationOptions } from './optimizer'
 import type { JsonOptions } from './plugins/json'
 import type { PluginContainer } from './server/pluginContainer'
 import { createPluginContainer } from './server/pluginContainer'
@@ -76,26 +111,6 @@ import { resolveSSROptions } from './ssr'
 const debug = createDebugger('vite:config')
 const promisifiedRealpath = promisify(fs.realpath)
 
-export interface ConfigEnv {
-  /**
-   * 'serve': during dev (`vite` command)
-   * 'build': when building for production (`vite build` command)
-   */
-  command: 'build' | 'serve'
-  mode: string
-  isSsrBuild?: boolean
-  isPreview?: boolean
-}
-
-/**
- * spa: include SPA fallback middleware and configure sirv with `single: true` in preview
- *
- * mpa: only include non-SPA HTML middlewares
- *
- * custom: don't include HTML middlewares
- */
-export type AppType = 'spa' | 'mpa' | 'custom'
-
 export type UserConfigFnObject = (env: ConfigEnv) => UserConfig
 export type UserConfigFnPromise = (env: ConfigEnv) => Promise<UserConfig>
 export type UserConfigFn = (env: ConfigEnv) => UserConfig | Promise<UserConfig>
@@ -120,823 +135,6 @@ export function defineConfig(config: UserConfigExport): UserConfigExport {
   return config
 }
 
-export type PluginOption =
-  | Plugin
-  | false
-  | null
-  | undefined
-  | PluginOption[]
-  | Promise<Plugin | false | null | undefined | PluginOption[]>
-
-export interface UserConfig {
-  /**
-   * Project root directory. Can be an absolute path, or a path relative from
-   * the location of the config file itself.
-   * @default process.cwd()
-   */
-  root?: string
-  /**
-   * Base public path when served in development or production.
-   * @default '/'
-   */
-  base?: string
-  /**
-   * Directory to serve as plain static assets. Files in this directory are
-   * served and copied to build dist dir as-is without transform. The value
-   * can be either an absolute file system path or a path relative to project root.
-   *
-   * Set to `false` or an empty string to disable copied static assets to build dist dir.
-   * @default 'public'
-   */
-  publicDir?: string | false
-  /**
-   * Directory to save cache files. Files in this directory are pre-bundled
-   * deps or some other cache files that generated by vite, which can improve
-   * the performance. You can use `--force` flag or manually delete the directory
-   * to regenerate the cache files. The value can be either an absolute file
-   * system path or a path relative to project root.
-   * Default to `.vite` when no `package.json` is detected.
-   * @default 'node_modules/.vite'
-   */
-  cacheDir?: string
-  /**
-   * Explicitly set a mode to run in. This will override the default mode for
-   * each command, and can be overridden by the command line --mode option.
-   */
-  mode?: string
-  /**
-   * Define global variable replacements.
-   * Entries will be defined on `window` during dev and replaced during build.
-   */
-  define?: Record<string, any>
-  /**
-   * Array of vite plugins to use.
-   */
-  plugins?: PluginOption[]
-  /**
-   * Configure resolver
-   */
-  resolve?: ResolveOptions & { alias?: AliasOptions }
-  /**
-   * HTML related options
-   */
-  html?: HTMLOptions
-  /**
-   * CSS related options (preprocessors and CSS modules)
-   */
-  css?: CSSOptions
-  /**
-   * JSON loading options
-   */
-  json?: JsonOptions
-  /**
-   * Transform options to pass to esbuild.
-   * Or set to `false` to disable esbuild.
-   */
-  esbuild?: ESBuildOptions | false
-  /**
-   * Specify additional picomatch patterns to be treated as static assets.
-   */
-  assetsInclude?: string | RegExp | (string | RegExp)[]
-  /**
-   * Server specific options, e.g. host, port, https...
-   */
-  server?: ServerOptions
-  /**
-   * Build specific options
-   */
-  build?: BuildOptions
-  /**
-   * Preview specific options, e.g. host, port, https...
-   */
-  preview?: PreviewOptions
-  /**
-   * Dep optimization options
-   */
-  optimizeDeps?: DepOptimizationOptions
-  /**
-   * SSR specific options
-   */
-  ssr?: SSROptions
-  /**
-   * Experimental features
-   *
-   * Features under this field could change in the future and might NOT follow semver.
-   * Please be careful and always pin Vite's version when using them.
-   * @experimental
-   */
-  experimental?: ExperimentalOptions
-  /**
-   * Legacy options
-   *
-   * Features under this field only follow semver for patches, they could be removed in a
-   * future minor version. Please always pin Vite's version to a minor when using them.
-   */
-  legacy?: LegacyOptions
-  /**
-   * Log level.
-   * @default 'info'
-   */
-  logLevel?: LogLevel
-  /**
-   * Custom logger.
-   */
-  customLogger?: Logger
-  /**
-   * @default true
-   */
-  clearScreen?: boolean
-  /**
-   * Environment files directory. Can be an absolute path, or a path relative from
-   * root.
-   * @default root
-   */
-  envDir?: string
-  /**
-   * Env variables starts with `envPrefix` will be exposed to your client source code via import.meta.env.
-   * @default 'VITE_'
-   */
-  envPrefix?: string | string[]
-  /**
-   * Worker bundle options
-   */
-  worker?: {
-    /**
-     * Output format for worker bundle
-     * @default 'iife'
-     */
-    format?: 'es' | 'iife'
-    /**
-     * Vite plugins that apply to worker bundle. The plugins returned by this function
-     * should be new instances every time it is called, because they are used for each
-     * rollup worker bundling process.
-     */
-    plugins?: () => PluginOption[]
-    /**
-     * Rollup options to build worker bundle
-     */
-    rollupOptions?: Omit<
-      RollupOptions,
-      'plugins' | 'input' | 'onwarn' | 'preserveEntrySignatures'
-    >
-  }
-  /**
-   * Whether your application is a Single Page Application (SPA),
-   * a Multi-Page Application (MPA), or Custom Application (SSR
-   * and frameworks with custom HTML handling)
-   * @default 'spa'
-   */
-  appType?: AppType
-}
-
-export interface HTMLOptions {
-  /**
-   * A nonce value placeholder that will be used when generating script/style tags.
-   *
-   * Make sure that this placeholder will be replaced with a unique value for each request by the server.
-   */
-  cspNonce?: string
-}
-
-export interface ExperimentalOptions {
-  /**
-   * Append fake `&lang.(ext)` when queries are specified, to preserve the file extension for following plugins to process.
-   *
-   * @experimental
-   * @default false
-   */
-  importGlobRestoreExtension?: boolean
-  /**
-   * Allow finegrain control over assets and public files paths
-   *
-   * @experimental
-   */
-  renderBuiltUrl?: RenderBuiltAssetUrl
-  /**
-   * Enables support of HMR partial accept via `import.meta.hot.acceptExports`.
-   *
-   * @experimental
-   * @default false
-   */
-  hmrPartialAccept?: boolean
-  /**
-   * Skips SSR transform to make it easier to use Vite with Node ESM loaders.
-   * @warning Enabling this will break normal operation of Vite's SSR in development mode.
-   *
-   * @experimental
-   * @default false
-   */
-  skipSsrTransform?: boolean
-}
-
-export interface LegacyOptions {
-  /**
-   * In Vite 4, SSR-externalized modules (modules not bundled and loaded by Node.js at runtime)
-   * are implicitly proxied in dev to automatically handle `default` and `__esModule` access.
-   * However, this does not correctly reflect how it works in the Node.js runtime, causing
-   * inconsistencies between dev and prod.
-   *
-   * In Vite 5, the proxy is removed so dev and prod are consistent, but if you still require
-   * the old behaviour, you can enable this option. If so, please leave your feedback at
-   * https://github.com/vitejs/vite/discussions/14697.
-   */
-  proxySsrExternalModules?: boolean
-}
-
-export interface ResolvedWorkerOptions {
-  format: 'es' | 'iife'
-  plugins: (bundleChain: string[]) => Promise<Plugin[]>
-  rollupOptions: RollupOptions
-}
-
-export interface InlineConfig extends UserConfig {
-  configFile?: string | false
-  envFile?: false
-}
-
-export type ResolvedConfig = Readonly<
-  Omit<
-    UserConfig,
-    'plugins' | 'css' | 'assetsInclude' | 'optimizeDeps' | 'worker' | 'build'
-  > & {
-    configFile: string | undefined
-    configFileDependencies: string[]
-    inlineConfig: InlineConfig
-    root: string
-    base: string
-    /** @internal */
-    decodedBase: string
-    /** @internal */
-    rawBase: string
-    publicDir: string
-    cacheDir: string
-    command: 'build' | 'serve'
-    mode: string
-    isWorker: boolean
-    // in nested worker bundle to find the main config
-    /** @internal */
-    mainConfig: ResolvedConfig | null
-    /** @internal list of bundle entry id. used to detect recursive worker bundle. */
-    bundleChain: string[]
-    isProduction: boolean
-    envDir: string
-    env: Record<string, any>
-    resolve: Required<ResolveOptions> & {
-      alias: Alias[]
-    }
-    plugins: readonly Plugin[]
-    css: ResolvedCSSOptions
-    esbuild: ESBuildOptions | false
-    server: ResolvedServerOptions
-    build: ResolvedBuildOptions
-    preview: ResolvedPreviewOptions
-    ssr: ResolvedSSROptions
-    assetsInclude: (file: string) => boolean
-    logger: Logger
-    createResolver: (options?: Partial<InternalResolveOptions>) => ResolveFn
-    optimizeDeps: DepOptimizationOptions
-    /** @internal */
-    packageCache: PackageCache
-    worker: ResolvedWorkerOptions
-    appType: AppType
-    experimental: ExperimentalOptions
-  } & PluginHookUtils
->
-
-export interface PluginHookUtils {
-  getSortedPlugins: <K extends keyof Plugin>(
-    hookName: K,
-  ) => PluginWithRequiredHook<K>[]
-  getSortedPluginHooks: <K extends keyof Plugin>(
-    hookName: K,
-  ) => NonNullable<HookHandler<Plugin[K]>>[]
-}
-
-export type ResolveFn = (
-  id: string,
-  importer?: string,
-  aliasOnly?: boolean,
-  ssr?: boolean,
-) => Promise<string | undefined>
-
-/**
- * Check and warn if `path` includes characters that don't work well in Vite,
- * such as `#` and `?`.
- */
-function checkBadCharactersInPath(path: string, logger: Logger): void {
-  const badChars = []
-
-  if (path.includes('#')) {
-    badChars.push('#')
-  }
-  if (path.includes('?')) {
-    badChars.push('?')
-  }
-
-  if (badChars.length > 0) {
-    const charString = badChars.map((c) => `"${c}"`).join(' and ')
-    const inflectedChars = badChars.length > 1 ? 'characters' : 'character'
-
-    logger.warn(
-      colors.yellow(
-        `The project root contains the ${charString} ${inflectedChars} (${colors.cyan(
-          path,
-        )}), which may not work when running Vite. Consider renaming the directory to remove the characters.`,
-      ),
-    )
-  }
-}
-
-export async function resolveConfig(
-  inlineConfig: InlineConfig,
-  command: 'build' | 'serve',
-  defaultMode = 'development',
-  defaultNodeEnv = 'development',
-  isPreview = false,
-): Promise<ResolvedConfig> {
-  let config = inlineConfig
-  let configFileDependencies: string[] = []
-  let mode = inlineConfig.mode || defaultMode
-  const isNodeEnvSet = !!process.env.NODE_ENV
-  const packageCache: PackageCache = new Map()
-
-  // some dependencies e.g. @vue/compiler-* relies on NODE_ENV for getting
-  // production-specific behavior, so set it early on
-  if (!isNodeEnvSet) {
-    process.env.NODE_ENV = defaultNodeEnv
-  }
-
-  const configEnv: ConfigEnv = {
-    mode,
-    command,
-    isSsrBuild: command === 'build' && !!config.build?.ssr,
-    isPreview,
-  }
-
-  let { configFile } = config
-  if (configFile !== false) {
-    const loadResult = await loadConfigFromFile(
-      configEnv,
-      configFile,
-      config.root,
-      config.logLevel,
-      config.customLogger,
-    )
-    if (loadResult) {
-      config = mergeConfig(loadResult.config, config)
-      configFile = loadResult.path
-      configFileDependencies = loadResult.dependencies
-    }
-  }
-
-  // user config may provide an alternative mode. But --mode has a higher priority
-  mode = inlineConfig.mode || config.mode || mode
-  configEnv.mode = mode
-
-  const filterPlugin = (p: Plugin) => {
-    if (!p) {
-      return false
-    } else if (!p.apply) {
-      return true
-    } else if (typeof p.apply === 'function') {
-      return p.apply({ ...config, mode }, configEnv)
-    } else {
-      return p.apply === command
-    }
-  }
-
-  // resolve plugins
-  const rawUserPlugins = (
-    (await asyncFlatten(config.plugins || [])) as Plugin[]
-  ).filter(filterPlugin)
-
-  const [prePlugins, normalPlugins, postPlugins] =
-    sortUserPlugins(rawUserPlugins)
-
-  // run config hooks
-  const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins]
-  config = await runConfigHook(config, userPlugins, configEnv)
-
-  // Define logger
-  const logger = createLogger(config.logLevel, {
-    allowClearScreen: config.clearScreen,
-    customLogger: config.customLogger,
-  })
-
-  // resolve root
-  const resolvedRoot = normalizePath(
-    config.root ? path.resolve(config.root) : process.cwd(),
-  )
-
-  checkBadCharactersInPath(resolvedRoot, logger)
-
-  const clientAlias = [
-    {
-      find: /^\/?@vite\/env/,
-      replacement: path.posix.join(FS_PREFIX, normalizePath(ENV_ENTRY)),
-    },
-    {
-      find: /^\/?@vite\/client/,
-      replacement: path.posix.join(FS_PREFIX, normalizePath(CLIENT_ENTRY)),
-    },
-  ]
-
-  // resolve alias with internal client alias
-  const resolvedAlias = normalizeAlias(
-    mergeAlias(clientAlias, config.resolve?.alias || []),
-  )
-
-  const resolveOptions: ResolvedConfig['resolve'] = {
-    mainFields: config.resolve?.mainFields ?? DEFAULT_MAIN_FIELDS,
-    conditions: config.resolve?.conditions ?? [],
-    extensions: config.resolve?.extensions ?? DEFAULT_EXTENSIONS,
-    dedupe: config.resolve?.dedupe ?? [],
-    preserveSymlinks: config.resolve?.preserveSymlinks ?? false,
-    alias: resolvedAlias,
-  }
-
-  if (
-    // @ts-expect-error removed field
-    config.resolve?.browserField === false &&
-    resolveOptions.mainFields.includes('browser')
-  ) {
-    logger.warn(
-      colors.yellow(
-        `\`resolve.browserField\` is set to false, but the option is removed in favour of ` +
-          `the 'browser' string in \`resolve.mainFields\`. You may want to update \`resolve.mainFields\` ` +
-          `to remove the 'browser' string and preserve the previous browser behaviour.`,
-      ),
-    )
-  }
-
-  // load .env files
-  const envDir = config.envDir
-    ? normalizePath(path.resolve(resolvedRoot, config.envDir))
-    : resolvedRoot
-  const userEnv =
-    inlineConfig.envFile !== false &&
-    loadEnv(mode, envDir, resolveEnvPrefix(config))
-
-  // Note it is possible for user to have a custom mode, e.g. `staging` where
-  // development-like behavior is expected. This is indicated by NODE_ENV=development
-  // loaded from `.staging.env` and set by us as VITE_USER_NODE_ENV
-  const userNodeEnv = process.env.VITE_USER_NODE_ENV
-  if (!isNodeEnvSet && userNodeEnv) {
-    if (userNodeEnv === 'development') {
-      process.env.NODE_ENV = 'development'
-    } else {
-      // NODE_ENV=production is not supported as it could break HMR in dev for frameworks like Vue
-      logger.warn(
-        `NODE_ENV=${userNodeEnv} is not supported in the .env file. ` +
-          `Only NODE_ENV=development is supported to create a development build of your project. ` +
-          `If you need to set process.env.NODE_ENV, you can set it in the Vite config instead.`,
-      )
-    }
-  }
-
-  const isProduction = process.env.NODE_ENV === 'production'
-
-  // resolve public base url
-  const isBuild = command === 'build'
-  const relativeBaseShortcut = config.base === '' || config.base === './'
-
-  // During dev, we ignore relative base and fallback to '/'
-  // For the SSR build, relative base isn't possible by means
-  // of import.meta.url.
-  const resolvedBase = relativeBaseShortcut
-    ? !isBuild || config.build?.ssr
-      ? '/'
-      : './'
-    : (resolveBaseUrl(config.base, isBuild, logger) ?? '/')
-
-  const resolvedBuildOptions = resolveBuildOptions(
-    config.build,
-    logger,
-    resolvedRoot,
-  )
-
-  // resolve cache directory
-  const pkgDir = findNearestPackageData(resolvedRoot, packageCache)?.dir
-  const cacheDir = normalizePath(
-    config.cacheDir
-      ? path.resolve(resolvedRoot, config.cacheDir)
-      : pkgDir
-        ? path.join(pkgDir, `node_modules/.vite`)
-        : path.join(resolvedRoot, `.vite`),
-  )
-
-  const assetsFilter =
-    config.assetsInclude &&
-    (!Array.isArray(config.assetsInclude) || config.assetsInclude.length)
-      ? createFilter(config.assetsInclude)
-      : () => false
-
-  // create an internal resolver to be used in special scenarios, e.g.
-  // optimizer & handling css @imports
-  const createResolver: ResolvedConfig['createResolver'] = (options) => {
-    let aliasContainer: PluginContainer | undefined
-    let resolverContainer: PluginContainer | undefined
-    return async (id, importer, aliasOnly, ssr) => {
-      let container: PluginContainer
-      if (aliasOnly) {
-        container =
-          aliasContainer ||
-          (aliasContainer = await createPluginContainer({
-            ...resolved,
-            plugins: [aliasPlugin({ entries: resolved.resolve.alias })],
-          }))
-      } else {
-        container =
-          resolverContainer ||
-          (resolverContainer = await createPluginContainer({
-            ...resolved,
-            plugins: [
-              aliasPlugin({ entries: resolved.resolve.alias }),
-              resolvePlugin({
-                ...resolved.resolve,
-                root: resolvedRoot,
-                isProduction,
-                isBuild: command === 'build',
-                ssrConfig: resolved.ssr,
-                asSrc: true,
-                preferRelative: false,
-                tryIndex: true,
-                ...options,
-                idOnly: true,
-                fsUtils: getFsUtils(resolved),
-              }),
-            ],
-          }))
-      }
-      return (
-        await container.resolveId(id, importer, {
-          ssr,
-          scan: options?.scan,
-        })
-      )?.id
-    }
-  }
-
-  const { publicDir } = config
-  const resolvedPublicDir =
-    publicDir !== false && publicDir !== ''
-      ? normalizePath(
-          path.resolve(
-            resolvedRoot,
-            typeof publicDir === 'string' ? publicDir : 'public',
-          ),
-        )
-      : ''
-
-  const server = resolveServerOptions(resolvedRoot, config.server, logger)
-  const ssr = resolveSSROptions(config.ssr, resolveOptions.preserveSymlinks)
-
-  const optimizeDeps = config.optimizeDeps || {}
-
-  const BASE_URL = resolvedBase
-
-  let resolved: ResolvedConfig
-
-  let createUserWorkerPlugins = config.worker?.plugins
-  if (Array.isArray(createUserWorkerPlugins)) {
-    // @ts-expect-error backward compatibility
-    createUserWorkerPlugins = () => config.worker?.plugins
-
-    logger.warn(
-      colors.yellow(
-        `worker.plugins is now a function that returns an array of plugins. ` +
-          `Please update your Vite config accordingly.\n`,
-      ),
-    )
-  }
-
-  const createWorkerPlugins = async function (bundleChain: string[]) {
-    // Some plugins that aren't intended to work in the bundling of workers (doing post-processing at build time for example).
-    // And Plugins may also have cached that could be corrupted by being used in these extra rollup calls.
-    // So we need to separate the worker plugin from the plugin that vite needs to run.
-    const rawWorkerUserPlugins = (
-      (await asyncFlatten(createUserWorkerPlugins?.() || [])) as Plugin[]
-    ).filter(filterPlugin)
-
-    // resolve worker
-    let workerConfig = mergeConfig({}, config)
-    const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] =
-      sortUserPlugins(rawWorkerUserPlugins)
-
-    // run config hooks
-    const workerUserPlugins = [
-      ...workerPrePlugins,
-      ...workerNormalPlugins,
-      ...workerPostPlugins,
-    ]
-    workerConfig = await runConfigHook(
-      workerConfig,
-      workerUserPlugins,
-      configEnv,
-    )
-
-    const workerResolved: ResolvedConfig = {
-      ...workerConfig,
-      ...resolved,
-      isWorker: true,
-      mainConfig: resolved,
-      bundleChain,
-    }
-    const resolvedWorkerPlugins = await resolvePlugins(
-      workerResolved,
-      workerPrePlugins,
-      workerNormalPlugins,
-      workerPostPlugins,
-    )
-
-    // run configResolved hooks
-    await Promise.all(
-      createPluginHookUtils(resolvedWorkerPlugins)
-        .getSortedPluginHooks('configResolved')
-        .map((hook) => hook(workerResolved)),
-    )
-
-    return resolvedWorkerPlugins
-  }
-
-  const resolvedWorkerOptions: ResolvedWorkerOptions = {
-    format: config.worker?.format || 'iife',
-    plugins: createWorkerPlugins,
-    rollupOptions: config.worker?.rollupOptions || {},
-  }
-
-  const base = withTrailingSlash(resolvedBase)
-
-  resolved = {
-    configFile: configFile ? normalizePath(configFile) : undefined,
-    configFileDependencies: configFileDependencies.map((name) =>
-      normalizePath(path.resolve(name)),
-    ),
-    inlineConfig,
-    root: resolvedRoot,
-    base,
-    decodedBase: decodeURI(base),
-    rawBase: resolvedBase,
-    resolve: resolveOptions,
-    publicDir: resolvedPublicDir,
-    cacheDir,
-    command,
-    mode,
-    ssr,
-    isWorker: false,
-    mainConfig: null,
-    bundleChain: [],
-    isProduction,
-    plugins: userPlugins,
-    css: resolveCSSOptions(config.css),
-    esbuild:
-      config.esbuild === false
-        ? false
-        : {
-            jsxDev: !isProduction,
-            ...config.esbuild,
-          },
-    server,
-    build: resolvedBuildOptions,
-    preview: resolvePreviewOptions(config.preview, server),
-    envDir,
-    env: {
-      ...userEnv,
-      BASE_URL,
-      MODE: mode,
-      DEV: !isProduction,
-      PROD: isProduction,
-    },
-    assetsInclude(file: string) {
-      return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file)
-    },
-    logger,
-    packageCache,
-    createResolver,
-    optimizeDeps: {
-      holdUntilCrawlEnd: true,
-      ...optimizeDeps,
-      esbuildOptions: {
-        preserveSymlinks: resolveOptions.preserveSymlinks,
-        ...optimizeDeps.esbuildOptions,
-      },
-    },
-    worker: resolvedWorkerOptions,
-    appType: config.appType ?? 'spa',
-    experimental: {
-      importGlobRestoreExtension: false,
-      hmrPartialAccept: false,
-      ...config.experimental,
-    },
-    getSortedPlugins: undefined!,
-    getSortedPluginHooks: undefined!,
-  }
-  resolved = {
-    ...config,
-    ...resolved,
-  }
-  ;(resolved.plugins as Plugin[]) = await resolvePlugins(
-    resolved,
-    prePlugins,
-    normalPlugins,
-    postPlugins,
-  )
-  Object.assign(resolved, createPluginHookUtils(resolved.plugins))
-
-  // call configResolved hooks
-  await Promise.all(
-    resolved
-      .getSortedPluginHooks('configResolved')
-      .map((hook) => hook(resolved)),
-  )
-
-  optimizeDepsDisabledBackwardCompatibility(resolved, resolved.optimizeDeps)
-  optimizeDepsDisabledBackwardCompatibility(
-    resolved,
-    resolved.ssr.optimizeDeps,
-    'ssr.',
-  )
-
-  debug?.(`using resolved config: %O`, {
-    ...resolved,
-    plugins: resolved.plugins.map((p) => p.name),
-    worker: {
-      ...resolved.worker,
-      plugins: `() => plugins`,
-    },
-  })
-
-  // validate config
-
-  if (
-    config.build?.terserOptions &&
-    config.build.minify &&
-    config.build.minify !== 'terser'
-  ) {
-    logger.warn(
-      colors.yellow(
-        `build.terserOptions is specified but build.minify is not set to use Terser. ` +
-          `Note Vite now defaults to use esbuild for minification. If you still ` +
-          `prefer Terser, set build.minify to "terser".`,
-      ),
-    )
-  }
-
-  // Check if all assetFileNames have the same reference.
-  // If not, display a warn for user.
-  const outputOption = config.build?.rollupOptions?.output ?? []
-  // Use isArray to narrow its type to array
-  if (Array.isArray(outputOption)) {
-    const assetFileNamesList = outputOption.map(
-      (output) => output.assetFileNames,
-    )
-    if (assetFileNamesList.length > 1) {
-      const firstAssetFileNames = assetFileNamesList[0]
-      const hasDifferentReference = assetFileNamesList.some(
-        (assetFileNames) => assetFileNames !== firstAssetFileNames,
-      )
-      if (hasDifferentReference) {
-        resolved.logger.warn(
-          colors.yellow(`
-assetFileNames isn't equal for every build.rollupOptions.output. A single pattern across all outputs is supported by Vite.
-`),
-        )
-      }
-    }
-  }
-
-  // Warn about removal of experimental features
-  if (
-    // @ts-expect-error Option removed
-    config.legacy?.buildSsrCjsExternalHeuristics ||
-    // @ts-expect-error Option removed
-    config.ssr?.format === 'cjs'
-  ) {
-    resolved.logger.warn(
-      colors.yellow(`
-(!) Experimental legacy.buildSsrCjsExternalHeuristics and ssr.format were be removed in Vite 5.
-    The only SSR Output format is ESM. Find more information at https://github.com/vitejs/vite/discussions/13816.
-`),
-    )
-  }
-
-  const resolvedBuildOutDir = normalizePath(
-    path.resolve(resolved.root, resolved.build.outDir),
-  )
-  if (
-    isParentDirectory(resolvedBuildOutDir, resolved.root) ||
-    resolvedBuildOutDir === resolved.root
-  ) {
-    resolved.logger.warn(
-      colors.yellow(`
-(!) build.outDir must not be the same directory of root or a parent directory of root as this could cause Vite to overwriting source files with build outputs.
-`),
-    )
-  }
-
-  return resolved
-}
-
 /**
  * Resolve base url. Note that some users use Vite to build for non-web targets like
  * electron or expects to deploy
@@ -999,227 +197,6 @@ export function sortUserPlugins(
   return [prePlugins, normalPlugins, postPlugins]
 }
 
-export async function loadConfigFromFile(
-  configEnv: ConfigEnv,
-  configFile?: string,
-  configRoot: string = process.cwd(),
-  logLevel?: LogLevel,
-  customLogger?: Logger,
-): Promise<{
-  path: string
-  config: UserConfig
-  dependencies: string[]
-} | null> {
-  const start = performance.now()
-  const getTime = () => `${(performance.now() - start).toFixed(2)}ms`
-
-  let resolvedPath: string | undefined
-
-  if (configFile) {
-    // explicit config path is always resolved from cwd
-    resolvedPath = path.resolve(configFile)
-  } else {
-    // implicit config file loaded from inline root (if present)
-    // otherwise from cwd
-    for (const filename of DEFAULT_CONFIG_FILES) {
-      const filePath = path.resolve(configRoot, filename)
-      if (!fs.existsSync(filePath)) continue
-
-      resolvedPath = filePath
-      break
-    }
-  }
-
-  if (!resolvedPath) {
-    debug?.('no config file found.')
-    return null
-  }
-
-  const isESM = isFilePathESM(resolvedPath)
-
-  try {
-    const bundled = await bundleConfigFile(resolvedPath, isESM)
-    const userConfig = await loadConfigFromBundledFile(
-      resolvedPath,
-      bundled.code,
-      isESM,
-    )
-    debug?.(`bundled config file loaded in ${getTime()}`)
-
-    const config = await (typeof userConfig === 'function'
-      ? userConfig(configEnv)
-      : userConfig)
-    if (!isObject(config)) {
-      throw new Error(`config must export or return an object.`)
-    }
-    return {
-      path: normalizePath(resolvedPath),
-      config,
-      dependencies: bundled.dependencies,
-    }
-  } catch (e) {
-    createLogger(logLevel, { customLogger }).error(
-      colors.red(`failed to load config from ${resolvedPath}`),
-      {
-        error: e,
-      },
-    )
-    throw e
-  }
-}
-
-async function bundleConfigFile(
-  fileName: string,
-  isESM: boolean,
-): Promise<{ code: string; dependencies: string[] }> {
-  const dirnameVarName = '__vite_injected_original_dirname'
-  const filenameVarName = '__vite_injected_original_filename'
-  const importMetaUrlVarName = '__vite_injected_original_import_meta_url'
-  const result = await build({
-    absWorkingDir: process.cwd(),
-    entryPoints: [fileName],
-    write: false,
-    target: [`node${process.versions.node}`],
-    platform: 'node',
-    bundle: true,
-    format: isESM ? 'esm' : 'cjs',
-    mainFields: ['main'],
-    sourcemap: 'inline',
-    metafile: true,
-    define: {
-      __dirname: dirnameVarName,
-      __filename: filenameVarName,
-      'import.meta.url': importMetaUrlVarName,
-      'import.meta.dirname': dirnameVarName,
-      'import.meta.filename': filenameVarName,
-    },
-    plugins: [
-      {
-        name: 'externalize-deps',
-        setup(build) {
-          const packageCache = new Map()
-          const resolveByViteResolver = (
-            id: string,
-            importer: string,
-            isRequire: boolean,
-          ) => {
-            return tryNodeResolve(
-              id,
-              importer,
-              {
-                root: path.dirname(fileName),
-                isBuild: true,
-                isProduction: true,
-                preferRelative: false,
-                tryIndex: true,
-                mainFields: [],
-                conditions: [],
-                overrideConditions: ['node'],
-                dedupe: [],
-                extensions: DEFAULT_EXTENSIONS,
-                preserveSymlinks: false,
-                packageCache,
-                isRequire,
-              },
-              false,
-            )?.id
-          }
-
-          // externalize bare imports
-          build.onResolve(
-            { filter: /^[^.].*/ },
-            async ({ path: id, importer, kind }) => {
-              if (
-                kind === 'entry-point' ||
-                path.isAbsolute(id) ||
-                isNodeBuiltin(id)
-              ) {
-                return
-              }
-
-              // With the `isNodeBuiltin` check above, this check captures if the builtin is a
-              // non-node built-in, which esbuild doesn't know how to handle. In that case, we
-              // externalize it so the non-node runtime handles it instead.
-              if (isBuiltin(id)) {
-                return { external: true }
-              }
-
-              const isImport = isESM || kind === 'dynamic-import'
-              let idFsPath: string | undefined
-              try {
-                idFsPath = resolveByViteResolver(id, importer, !isImport)
-              } catch (e) {
-                if (!isImport) {
-                  let canResolveWithImport = false
-                  try {
-                    canResolveWithImport = !!resolveByViteResolver(
-                      id,
-                      importer,
-                      false,
-                    )
-                  } catch {}
-                  if (canResolveWithImport) {
-                    throw new Error(
-                      `Failed to resolve ${JSON.stringify(
-                        id,
-                      )}. This package is ESM only but it was tried to load by \`require\`. See https://vitejs.dev/guide/troubleshooting.html#this-package-is-esm-only for more details.`,
-                    )
-                  }
-                }
-                throw e
-              }
-              if (idFsPath && isImport) {
-                idFsPath = pathToFileURL(idFsPath).href
-              }
-              if (
-                idFsPath &&
-                !isImport &&
-                isFilePathESM(idFsPath, packageCache)
-              ) {
-                throw new Error(
-                  `${JSON.stringify(
-                    id,
-                  )} resolved to an ESM file. ESM file cannot be loaded by \`require\`. See https://vitejs.dev/guide/troubleshooting.html#this-package-is-esm-only for more details.`,
-                )
-              }
-              return {
-                path: idFsPath,
-                external: true,
-              }
-            },
-          )
-        },
-      },
-      {
-        name: 'inject-file-scope-variables',
-        setup(build) {
-          build.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
-            const contents = await fsp.readFile(args.path, 'utf-8')
-            const injectValues =
-              `const ${dirnameVarName} = ${JSON.stringify(
-                path.dirname(args.path),
-              )};` +
-              `const ${filenameVarName} = ${JSON.stringify(args.path)};` +
-              `const ${importMetaUrlVarName} = ${JSON.stringify(
-                pathToFileURL(args.path).href,
-              )};`
-
-            return {
-              loader: args.path.endsWith('ts') ? 'ts' : 'js',
-              contents: injectValues + contents,
-            }
-          })
-        },
-      },
-    ],
-  })
-  const { text } = result.outputFiles[0]
-  return {
-    code: text,
-    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : [],
-  }
-}
-
 interface NodeModuleWithCompile extends NodeModule {
   _compile(code: string, filename: string): any
 }
diff --git a/packages/vite/src/node/config/UserConfig.ts b/packages/vite/src/node/config/UserConfig.ts
new file mode 100644
index 000000000..5aa2ffede
--- /dev/null
+++ b/packages/vite/src/node/config/UserConfig.ts
@@ -0,0 +1,248 @@
+import type { Alias, AliasOptions } from 'dep-types/alias'
+import type { RollupOptions } from 'rollup'
+import { BuildOptions } from 'packages/vite/src/node/build';
+import { ServerOptions } from 'packages/vite/src/node/server/index';
+import { PreviewOptions } from 'packages/vite/src/node/preview';
+import { CSSOptions } from 'packages/vite/src/node/plugins/css';
+import { ESBuildOptions } from 'packages/vite/src/node/plugins/esbuild';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve';
+import { LogLevel } from 'packages/vite/src/node/logger';
+import { Logger } from 'packages/vite/src/node/logger';
+import { DepOptimizationOptions } from 'packages/vite/src/node/optimizer/index';
+import { JsonOptions } from 'packages/vite/src/node/plugins/json';
+import { SSROptions } from 'packages/vite/src/node/ssr/index';
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { RenderBuiltAssetUrl } from 'packages/vite/src/node/build';
+
+
+/**
+ * spa: include SPA fallback middleware and configure sirv with `single: true` in preview
+ *
+ * mpa: only include non-SPA HTML middlewares
+ *
+ * custom: don't include HTML middlewares
+ */
+export type AppType = 'spa' | 'mpa' | 'custom'
+
+export type PluginOption =
+  | Plugin
+  | false
+  | null
+  | undefined
+  | PluginOption[]
+  | Promise<Plugin | false | null | undefined | PluginOption[]>
+
+export interface HTMLOptions {
+  /**
+   * A nonce value placeholder that will be used when generating script/style tags.
+   *
+   * Make sure that this placeholder will be replaced with a unique value for each request by the server.
+   */
+  cspNonce?: string
+}
+
+export interface ExperimentalOptions {
+  /**
+   * Append fake `&lang.(ext)` when queries are specified, to preserve the file extension for following plugins to process.
+   *
+   * @experimental
+   * @default false
+   */
+  importGlobRestoreExtension?: boolean
+  /**
+   * Allow finegrain control over assets and public files paths
+   *
+   * @experimental
+   */
+  renderBuiltUrl?: RenderBuiltAssetUrl
+  /**
+   * Enables support of HMR partial accept via `import.meta.hot.acceptExports`.
+   *
+   * @experimental
+   * @default false
+   */
+  hmrPartialAccept?: boolean
+  /**
+   * Skips SSR transform to make it easier to use Vite with Node ESM loaders.
+   * @warning Enabling this will break normal operation of Vite's SSR in development mode.
+   *
+   * @experimental
+   * @default false
+   */
+  skipSsrTransform?: boolean
+}
+
+export interface LegacyOptions {
+  /**
+   * In Vite 4, SSR-externalized modules (modules not bundled and loaded by Node.js at runtime)
+   * are implicitly proxied in dev to automatically handle `default` and `__esModule` access.
+   * However, this does not correctly reflect how it works in the Node.js runtime, causing
+   * inconsistencies between dev and prod.
+   *
+   * In Vite 5, the proxy is removed so dev and prod are consistent, but if you still require
+   * the old behaviour, you can enable this option. If so, please leave your feedback at
+   * https://github.com/vitejs/vite/discussions/14697.
+   */
+  proxySsrExternalModules?: boolean
+}
+
+export interface UserConfig {
+  /**
+   * Project root directory. Can be an absolute path, or a path relative from
+   * the location of the config file itself.
+   * @default process.cwd()
+   */
+  root?: string
+  /**
+   * Base public path when served in development or production.
+   * @default '/'
+   */
+  base?: string
+  /**
+   * Directory to serve as plain static assets. Files in this directory are
+   * served and copied to build dist dir as-is without transform. The value
+   * can be either an absolute file system path or a path relative to project root.
+   *
+   * Set to `false` or an empty string to disable copied static assets to build dist dir.
+   * @default 'public'
+   */
+  publicDir?: string | false
+  /**
+   * Directory to save cache files. Files in this directory are pre-bundled
+   * deps or some other cache files that generated by vite, which can improve
+   * the performance. You can use `--force` flag or manually delete the directory
+   * to regenerate the cache files. The value can be either an absolute file
+   * system path or a path relative to project root.
+   * Default to `.vite` when no `package.json` is detected.
+   * @default 'node_modules/.vite'
+   */
+  cacheDir?: string
+  /**
+   * Explicitly set a mode to run in. This will override the default mode for
+   * each command, and can be overridden by the command line --mode option.
+   */
+  mode?: string
+  /**
+   * Define global variable replacements.
+   * Entries will be defined on `window` during dev and replaced during build.
+   */
+  define?: Record<string, any>
+  /**
+   * Array of vite plugins to use.
+   */
+  plugins?: PluginOption[]
+  /**
+   * Configure resolver
+   */
+  resolve?: ResolveOptions & { alias?: AliasOptions }
+  /**
+   * HTML related options
+   */
+  html?: HTMLOptions
+  /**
+   * CSS related options (preprocessors and CSS modules)
+   */
+  css?: CSSOptions
+  /**
+   * JSON loading options
+   */
+  json?: JsonOptions
+  /**
+   * Transform options to pass to esbuild.
+   * Or set to `false` to disable esbuild.
+   */
+  esbuild?: ESBuildOptions | false
+  /**
+   * Specify additional picomatch patterns to be treated as static assets.
+   */
+  assetsInclude?: string | RegExp | (string | RegExp)[]
+  /**
+   * Server specific options, e.g. host, port, https...
+   */
+  server?: ServerOptions
+  /**
+   * Build specific options
+   */
+  build?: BuildOptions
+  /**
+   * Preview specific options, e.g. host, port, https...
+   */
+  preview?: PreviewOptions
+  /**
+   * Dep optimization options
+   */
+  optimizeDeps?: DepOptimizationOptions
+  /**
+   * SSR specific options
+   */
+  ssr?: SSROptions
+  /**
+   * Experimental features
+   *
+   * Features under this field could change in the future and might NOT follow semver.
+   * Please be careful and always pin Vite's version when using them.
+   * @experimental
+   */
+  experimental?: ExperimentalOptions
+  /**
+   * Legacy options
+   *
+   * Features under this field only follow semver for patches, they could be removed in a
+   * future minor version. Please always pin Vite's version to a minor when using them.
+   */
+  legacy?: LegacyOptions
+  /**
+   * Log level.
+   * @default 'info'
+   */
+  logLevel?: LogLevel
+  /**
+   * Custom logger.
+   */
+  customLogger?: Logger
+  /**
+   * @default true
+   */
+  clearScreen?: boolean
+  /**
+   * Environment files directory. Can be an absolute path, or a path relative from
+   * root.
+   * @default root
+   */
+  envDir?: string
+  /**
+   * Env variables starts with `envPrefix` will be exposed to your client source code via import.meta.env.
+   * @default 'VITE_'
+   */
+  envPrefix?: string | string[]
+  /**
+   * Worker bundle options
+   */
+  worker?: {
+    /**
+     * Output format for worker bundle
+     * @default 'iife'
+     */
+    format?: 'es' | 'iife'
+    /**
+     * Vite plugins that apply to worker bundle. The plugins returned by this function
+     * should be new instances every time it is called, because they are used for each
+     * rollup worker bundling process.
+     */
+    plugins?: () => PluginOption[]
+    /**
+     * Rollup options to build worker bundle
+     */
+    rollupOptions?: Omit<
+      RollupOptions,
+      'plugins' | 'input' | 'onwarn' | 'preserveEntrySignatures'
+    >
+  }
+  /**
+   * Whether your application is a Single Page Application (SPA),
+   * a Multi-Page Application (MPA), or Custom Application (SSR
+   * and frameworks with custom HTML handling)
+   * @default 'spa'
+   */
+  appType?: AppType
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/config/bundleConfigFile.ts b/packages/vite/src/node/config/bundleConfigFile.ts
new file mode 100644
index 000000000..74fc22cfd
--- /dev/null
+++ b/packages/vite/src/node/config/bundleConfigFile.ts
@@ -0,0 +1,158 @@
+import path from 'node:path'
+import { build } from 'esbuild'
+import { isNodeBuiltin } from 'packages/vite/src/node/utils';
+import { isBuiltin } from 'packages/vite/src/node/utils';
+import { isFilePathESM } from 'packages/vite/src/node/utils';
+
+
+export async function bundleConfigFile(
+  fileName: string,
+  isESM: boolean,
+): Promise<{ code: string; dependencies: string[] }> {
+  const dirnameVarName = '__vite_injected_original_dirname'
+  const filenameVarName = '__vite_injected_original_filename'
+  const importMetaUrlVarName = '__vite_injected_original_import_meta_url'
+  const result = await build({
+    absWorkingDir: process.cwd(),
+    entryPoints: [fileName],
+    write: false,
+    target: [`node${process.versions.node}`],
+    platform: 'node',
+    bundle: true,
+    format: isESM ? 'esm' : 'cjs',
+    mainFields: ['main'],
+    sourcemap: 'inline',
+    metafile: true,
+    define: {
+      __dirname: dirnameVarName,
+      __filename: filenameVarName,
+      'import.meta.url': importMetaUrlVarName,
+      'import.meta.dirname': dirnameVarName,
+      'import.meta.filename': filenameVarName,
+    },
+    plugins: [
+      {
+        name: 'externalize-deps',
+        setup(build) {
+          const packageCache = new Map()
+          const resolveByViteResolver = (
+            id: string,
+            importer: string,
+            isRequire: boolean,
+          ) => {
+            return tryNodeResolve(
+              id,
+              importer,
+              {
+                root: path.dirname(fileName),
+                isBuild: true,
+                isProduction: true,
+                preferRelative: false,
+                tryIndex: true,
+                mainFields: [],
+                conditions: [],
+                overrideConditions: ['node'],
+                dedupe: [],
+                extensions: DEFAULT_EXTENSIONS,
+                preserveSymlinks: false,
+                packageCache,
+                isRequire,
+              },
+              false,
+            )?.id
+          }
+
+          // externalize bare imports
+          build.onResolve(
+            { filter: /^[^.].*/ },
+            async ({ path: id, importer, kind }) => {
+              if (
+                kind === 'entry-point' ||
+                path.isAbsolute(id) ||
+                isNodeBuiltin(id)
+              ) {
+                return
+              }
+
+              // With the `isNodeBuiltin` check above, this check captures if the builtin is a
+              // non-node built-in, which esbuild doesn't know how to handle. In that case, we
+              // externalize it so the non-node runtime handles it instead.
+              if (isBuiltin(id)) {
+                return { external: true }
+              }
+
+              const isImport = isESM || kind === 'dynamic-import'
+              let idFsPath: string | undefined
+              try {
+                idFsPath = resolveByViteResolver(id, importer, !isImport)
+              } catch (e) {
+                if (!isImport) {
+                  let canResolveWithImport = false
+                  try {
+                    canResolveWithImport = !!resolveByViteResolver(
+                      id,
+                      importer,
+                      false,
+                    )
+                  } catch {}
+                  if (canResolveWithImport) {
+                    throw new Error(
+                      `Failed to resolve ${JSON.stringify(
+                        id,
+                      )}. This package is ESM only but it was tried to load by \`require\`. See https://vitejs.dev/guide/troubleshooting.html#this-package-is-esm-only for more details.`,
+                    )
+                  }
+                }
+                throw e
+              }
+              if (idFsPath && isImport) {
+                idFsPath = pathToFileURL(idFsPath).href
+              }
+              if (
+                idFsPath &&
+                !isImport &&
+                isFilePathESM(idFsPath, packageCache)
+              ) {
+                throw new Error(
+                  `${JSON.stringify(
+                    id,
+                  )} resolved to an ESM file. ESM file cannot be loaded by \`require\`. See https://vitejs.dev/guide/troubleshooting.html#this-package-is-esm-only for more details.`,
+                )
+              }
+              return {
+                path: idFsPath,
+                external: true,
+              }
+            },
+          )
+        },
+      },
+      {
+        name: 'inject-file-scope-variables',
+        setup(build) {
+          build.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
+            const contents = await fsp.readFile(args.path, 'utf-8')
+            const injectValues =
+              `const ${dirnameVarName} = ${JSON.stringify(
+                path.dirname(args.path),
+              )};` +
+              `const ${filenameVarName} = ${JSON.stringify(args.path)};` +
+              `const ${importMetaUrlVarName} = ${JSON.stringify(
+                pathToFileURL(args.path).href,
+              )};`
+
+            return {
+              loader: args.path.endsWith('ts') ? 'ts' : 'js',
+              contents: injectValues + contents,
+            }
+          })
+        },
+      },
+    ],
+  })
+  const { text } = result.outputFiles[0]
+  return {
+    code: text,
+    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : [],
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/config/loadConfigFromFile.ts b/packages/vite/src/node/config/loadConfigFromFile.ts
new file mode 100644
index 000000000..a8c60b0af
--- /dev/null
+++ b/packages/vite/src/node/config/loadConfigFromFile.ts
@@ -0,0 +1,337 @@
+import fs from 'node:fs'
+import path from 'node:path'
+import { performance } from 'node:perf_hooks'
+import colors from 'picocolors'
+import { DEFAULT_CONFIG_FILES } from 'packages/vite/src/node/constants';
+import { isObject } from 'packages/vite/src/node/utils';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { isFilePathESM } from 'packages/vite/src/node/utils';
+import { LogLevel } from 'packages/vite/src/node/logger';
+import { Logger } from 'packages/vite/src/node/logger';
+import { createLogger } from 'packages/vite/src/node/logger';
+import type { Alias, AliasOptions } from 'dep-types/alias'
+import type { RollupOptions } from 'rollup'
+import { BuildOptions } from 'packages/vite/src/node/build';
+import { ServerOptions } from 'packages/vite/src/node/server/index';
+import { PreviewOptions } from 'packages/vite/src/node/preview';
+import { CSSOptions } from 'packages/vite/src/node/plugins/css';
+import { ESBuildOptions } from 'packages/vite/src/node/plugins/esbuild';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve';
+import { DepOptimizationOptions } from 'packages/vite/src/node/optimizer/index';
+import { JsonOptions } from 'packages/vite/src/node/plugins/json';
+import { SSROptions } from 'packages/vite/src/node/ssr/index';
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { RenderBuiltAssetUrl } from 'packages/vite/src/node/build';
+
+
+export interface ConfigEnv {
+  /**
+   * 'serve': during dev (`vite` command)
+   * 'build': when building for production (`vite build` command)
+   */
+  command: 'build' | 'serve'
+  mode: string
+  isSsrBuild?: boolean
+  isPreview?: boolean
+}
+
+/**
+ * spa: include SPA fallback middleware and configure sirv with `single: true` in preview
+ *
+ * mpa: only include non-SPA HTML middlewares
+ *
+ * custom: don't include HTML middlewares
+ */
+export type AppType = 'spa' | 'mpa' | 'custom'
+
+export type PluginOption =
+  | Plugin
+  | false
+  | null
+  | undefined
+  | PluginOption[]
+  | Promise<Plugin | false | null | undefined | PluginOption[]>
+
+export interface HTMLOptions {
+  /**
+   * A nonce value placeholder that will be used when generating script/style tags.
+   *
+   * Make sure that this placeholder will be replaced with a unique value for each request by the server.
+   */
+  cspNonce?: string
+}
+
+export interface ExperimentalOptions {
+  /**
+   * Append fake `&lang.(ext)` when queries are specified, to preserve the file extension for following plugins to process.
+   *
+   * @experimental
+   * @default false
+   */
+  importGlobRestoreExtension?: boolean
+  /**
+   * Allow finegrain control over assets and public files paths
+   *
+   * @experimental
+   */
+  renderBuiltUrl?: RenderBuiltAssetUrl
+  /**
+   * Enables support of HMR partial accept via `import.meta.hot.acceptExports`.
+   *
+   * @experimental
+   * @default false
+   */
+  hmrPartialAccept?: boolean
+  /**
+   * Skips SSR transform to make it easier to use Vite with Node ESM loaders.
+   * @warning Enabling this will break normal operation of Vite's SSR in development mode.
+   *
+   * @experimental
+   * @default false
+   */
+  skipSsrTransform?: boolean
+}
+
+export interface LegacyOptions {
+  /**
+   * In Vite 4, SSR-externalized modules (modules not bundled and loaded by Node.js at runtime)
+   * are implicitly proxied in dev to automatically handle `default` and `__esModule` access.
+   * However, this does not correctly reflect how it works in the Node.js runtime, causing
+   * inconsistencies between dev and prod.
+   *
+   * In Vite 5, the proxy is removed so dev and prod are consistent, but if you still require
+   * the old behaviour, you can enable this option. If so, please leave your feedback at
+   * https://github.com/vitejs/vite/discussions/14697.
+   */
+  proxySsrExternalModules?: boolean
+}
+
+export interface UserConfig {
+  /**
+   * Project root directory. Can be an absolute path, or a path relative from
+   * the location of the config file itself.
+   * @default process.cwd()
+   */
+  root?: string
+  /**
+   * Base public path when served in development or production.
+   * @default '/'
+   */
+  base?: string
+  /**
+   * Directory to serve as plain static assets. Files in this directory are
+   * served and copied to build dist dir as-is without transform. The value
+   * can be either an absolute file system path or a path relative to project root.
+   *
+   * Set to `false` or an empty string to disable copied static assets to build dist dir.
+   * @default 'public'
+   */
+  publicDir?: string | false
+  /**
+   * Directory to save cache files. Files in this directory are pre-bundled
+   * deps or some other cache files that generated by vite, which can improve
+   * the performance. You can use `--force` flag or manually delete the directory
+   * to regenerate the cache files. The value can be either an absolute file
+   * system path or a path relative to project root.
+   * Default to `.vite` when no `package.json` is detected.
+   * @default 'node_modules/.vite'
+   */
+  cacheDir?: string
+  /**
+   * Explicitly set a mode to run in. This will override the default mode for
+   * each command, and can be overridden by the command line --mode option.
+   */
+  mode?: string
+  /**
+   * Define global variable replacements.
+   * Entries will be defined on `window` during dev and replaced during build.
+   */
+  define?: Record<string, any>
+  /**
+   * Array of vite plugins to use.
+   */
+  plugins?: PluginOption[]
+  /**
+   * Configure resolver
+   */
+  resolve?: ResolveOptions & { alias?: AliasOptions }
+  /**
+   * HTML related options
+   */
+  html?: HTMLOptions
+  /**
+   * CSS related options (preprocessors and CSS modules)
+   */
+  css?: CSSOptions
+  /**
+   * JSON loading options
+   */
+  json?: JsonOptions
+  /**
+   * Transform options to pass to esbuild.
+   * Or set to `false` to disable esbuild.
+   */
+  esbuild?: ESBuildOptions | false
+  /**
+   * Specify additional picomatch patterns to be treated as static assets.
+   */
+  assetsInclude?: string | RegExp | (string | RegExp)[]
+  /**
+   * Server specific options, e.g. host, port, https...
+   */
+  server?: ServerOptions
+  /**
+   * Build specific options
+   */
+  build?: BuildOptions
+  /**
+   * Preview specific options, e.g. host, port, https...
+   */
+  preview?: PreviewOptions
+  /**
+   * Dep optimization options
+   */
+  optimizeDeps?: DepOptimizationOptions
+  /**
+   * SSR specific options
+   */
+  ssr?: SSROptions
+  /**
+   * Experimental features
+   *
+   * Features under this field could change in the future and might NOT follow semver.
+   * Please be careful and always pin Vite's version when using them.
+   * @experimental
+   */
+  experimental?: ExperimentalOptions
+  /**
+   * Legacy options
+   *
+   * Features under this field only follow semver for patches, they could be removed in a
+   * future minor version. Please always pin Vite's version to a minor when using them.
+   */
+  legacy?: LegacyOptions
+  /**
+   * Log level.
+   * @default 'info'
+   */
+  logLevel?: LogLevel
+  /**
+   * Custom logger.
+   */
+  customLogger?: Logger
+  /**
+   * @default true
+   */
+  clearScreen?: boolean
+  /**
+   * Environment files directory. Can be an absolute path, or a path relative from
+   * root.
+   * @default root
+   */
+  envDir?: string
+  /**
+   * Env variables starts with `envPrefix` will be exposed to your client source code via import.meta.env.
+   * @default 'VITE_'
+   */
+  envPrefix?: string | string[]
+  /**
+   * Worker bundle options
+   */
+  worker?: {
+    /**
+     * Output format for worker bundle
+     * @default 'iife'
+     */
+    format?: 'es' | 'iife'
+    /**
+     * Vite plugins that apply to worker bundle. The plugins returned by this function
+     * should be new instances every time it is called, because they are used for each
+     * rollup worker bundling process.
+     */
+    plugins?: () => PluginOption[]
+    /**
+     * Rollup options to build worker bundle
+     */
+    rollupOptions?: Omit<
+      RollupOptions,
+      'plugins' | 'input' | 'onwarn' | 'preserveEntrySignatures'
+    >
+  }
+  /**
+   * Whether your application is a Single Page Application (SPA),
+   * a Multi-Page Application (MPA), or Custom Application (SSR
+   * and frameworks with custom HTML handling)
+   * @default 'spa'
+   */
+  appType?: AppType
+}
+
+export async function loadConfigFromFile(
+  configEnv: ConfigEnv,
+  configFile?: string,
+  configRoot: string = process.cwd(),
+  logLevel?: LogLevel,
+  customLogger?: Logger,
+): Promise<{
+  path: string
+  config: UserConfig
+  dependencies: string[]
+} | null> {
+  const start = performance.now()
+  const getTime = () => `${(performance.now() - start).toFixed(2)}ms`
+
+  let resolvedPath: string | undefined
+
+  if (configFile) {
+    // explicit config path is always resolved from cwd
+    resolvedPath = path.resolve(configFile)
+  } else {
+    // implicit config file loaded from inline root (if present)
+    // otherwise from cwd
+    for (const filename of DEFAULT_CONFIG_FILES) {
+      const filePath = path.resolve(configRoot, filename)
+      if (!fs.existsSync(filePath)) continue
+
+      resolvedPath = filePath
+      break
+    }
+  }
+
+  if (!resolvedPath) {
+    debug?.('no config file found.')
+    return null
+  }
+
+  const isESM = isFilePathESM(resolvedPath)
+
+  try {
+    const bundled = await bundleConfigFile(resolvedPath, isESM)
+    const userConfig = await loadConfigFromBundledFile(
+      resolvedPath,
+      bundled.code,
+      isESM,
+    )
+    debug?.(`bundled config file loaded in ${getTime()}`)
+
+    const config = await (typeof userConfig === 'function'
+      ? userConfig(configEnv)
+      : userConfig)
+    if (!isObject(config)) {
+      throw new Error(`config must export or return an object.`)
+    }
+    return {
+      path: normalizePath(resolvedPath),
+      config,
+      dependencies: bundled.dependencies,
+    }
+  } catch (e) {
+    createLogger(logLevel, { customLogger }).error(
+      colors.red(`failed to load config from ${resolvedPath}`),
+      {
+        error: e,
+      },
+    )
+    throw e
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/config/resolveConfig.ts b/packages/vite/src/node/config/resolveConfig.ts
new file mode 100644
index 000000000..9e10e6f6d
--- /dev/null
+++ b/packages/vite/src/node/config/resolveConfig.ts
@@ -0,0 +1,889 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import { withTrailingSlash } from 'packages/vite/src/shared/utils';
+import { FS_PREFIX } from 'packages/vite/src/node/constants';
+import { ENV_ENTRY } from 'packages/vite/src/node/constants';
+import { CLIENT_ENTRY } from 'packages/vite/src/node/constants';
+import { DEFAULT_MAIN_FIELDS } from 'packages/vite/src/node/constants';
+import { DEFAULT_EXTENSIONS } from 'packages/vite/src/node/constants';
+import { DEFAULT_ASSETS_RE } from 'packages/vite/src/node/constants';
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { resolveBuildOptions } from 'packages/vite/src/node/build';
+import { resolveServerOptions } from 'packages/vite/src/node/server/index';
+import { resolvePreviewOptions } from 'packages/vite/src/node/preview';
+import { resolveCSSOptions } from 'packages/vite/src/node/plugins/css';
+import { isParentDirectory } from 'packages/vite/src/node/utils';
+import { mergeConfig } from 'packages/vite/src/node/utils';
+import { asyncFlatten } from 'packages/vite/src/node/utils';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { mergeAlias } from 'packages/vite/src/node/utils';
+import { normalizeAlias } from 'packages/vite/src/node/utils';
+import { createPluginHookUtils } from 'packages/vite/src/node/plugins/index';
+import { resolvePlugins } from 'packages/vite/src/node/plugins/index';
+import { createLogger } from 'packages/vite/src/node/logger';
+import { PluginContainer } from 'packages/vite/src/node/server/pluginContainer';
+import { PackageCache } from 'packages/vite/src/node/packages';
+import { findNearestPackageData } from 'packages/vite/src/node/packages';
+import { resolveEnvPrefix } from 'packages/vite/src/node/env';
+import { loadEnv } from 'packages/vite/src/node/env';
+import { resolveSSROptions } from 'packages/vite/src/node/ssr/index';
+import type { RollupOptions } from 'rollup'
+import type { Alias, AliasOptions } from 'dep-types/alias'
+import { BuildOptions } from 'packages/vite/src/node/build';
+import { ServerOptions } from 'packages/vite/src/node/server/index';
+import { PreviewOptions } from 'packages/vite/src/node/preview';
+import { CSSOptions } from 'packages/vite/src/node/plugins/css';
+import { ESBuildOptions } from 'packages/vite/src/node/plugins/esbuild';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve';
+import { LogLevel } from 'packages/vite/src/node/logger';
+import { Logger } from 'packages/vite/src/node/logger';
+import { DepOptimizationOptions } from 'packages/vite/src/node/optimizer/index';
+import { JsonOptions } from 'packages/vite/src/node/plugins/json';
+import { SSROptions } from 'packages/vite/src/node/ssr/index';
+import { RenderBuiltAssetUrl } from 'packages/vite/src/node/build';
+import { ResolvedBuildOptions } from 'packages/vite/src/node/build';
+import { ResolvedServerOptions } from 'packages/vite/src/node/server/index';
+import { ResolvedPreviewOptions } from 'packages/vite/src/node/preview';
+import { ResolvedCSSOptions } from 'packages/vite/src/node/plugins/css';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve';
+import { ResolvedSSROptions } from 'packages/vite/src/node/ssr/index';
+import { PluginWithRequiredHook } from 'packages/vite/src/node/plugin';
+import { HookHandler } from 'packages/vite/src/node/plugin';
+
+
+export interface ConfigEnv {
+  /**
+   * 'serve': during dev (`vite` command)
+   * 'build': when building for production (`vite build` command)
+   */
+  command: 'build' | 'serve'
+  mode: string
+  isSsrBuild?: boolean
+  isPreview?: boolean
+}
+
+export interface ResolvedWorkerOptions {
+  format: 'es' | 'iife'
+  plugins: (bundleChain: string[]) => Promise<Plugin[]>
+  rollupOptions: RollupOptions
+}
+
+/**
+ * spa: include SPA fallback middleware and configure sirv with `single: true` in preview
+ *
+ * mpa: only include non-SPA HTML middlewares
+ *
+ * custom: don't include HTML middlewares
+ */
+export type AppType = 'spa' | 'mpa' | 'custom'
+
+export type PluginOption =
+  | Plugin
+  | false
+  | null
+  | undefined
+  | PluginOption[]
+  | Promise<Plugin | false | null | undefined | PluginOption[]>
+
+export interface HTMLOptions {
+  /**
+   * A nonce value placeholder that will be used when generating script/style tags.
+   *
+   * Make sure that this placeholder will be replaced with a unique value for each request by the server.
+   */
+  cspNonce?: string
+}
+
+export interface ExperimentalOptions {
+  /**
+   * Append fake `&lang.(ext)` when queries are specified, to preserve the file extension for following plugins to process.
+   *
+   * @experimental
+   * @default false
+   */
+  importGlobRestoreExtension?: boolean
+  /**
+   * Allow finegrain control over assets and public files paths
+   *
+   * @experimental
+   */
+  renderBuiltUrl?: RenderBuiltAssetUrl
+  /**
+   * Enables support of HMR partial accept via `import.meta.hot.acceptExports`.
+   *
+   * @experimental
+   * @default false
+   */
+  hmrPartialAccept?: boolean
+  /**
+   * Skips SSR transform to make it easier to use Vite with Node ESM loaders.
+   * @warning Enabling this will break normal operation of Vite's SSR in development mode.
+   *
+   * @experimental
+   * @default false
+   */
+  skipSsrTransform?: boolean
+}
+
+export interface LegacyOptions {
+  /**
+   * In Vite 4, SSR-externalized modules (modules not bundled and loaded by Node.js at runtime)
+   * are implicitly proxied in dev to automatically handle `default` and `__esModule` access.
+   * However, this does not correctly reflect how it works in the Node.js runtime, causing
+   * inconsistencies between dev and prod.
+   *
+   * In Vite 5, the proxy is removed so dev and prod are consistent, but if you still require
+   * the old behaviour, you can enable this option. If so, please leave your feedback at
+   * https://github.com/vitejs/vite/discussions/14697.
+   */
+  proxySsrExternalModules?: boolean
+}
+
+export interface UserConfig {
+  /**
+   * Project root directory. Can be an absolute path, or a path relative from
+   * the location of the config file itself.
+   * @default process.cwd()
+   */
+  root?: string
+  /**
+   * Base public path when served in development or production.
+   * @default '/'
+   */
+  base?: string
+  /**
+   * Directory to serve as plain static assets. Files in this directory are
+   * served and copied to build dist dir as-is without transform. The value
+   * can be either an absolute file system path or a path relative to project root.
+   *
+   * Set to `false` or an empty string to disable copied static assets to build dist dir.
+   * @default 'public'
+   */
+  publicDir?: string | false
+  /**
+   * Directory to save cache files. Files in this directory are pre-bundled
+   * deps or some other cache files that generated by vite, which can improve
+   * the performance. You can use `--force` flag or manually delete the directory
+   * to regenerate the cache files. The value can be either an absolute file
+   * system path or a path relative to project root.
+   * Default to `.vite` when no `package.json` is detected.
+   * @default 'node_modules/.vite'
+   */
+  cacheDir?: string
+  /**
+   * Explicitly set a mode to run in. This will override the default mode for
+   * each command, and can be overridden by the command line --mode option.
+   */
+  mode?: string
+  /**
+   * Define global variable replacements.
+   * Entries will be defined on `window` during dev and replaced during build.
+   */
+  define?: Record<string, any>
+  /**
+   * Array of vite plugins to use.
+   */
+  plugins?: PluginOption[]
+  /**
+   * Configure resolver
+   */
+  resolve?: ResolveOptions & { alias?: AliasOptions }
+  /**
+   * HTML related options
+   */
+  html?: HTMLOptions
+  /**
+   * CSS related options (preprocessors and CSS modules)
+   */
+  css?: CSSOptions
+  /**
+   * JSON loading options
+   */
+  json?: JsonOptions
+  /**
+   * Transform options to pass to esbuild.
+   * Or set to `false` to disable esbuild.
+   */
+  esbuild?: ESBuildOptions | false
+  /**
+   * Specify additional picomatch patterns to be treated as static assets.
+   */
+  assetsInclude?: string | RegExp | (string | RegExp)[]
+  /**
+   * Server specific options, e.g. host, port, https...
+   */
+  server?: ServerOptions
+  /**
+   * Build specific options
+   */
+  build?: BuildOptions
+  /**
+   * Preview specific options, e.g. host, port, https...
+   */
+  preview?: PreviewOptions
+  /**
+   * Dep optimization options
+   */
+  optimizeDeps?: DepOptimizationOptions
+  /**
+   * SSR specific options
+   */
+  ssr?: SSROptions
+  /**
+   * Experimental features
+   *
+   * Features under this field could change in the future and might NOT follow semver.
+   * Please be careful and always pin Vite's version when using them.
+   * @experimental
+   */
+  experimental?: ExperimentalOptions
+  /**
+   * Legacy options
+   *
+   * Features under this field only follow semver for patches, they could be removed in a
+   * future minor version. Please always pin Vite's version to a minor when using them.
+   */
+  legacy?: LegacyOptions
+  /**
+   * Log level.
+   * @default 'info'
+   */
+  logLevel?: LogLevel
+  /**
+   * Custom logger.
+   */
+  customLogger?: Logger
+  /**
+   * @default true
+   */
+  clearScreen?: boolean
+  /**
+   * Environment files directory. Can be an absolute path, or a path relative from
+   * root.
+   * @default root
+   */
+  envDir?: string
+  /**
+   * Env variables starts with `envPrefix` will be exposed to your client source code via import.meta.env.
+   * @default 'VITE_'
+   */
+  envPrefix?: string | string[]
+  /**
+   * Worker bundle options
+   */
+  worker?: {
+    /**
+     * Output format for worker bundle
+     * @default 'iife'
+     */
+    format?: 'es' | 'iife'
+    /**
+     * Vite plugins that apply to worker bundle. The plugins returned by this function
+     * should be new instances every time it is called, because they are used for each
+     * rollup worker bundling process.
+     */
+    plugins?: () => PluginOption[]
+    /**
+     * Rollup options to build worker bundle
+     */
+    rollupOptions?: Omit<
+      RollupOptions,
+      'plugins' | 'input' | 'onwarn' | 'preserveEntrySignatures'
+    >
+  }
+  /**
+   * Whether your application is a Single Page Application (SPA),
+   * a Multi-Page Application (MPA), or Custom Application (SSR
+   * and frameworks with custom HTML handling)
+   * @default 'spa'
+   */
+  appType?: AppType
+}
+
+export interface InlineConfig extends UserConfig {
+  configFile?: string | false
+  envFile?: false
+}
+
+export interface PluginHookUtils {
+  getSortedPlugins: <K extends keyof Plugin>(
+    hookName: K,
+  ) => PluginWithRequiredHook<K>[]
+  getSortedPluginHooks: <K extends keyof Plugin>(
+    hookName: K,
+  ) => NonNullable<HookHandler<Plugin[K]>>[]
+}
+
+export type ResolveFn = (
+  id: string,
+  importer?: string,
+  aliasOnly?: boolean,
+  ssr?: boolean,
+) => Promise<string | undefined>
+
+export type ResolvedConfig = Readonly<
+  Omit<
+    UserConfig,
+    'plugins' | 'css' | 'assetsInclude' | 'optimizeDeps' | 'worker' | 'build'
+  > & {
+    configFile: string | undefined
+    configFileDependencies: string[]
+    inlineConfig: InlineConfig
+    root: string
+    base: string
+    /** @internal */
+    decodedBase: string
+    /** @internal */
+    rawBase: string
+    publicDir: string
+    cacheDir: string
+    command: 'build' | 'serve'
+    mode: string
+    isWorker: boolean
+    // in nested worker bundle to find the main config
+    /** @internal */
+    mainConfig: ResolvedConfig | null
+    /** @internal list of bundle entry id. used to detect recursive worker bundle. */
+    bundleChain: string[]
+    isProduction: boolean
+    envDir: string
+    env: Record<string, any>
+    resolve: Required<ResolveOptions> & {
+      alias: Alias[]
+    }
+    plugins: readonly Plugin[]
+    css: ResolvedCSSOptions
+    esbuild: ESBuildOptions | false
+    server: ResolvedServerOptions
+    build: ResolvedBuildOptions
+    preview: ResolvedPreviewOptions
+    ssr: ResolvedSSROptions
+    assetsInclude: (file: string) => boolean
+    logger: Logger
+    createResolver: (options?: Partial<InternalResolveOptions>) => ResolveFn
+    optimizeDeps: DepOptimizationOptions
+    /** @internal */
+    packageCache: PackageCache
+    worker: ResolvedWorkerOptions
+    appType: AppType
+    experimental: ExperimentalOptions
+  } & PluginHookUtils
+>
+
+/**
+ * Check and warn if `path` includes characters that don't work well in Vite,
+ * such as `#` and `?`.
+ */
+export function checkBadCharactersInPath(path: string, logger: Logger): void {
+  const badChars = []
+
+  if (path.includes('#')) {
+    badChars.push('#')
+  }
+  if (path.includes('?')) {
+    badChars.push('?')
+  }
+
+  if (badChars.length > 0) {
+    const charString = badChars.map((c) => `"${c}"`).join(' and ')
+    const inflectedChars = badChars.length > 1 ? 'characters' : 'character'
+
+    logger.warn(
+      colors.yellow(
+        `The project root contains the ${charString} ${inflectedChars} (${colors.cyan(
+          path,
+        )}), which may not work when running Vite. Consider renaming the directory to remove the characters.`,
+      ),
+    )
+  }
+}
+
+export async function resolveConfig(
+  inlineConfig: InlineConfig,
+  command: 'build' | 'serve',
+  defaultMode = 'development',
+  defaultNodeEnv = 'development',
+  isPreview = false,
+): Promise<ResolvedConfig> {
+  let config = inlineConfig
+  let configFileDependencies: string[] = []
+  let mode = inlineConfig.mode || defaultMode
+  const isNodeEnvSet = !!process.env.NODE_ENV
+  const packageCache: PackageCache = new Map()
+
+  // some dependencies e.g. @vue/compiler-* relies on NODE_ENV for getting
+  // production-specific behavior, so set it early on
+  if (!isNodeEnvSet) {
+    process.env.NODE_ENV = defaultNodeEnv
+  }
+
+  const configEnv: ConfigEnv = {
+    mode,
+    command,
+    isSsrBuild: command === 'build' && !!config.build?.ssr,
+    isPreview,
+  }
+
+  let { configFile } = config
+  if (configFile !== false) {
+    const loadResult = await loadConfigFromFile(
+      configEnv,
+      configFile,
+      config.root,
+      config.logLevel,
+      config.customLogger,
+    )
+    if (loadResult) {
+      config = mergeConfig(loadResult.config, config)
+      configFile = loadResult.path
+      configFileDependencies = loadResult.dependencies
+    }
+  }
+
+  // user config may provide an alternative mode. But --mode has a higher priority
+  mode = inlineConfig.mode || config.mode || mode
+  configEnv.mode = mode
+
+  const filterPlugin = (p: Plugin) => {
+    if (!p) {
+      return false
+    } else if (!p.apply) {
+      return true
+    } else if (typeof p.apply === 'function') {
+      return p.apply({ ...config, mode }, configEnv)
+    } else {
+      return p.apply === command
+    }
+  }
+
+  // resolve plugins
+  const rawUserPlugins = (
+    (await asyncFlatten(config.plugins || [])) as Plugin[]
+  ).filter(filterPlugin)
+
+  const [prePlugins, normalPlugins, postPlugins] =
+    sortUserPlugins(rawUserPlugins)
+
+  // run config hooks
+  const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins]
+  config = await runConfigHook(config, userPlugins, configEnv)
+
+  // Define logger
+  const logger = createLogger(config.logLevel, {
+    allowClearScreen: config.clearScreen,
+    customLogger: config.customLogger,
+  })
+
+  // resolve root
+  const resolvedRoot = normalizePath(
+    config.root ? path.resolve(config.root) : process.cwd(),
+  )
+
+  checkBadCharactersInPath(resolvedRoot, logger)
+
+  const clientAlias = [
+    {
+      find: /^\/?@vite\/env/,
+      replacement: path.posix.join(FS_PREFIX, normalizePath(ENV_ENTRY)),
+    },
+    {
+      find: /^\/?@vite\/client/,
+      replacement: path.posix.join(FS_PREFIX, normalizePath(CLIENT_ENTRY)),
+    },
+  ]
+
+  // resolve alias with internal client alias
+  const resolvedAlias = normalizeAlias(
+    mergeAlias(clientAlias, config.resolve?.alias || []),
+  )
+
+  const resolveOptions: ResolvedConfig['resolve'] = {
+    mainFields: config.resolve?.mainFields ?? DEFAULT_MAIN_FIELDS,
+    conditions: config.resolve?.conditions ?? [],
+    extensions: config.resolve?.extensions ?? DEFAULT_EXTENSIONS,
+    dedupe: config.resolve?.dedupe ?? [],
+    preserveSymlinks: config.resolve?.preserveSymlinks ?? false,
+    alias: resolvedAlias,
+  }
+
+  if (
+    // @ts-expect-error removed field
+    config.resolve?.browserField === false &&
+    resolveOptions.mainFields.includes('browser')
+  ) {
+    logger.warn(
+      colors.yellow(
+        `\`resolve.browserField\` is set to false, but the option is removed in favour of ` +
+          `the 'browser' string in \`resolve.mainFields\`. You may want to update \`resolve.mainFields\` ` +
+          `to remove the 'browser' string and preserve the previous browser behaviour.`,
+      ),
+    )
+  }
+
+  // load .env files
+  const envDir = config.envDir
+    ? normalizePath(path.resolve(resolvedRoot, config.envDir))
+    : resolvedRoot
+  const userEnv =
+    inlineConfig.envFile !== false &&
+    loadEnv(mode, envDir, resolveEnvPrefix(config))
+
+  // Note it is possible for user to have a custom mode, e.g. `staging` where
+  // development-like behavior is expected. This is indicated by NODE_ENV=development
+  // loaded from `.staging.env` and set by us as VITE_USER_NODE_ENV
+  const userNodeEnv = process.env.VITE_USER_NODE_ENV
+  if (!isNodeEnvSet && userNodeEnv) {
+    if (userNodeEnv === 'development') {
+      process.env.NODE_ENV = 'development'
+    } else {
+      // NODE_ENV=production is not supported as it could break HMR in dev for frameworks like Vue
+      logger.warn(
+        `NODE_ENV=${userNodeEnv} is not supported in the .env file. ` +
+          `Only NODE_ENV=development is supported to create a development build of your project. ` +
+          `If you need to set process.env.NODE_ENV, you can set it in the Vite config instead.`,
+      )
+    }
+  }
+
+  const isProduction = process.env.NODE_ENV === 'production'
+
+  // resolve public base url
+  const isBuild = command === 'build'
+  const relativeBaseShortcut = config.base === '' || config.base === './'
+
+  // During dev, we ignore relative base and fallback to '/'
+  // For the SSR build, relative base isn't possible by means
+  // of import.meta.url.
+  const resolvedBase = relativeBaseShortcut
+    ? !isBuild || config.build?.ssr
+      ? '/'
+      : './'
+    : (resolveBaseUrl(config.base, isBuild, logger) ?? '/')
+
+  const resolvedBuildOptions = resolveBuildOptions(
+    config.build,
+    logger,
+    resolvedRoot,
+  )
+
+  // resolve cache directory
+  const pkgDir = findNearestPackageData(resolvedRoot, packageCache)?.dir
+  const cacheDir = normalizePath(
+    config.cacheDir
+      ? path.resolve(resolvedRoot, config.cacheDir)
+      : pkgDir
+        ? path.join(pkgDir, `node_modules/.vite`)
+        : path.join(resolvedRoot, `.vite`),
+  )
+
+  const assetsFilter =
+    config.assetsInclude &&
+    (!Array.isArray(config.assetsInclude) || config.assetsInclude.length)
+      ? createFilter(config.assetsInclude)
+      : () => false
+
+  // create an internal resolver to be used in special scenarios, e.g.
+  // optimizer & handling css @imports
+  const createResolver: ResolvedConfig['createResolver'] = (options) => {
+    let aliasContainer: PluginContainer | undefined
+    let resolverContainer: PluginContainer | undefined
+    return async (id, importer, aliasOnly, ssr) => {
+      let container: PluginContainer
+      if (aliasOnly) {
+        container =
+          aliasContainer ||
+          (aliasContainer = await createPluginContainer({
+            ...resolved,
+            plugins: [aliasPlugin({ entries: resolved.resolve.alias })],
+          }))
+      } else {
+        container =
+          resolverContainer ||
+          (resolverContainer = await createPluginContainer({
+            ...resolved,
+            plugins: [
+              aliasPlugin({ entries: resolved.resolve.alias }),
+              resolvePlugin({
+                ...resolved.resolve,
+                root: resolvedRoot,
+                isProduction,
+                isBuild: command === 'build',
+                ssrConfig: resolved.ssr,
+                asSrc: true,
+                preferRelative: false,
+                tryIndex: true,
+                ...options,
+                idOnly: true,
+                fsUtils: getFsUtils(resolved),
+              }),
+            ],
+          }))
+      }
+      return (
+        await container.resolveId(id, importer, {
+          ssr,
+          scan: options?.scan,
+        })
+      )?.id
+    }
+  }
+
+  const { publicDir } = config
+  const resolvedPublicDir =
+    publicDir !== false && publicDir !== ''
+      ? normalizePath(
+          path.resolve(
+            resolvedRoot,
+            typeof publicDir === 'string' ? publicDir : 'public',
+          ),
+        )
+      : ''
+
+  const server = resolveServerOptions(resolvedRoot, config.server, logger)
+  const ssr = resolveSSROptions(config.ssr, resolveOptions.preserveSymlinks)
+
+  const optimizeDeps = config.optimizeDeps || {}
+
+  const BASE_URL = resolvedBase
+
+  let resolved: ResolvedConfig
+
+  let createUserWorkerPlugins = config.worker?.plugins
+  if (Array.isArray(createUserWorkerPlugins)) {
+    // @ts-expect-error backward compatibility
+    createUserWorkerPlugins = () => config.worker?.plugins
+
+    logger.warn(
+      colors.yellow(
+        `worker.plugins is now a function that returns an array of plugins. ` +
+          `Please update your Vite config accordingly.\n`,
+      ),
+    )
+  }
+
+  const createWorkerPlugins = async function (bundleChain: string[]) {
+    // Some plugins that aren't intended to work in the bundling of workers (doing post-processing at build time for example).
+    // And Plugins may also have cached that could be corrupted by being used in these extra rollup calls.
+    // So we need to separate the worker plugin from the plugin that vite needs to run.
+    const rawWorkerUserPlugins = (
+      (await asyncFlatten(createUserWorkerPlugins?.() || [])) as Plugin[]
+    ).filter(filterPlugin)
+
+    // resolve worker
+    let workerConfig = mergeConfig({}, config)
+    const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] =
+      sortUserPlugins(rawWorkerUserPlugins)
+
+    // run config hooks
+    const workerUserPlugins = [
+      ...workerPrePlugins,
+      ...workerNormalPlugins,
+      ...workerPostPlugins,
+    ]
+    workerConfig = await runConfigHook(
+      workerConfig,
+      workerUserPlugins,
+      configEnv,
+    )
+
+    const workerResolved: ResolvedConfig = {
+      ...workerConfig,
+      ...resolved,
+      isWorker: true,
+      mainConfig: resolved,
+      bundleChain,
+    }
+    const resolvedWorkerPlugins = await resolvePlugins(
+      workerResolved,
+      workerPrePlugins,
+      workerNormalPlugins,
+      workerPostPlugins,
+    )
+
+    // run configResolved hooks
+    await Promise.all(
+      createPluginHookUtils(resolvedWorkerPlugins)
+        .getSortedPluginHooks('configResolved')
+        .map((hook) => hook(workerResolved)),
+    )
+
+    return resolvedWorkerPlugins
+  }
+
+  const resolvedWorkerOptions: ResolvedWorkerOptions = {
+    format: config.worker?.format || 'iife',
+    plugins: createWorkerPlugins,
+    rollupOptions: config.worker?.rollupOptions || {},
+  }
+
+  const base = withTrailingSlash(resolvedBase)
+
+  resolved = {
+    configFile: configFile ? normalizePath(configFile) : undefined,
+    configFileDependencies: configFileDependencies.map((name) =>
+      normalizePath(path.resolve(name)),
+    ),
+    inlineConfig,
+    root: resolvedRoot,
+    base,
+    decodedBase: decodeURI(base),
+    rawBase: resolvedBase,
+    resolve: resolveOptions,
+    publicDir: resolvedPublicDir,
+    cacheDir,
+    command,
+    mode,
+    ssr,
+    isWorker: false,
+    mainConfig: null,
+    bundleChain: [],
+    isProduction,
+    plugins: userPlugins,
+    css: resolveCSSOptions(config.css),
+    esbuild:
+      config.esbuild === false
+        ? false
+        : {
+            jsxDev: !isProduction,
+            ...config.esbuild,
+          },
+    server,
+    build: resolvedBuildOptions,
+    preview: resolvePreviewOptions(config.preview, server),
+    envDir,
+    env: {
+      ...userEnv,
+      BASE_URL,
+      MODE: mode,
+      DEV: !isProduction,
+      PROD: isProduction,
+    },
+    assetsInclude(file: string) {
+      return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file)
+    },
+    logger,
+    packageCache,
+    createResolver,
+    optimizeDeps: {
+      holdUntilCrawlEnd: true,
+      ...optimizeDeps,
+      esbuildOptions: {
+        preserveSymlinks: resolveOptions.preserveSymlinks,
+        ...optimizeDeps.esbuildOptions,
+      },
+    },
+    worker: resolvedWorkerOptions,
+    appType: config.appType ?? 'spa',
+    experimental: {
+      importGlobRestoreExtension: false,
+      hmrPartialAccept: false,
+      ...config.experimental,
+    },
+    getSortedPlugins: undefined!,
+    getSortedPluginHooks: undefined!,
+  }
+  resolved = {
+    ...config,
+    ...resolved,
+  }
+  ;(resolved.plugins as Plugin[]) = await resolvePlugins(
+    resolved,
+    prePlugins,
+    normalPlugins,
+    postPlugins,
+  )
+  Object.assign(resolved, createPluginHookUtils(resolved.plugins))
+
+  // call configResolved hooks
+  await Promise.all(
+    resolved
+      .getSortedPluginHooks('configResolved')
+      .map((hook) => hook(resolved)),
+  )
+
+  optimizeDepsDisabledBackwardCompatibility(resolved, resolved.optimizeDeps)
+  optimizeDepsDisabledBackwardCompatibility(
+    resolved,
+    resolved.ssr.optimizeDeps,
+    'ssr.',
+  )
+
+  debug?.(`using resolved config: %O`, {
+    ...resolved,
+    plugins: resolved.plugins.map((p) => p.name),
+    worker: {
+      ...resolved.worker,
+      plugins: `() => plugins`,
+    },
+  })
+
+  // validate config
+
+  if (
+    config.build?.terserOptions &&
+    config.build.minify &&
+    config.build.minify !== 'terser'
+  ) {
+    logger.warn(
+      colors.yellow(
+        `build.terserOptions is specified but build.minify is not set to use Terser. ` +
+          `Note Vite now defaults to use esbuild for minification. If you still ` +
+          `prefer Terser, set build.minify to "terser".`,
+      ),
+    )
+  }
+
+  // Check if all assetFileNames have the same reference.
+  // If not, display a warn for user.
+  const outputOption = config.build?.rollupOptions?.output ?? []
+  // Use isArray to narrow its type to array
+  if (Array.isArray(outputOption)) {
+    const assetFileNamesList = outputOption.map(
+      (output) => output.assetFileNames,
+    )
+    if (assetFileNamesList.length > 1) {
+      const firstAssetFileNames = assetFileNamesList[0]
+      const hasDifferentReference = assetFileNamesList.some(
+        (assetFileNames) => assetFileNames !== firstAssetFileNames,
+      )
+      if (hasDifferentReference) {
+        resolved.logger.warn(
+          colors.yellow(`
+assetFileNames isn't equal for every build.rollupOptions.output. A single pattern across all outputs is supported by Vite.
+`),
+        )
+      }
+    }
+  }
+
+  // Warn about removal of experimental features
+  if (
+    // @ts-expect-error Option removed
+    config.legacy?.buildSsrCjsExternalHeuristics ||
+    // @ts-expect-error Option removed
+    config.ssr?.format === 'cjs'
+  ) {
+    resolved.logger.warn(
+      colors.yellow(`
+(!) Experimental legacy.buildSsrCjsExternalHeuristics and ssr.format were be removed in Vite 5.
+    The only SSR Output format is ESM. Find more information at https://github.com/vitejs/vite/discussions/13816.
+`),
+    )
+  }
+
+  const resolvedBuildOutDir = normalizePath(
+    path.resolve(resolved.root, resolved.build.outDir),
+  )
+  if (
+    isParentDirectory(resolvedBuildOutDir, resolved.root) ||
+    resolvedBuildOutDir === resolved.root
+  ) {
+    resolved.logger.warn(
+      colors.yellow(`
+(!) build.outDir must not be the same directory of root or a parent directory of root as this could cause Vite to overwriting source files with build outputs.
+`),
+    )
+  }
+
+  return resolved
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/env.ts b/packages/vite/src/node/env.ts
index 897524612..ddfe02937 100644
--- a/packages/vite/src/node/env.ts
+++ b/packages/vite/src/node/env.ts
@@ -1,9 +1,11 @@
+import { UserConfig } from 'packages/vite/src/node/config/UserConfig';
+import { UserConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { UserConfig } from 'packages/vite/src/node/config/loadConfigFromFile';
 import fs from 'node:fs'
 import path from 'node:path'
 import { parse } from 'dotenv'
 import { type DotenvPopulateInput, expand } from 'dotenv-expand'
 import { arraify, normalizePath, tryStatSync } from './utils'
-import type { UserConfig } from './config'
 
 export function getEnvFilesForMode(mode: string, envDir: string): string[] {
   return [
diff --git a/packages/vite/src/node/fsUtils.ts b/packages/vite/src/node/fsUtils.ts
index a295d4fc4..56f34b315 100644
--- a/packages/vite/src/node/fsUtils.ts
+++ b/packages/vite/src/node/fsUtils.ts
@@ -1,7 +1,7 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import fs from 'node:fs'
 import path from 'node:path'
 import type { FSWatcher } from 'dep-types/chokidar'
-import type { ResolvedConfig } from './config'
 import {
   isInNodeModules,
   normalizePath,
diff --git a/packages/vite/src/node/http.ts b/packages/vite/src/node/http.ts
index 51a063ba8..0bf31e9a2 100644
--- a/packages/vite/src/node/http.ts
+++ b/packages/vite/src/node/http.ts
@@ -1,3 +1,8 @@
+import { HttpServer } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/_createServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/restartServer';
 import fsp from 'node:fs/promises'
 import path from 'node:path'
 import type { OutgoingHttpHeaders as HttpServerHeaders } from 'node:http'
@@ -6,7 +11,6 @@ import type { Connect } from 'dep-types/connect'
 import colors from 'picocolors'
 import type { ProxyOptions } from './server/middlewares/proxy'
 import type { Logger } from './logger'
-import type { HttpServer } from './server'
 
 export interface CommonServerOptions {
   /**
diff --git a/packages/vite/src/node/index.ts b/packages/vite/src/node/index.ts
index 3d17f8737..6f26e34e2 100644
--- a/packages/vite/src/node/index.ts
+++ b/packages/vite/src/node/index.ts
@@ -1,16 +1,98 @@
+import { LibraryFormats } from 'packages/vite/src/node/build/BuildOptions';
+import { LibraryOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { ResolveModulePreloadDependenciesFn } from 'packages/vite/src/node/build/BuildOptions';
+import { ModulePreloadOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { BuildOptions } from 'packages/vite/src/node/build/BuildOptions';
+import { LibraryFormats } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { LibraryOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { ResolveModulePreloadDependenciesFn } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { ModulePreloadOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { BuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { ResolvedModulePreloadOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { ResolvedBuildOptions } from 'packages/vite/src/node/build/resolveBuildOptions';
+import { build } from 'packages/vite/src/node/build/build';
+import { LibraryFormats } from 'packages/vite/src/node/build/resolveBuildOutputs';
+import { LibraryOptions } from 'packages/vite/src/node/build/resolveBuildOutputs';
+import { AppType } from 'packages/vite/src/node/config/UserConfig';
+import { PluginOption } from 'packages/vite/src/node/config/UserConfig';
+import { HTMLOptions } from 'packages/vite/src/node/config/UserConfig';
+import { ExperimentalOptions } from 'packages/vite/src/node/config/UserConfig';
+import { LegacyOptions } from 'packages/vite/src/node/config/UserConfig';
+import { UserConfig } from 'packages/vite/src/node/config/UserConfig';
+import { ConfigEnv } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedWorkerOptions } from 'packages/vite/src/node/config/resolveConfig';
+import { AppType } from 'packages/vite/src/node/config/resolveConfig';
+import { PluginOption } from 'packages/vite/src/node/config/resolveConfig';
+import { HTMLOptions } from 'packages/vite/src/node/config/resolveConfig';
+import { ExperimentalOptions } from 'packages/vite/src/node/config/resolveConfig';
+import { LegacyOptions } from 'packages/vite/src/node/config/resolveConfig';
+import { UserConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { InlineConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { PluginHookUtils } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolveFn } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ConfigEnv } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { AppType } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { PluginOption } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { HTMLOptions } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { ExperimentalOptions } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { LegacyOptions } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { UserConfig } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { loadConfigFromFile } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { HmrContext } from 'packages/vite/src/node/server/hmr/handleHMRUpdate';
+import { DepOptimizationConfig } from 'packages/vite/src/node/optimizer/index/DepOptimizationConfig';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { DepOptimizationMetadata } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { DepOptimizationMetadata } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/extractExportsData';
+import { FileSystemServeOptions } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ServerOptions';
+import { ServerOptions } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { FileSystemServeOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { ServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { ResolvedServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/restartServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/restartServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { ResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/doTransform';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation';
 import type * as Rollup from 'rollup'
 
 export type { Rollup }
 export { parseAst, parseAstAsync } from 'rollup/parseAst'
 export {
   defineConfig,
-  loadConfigFromFile,
-  resolveConfig,
   sortUserPlugins,
 } from './config'
 export { createServer } from './server'
 export { preview } from './preview'
-export { build } from './build'
 export { optimizeDeps } from './optimizer'
 export { formatPostcssSourceMap, preprocessCSS } from './plugins/css'
 export { transformWithEsbuild } from './plugins/esbuild'
@@ -20,58 +102,14 @@ export type { FetchModuleOptions } from './ssr/fetchModule'
 export * from './publicUtils'
 
 // additional types
-export type {
-  AppType,
-  ConfigEnv,
-  ExperimentalOptions,
-  HTMLOptions,
-  InlineConfig,
-  LegacyOptions,
-  PluginHookUtils,
-  PluginOption,
-  ResolveFn,
-  ResolvedWorkerOptions,
-  ResolvedConfig,
-  UserConfig,
-  UserConfigExport,
-  UserConfigFn,
-  UserConfigFnObject,
-  UserConfigFnPromise,
-} from './config'
 export type { FilterPattern } from './utils'
 export type { CorsOptions, CorsOrigin, CommonServerOptions } from './http'
-export type {
-  ViteDevServer,
-  ServerOptions,
-  FileSystemServeOptions,
-  ServerHook,
-  ResolvedServerOptions,
-  ResolvedServerUrls,
-  HttpServer,
-} from './server'
-export type {
-  BuildOptions,
-  LibraryOptions,
-  LibraryFormats,
-  RenderBuiltAssetUrl,
-  ResolvedBuildOptions,
-  ModulePreloadOptions,
-  ResolvedModulePreloadOptions,
-  ResolveModulePreloadDependenciesFn,
-} from './build'
 export type {
   PreviewOptions,
   PreviewServer,
   PreviewServerHook,
   ResolvedPreviewOptions,
 } from './preview'
-export type {
-  DepOptimizationMetadata,
-  DepOptimizationOptions,
-  DepOptimizationConfig,
-  OptimizedDepInfo,
-  ExportsData,
-} from './optimizer'
 export type {
   ResolvedSSROptions,
   SsrDepOptimizationOptions,
@@ -104,7 +142,6 @@ export type { JsonOptions } from './plugins/json'
 export type { TransformOptions as EsbuildTransformOptions } from 'esbuild'
 export type { ESBuildOptions, ESBuildTransformResult } from './plugins/esbuild'
 export type { Manifest, ManifestChunk } from './plugins/manifest'
-export type { ResolveOptions, InternalResolveOptions } from './plugins/resolve'
 export type { SplitVendorChunkCache } from './plugins/splitVendorChunk'
 export type { TerserOptions } from './plugins/terser'
 
@@ -117,11 +154,7 @@ export type { PluginContainer } from './server/pluginContainer'
 export type { ModuleGraph, ModuleNode, ResolvedUrl } from './server/moduleGraph'
 export type { SendOptions } from './server/send'
 export type { ProxyOptions } from './server/middlewares/proxy'
-export type {
-  TransformOptions,
-  TransformResult,
-} from './server/transformRequest'
-export type { HmrOptions, HmrContext } from './server/hmr'
+export type { HmrOptions } from './server/hmr'
 
 export type {
   HMRBroadcaster,
diff --git a/packages/vite/src/node/logger.ts b/packages/vite/src/node/logger.ts
index 7928c954b..ece4da37a 100644
--- a/packages/vite/src/node/logger.ts
+++ b/packages/vite/src/node/logger.ts
@@ -1,9 +1,11 @@
 /* eslint no-console: 0 */
 
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/_createServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/restartServer';
 import readline from 'node:readline'
 import colors from 'picocolors'
 import type { RollupError } from 'rollup'
-import type { ResolvedServerUrls } from './server'
 
 export type LogType = 'error' | 'warn' | 'info'
 export type LogLevel = LogType | 'silent'
diff --git a/packages/vite/src/node/optimizer/esbuildDepPlugin.ts b/packages/vite/src/node/optimizer/esbuildDepPlugin.ts
index 1f4c4dab1..36d84b6e4 100644
--- a/packages/vite/src/node/optimizer/esbuildDepPlugin.ts
+++ b/packages/vite/src/node/optimizer/esbuildDepPlugin.ts
@@ -1,9 +1,17 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isModuleCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { browserExternalId } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { optionalPeerDepId } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { optionalPeerDepId } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { browserExternalId } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
 import path from 'node:path'
 import type { ImportKind, Plugin } from 'esbuild'
 import { KNOWN_ASSET_TYPES } from '../constants'
 import type { PackageCache } from '../packages'
 import { getDepOptimizationConfig } from '../config'
-import type { ResolvedConfig } from '../config'
 import {
   escapeRegex,
   flattenId,
@@ -12,8 +20,6 @@ import {
   moduleListContains,
   normalizePath,
 } from '../utils'
-import { browserExternalId, optionalPeerDepId } from '../plugins/resolve'
-import { isCSSRequest, isModuleCSSRequest } from '../plugins/css'
 
 const externalWithConversionNamespace =
   'vite:dep-pre-bundle:external-conversion'
diff --git a/packages/vite/src/node/optimizer/index.ts b/packages/vite/src/node/optimizer/index.ts
index e62d78fdf..826868a61 100644
--- a/packages/vite/src/node/optimizer/index.ts
+++ b/packages/vite/src/node/optimizer/index.ts
@@ -1,3 +1,30 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { DepOptimizationConfig } from 'packages/vite/src/node/optimizer/index/DepOptimizationConfig';
+import { DepOptimizationConfig } from 'packages/vite/src/node/optimizer/index';
+import { debug } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { DepOptimizationMetadata } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { loadCachedDepOptimizationMetadata } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { loadCachedDepOptimizationMetadata } from 'packages/vite/src/node/optimizer/index';
+import { jsMapExtensionRE } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { DepOptimizationMetadata } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { DepOptimizationResult } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { initDepsOptimizerMetadata } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { addOptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { runOptimizeDeps } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { runOptimizeDeps } from 'packages/vite/src/node/optimizer/index';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun';
+import { prepareEsbuildOptimizerRun } from 'packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun';
+import { prepareEsbuildOptimizerRun } from 'packages/vite/src/node/optimizer/index';
+import { addManuallyIncludedOptimizeDeps } from 'packages/vite/src/node/optimizer/index/addManuallyIncludedOptimizeDeps';
+import { addManuallyIncludedOptimizeDeps } from 'packages/vite/src/node/optimizer/index';
+import { ExportsData } from 'packages/vite/src/node/optimizer/index/extractExportsData';
+import { extractExportsData } from 'packages/vite/src/node/optimizer/index/extractExportsData';
+import { extractExportsData } from 'packages/vite/src/node/optimizer/index';
 import fs from 'node:fs'
 import fsp from 'node:fs/promises'
 import path from 'node:path'
@@ -9,7 +36,6 @@ import esbuild, { build } from 'esbuild'
 import { init, parse } from 'es-module-lexer'
 import glob from 'fast-glob'
 import { getDepOptimizationConfig } from '../config'
-import type { ResolvedConfig } from '../config'
 import {
   createDebugger,
   flattenId,
@@ -37,18 +63,7 @@ export {
   getDepsOptimizer,
 } from './optimizer'
 
-const debug = createDebugger('vite:deps')
-
 const jsExtensionRE = /\.js$/i
-const jsMapExtensionRE = /\.js\.map$/i
-
-export type ExportsData = {
-  hasModuleSyntax: boolean
-  // exported names (for `export { a as b }`, `b` is exported name)
-  exports: readonly string[]
-  // hint if the dep requires loading as jsx
-  jsxLoader?: boolean
-}
 
 export interface DepsOptimizer {
   metadata: DepOptimizationMetadata
@@ -65,88 +80,6 @@ export interface DepsOptimizer {
   options: DepOptimizationOptions
 }
 
-export interface DepOptimizationConfig {
-  /**
-   * Force optimize listed dependencies (must be resolvable import paths,
-   * cannot be globs).
-   */
-  include?: string[]
-  /**
-   * Do not optimize these dependencies (must be resolvable import paths,
-   * cannot be globs).
-   */
-  exclude?: string[]
-  /**
-   * Forces ESM interop when importing these dependencies. Some legacy
-   * packages advertise themselves as ESM but use `require` internally
-   * @experimental
-   */
-  needsInterop?: string[]
-  /**
-   * Options to pass to esbuild during the dep scanning and optimization
-   *
-   * Certain options are omitted since changing them would not be compatible
-   * with Vite's dep optimization.
-   *
-   * - `external` is also omitted, use Vite's `optimizeDeps.exclude` option
-   * - `plugins` are merged with Vite's dep plugin
-   *
-   * https://esbuild.github.io/api
-   */
-  esbuildOptions?: Omit<
-    EsbuildBuildOptions,
-    | 'bundle'
-    | 'entryPoints'
-    | 'external'
-    | 'write'
-    | 'watch'
-    | 'outdir'
-    | 'outfile'
-    | 'outbase'
-    | 'outExtension'
-    | 'metafile'
-  >
-  /**
-   * List of file extensions that can be optimized. A corresponding esbuild
-   * plugin must exist to handle the specific extension.
-   *
-   * By default, Vite can optimize `.mjs`, `.js`, `.ts`, and `.mts` files. This option
-   * allows specifying additional extensions.
-   *
-   * @experimental
-   */
-  extensions?: string[]
-  /**
-   * Deps optimization during build was removed in Vite 5.1. This option is
-   * now redundant and will be removed in a future version. Switch to using
-   * `optimizeDeps.noDiscovery` and an empty or undefined `optimizeDeps.include`.
-   * true or 'dev' disables the optimizer, false or 'build' leaves it enabled.
-   * @default 'build'
-   * @deprecated
-   * @experimental
-   */
-  disabled?: boolean | 'build' | 'dev'
-  /**
-   * Automatic dependency discovery. When `noDiscovery` is true, only dependencies
-   * listed in `include` will be optimized. The scanner isn't run for cold start
-   * in this case. CJS-only dependencies must be present in `include` during dev.
-   * @default false
-   * @experimental
-   */
-  noDiscovery?: boolean
-  /**
-   * When enabled, it will hold the first optimized deps results until all static
-   * imports are crawled on cold start. This avoids the need for full-page reloads
-   * when new dependencies are discovered and they trigger the generation of new
-   * common chunks. If all dependencies are found by the scanner plus the explicitly
-   * defined ones in `include`, it is better to disable this option to let the
-   * browser process more requests in parallel.
-   * @default true
-   * @experimental
-   */
-  holdUntilCrawlEnd?: boolean
-}
-
 export type DepOptimizationOptions = DepOptimizationConfig & {
   /**
    * By default, Vite will crawl your `index.html` to detect dependencies that
@@ -166,76 +99,6 @@ export type DepOptimizationOptions = DepOptimizationConfig & {
   force?: boolean
 }
 
-export interface DepOptimizationResult {
-  metadata: DepOptimizationMetadata
-  /**
-   * When doing a re-run, if there are newly discovered dependencies
-   * the page reload will be delayed until the next rerun so we need
-   * to be able to discard the result
-   */
-  commit: () => Promise<void>
-  cancel: () => void
-}
-
-export interface OptimizedDepInfo {
-  id: string
-  file: string
-  src?: string
-  needsInterop?: boolean
-  browserHash?: string
-  fileHash?: string
-  /**
-   * During optimization, ids can still be resolved to their final location
-   * but the bundles may not yet be saved to disk
-   */
-  processing?: Promise<void>
-  /**
-   * ExportData cache, discovered deps will parse the src entry to get exports
-   * data used both to define if interop is needed and when pre-bundling
-   */
-  exportsData?: Promise<ExportsData>
-}
-
-export interface DepOptimizationMetadata {
-  /**
-   * The main hash is determined by user config and dependency lockfiles.
-   * This is checked on server startup to avoid unnecessary re-bundles.
-   */
-  hash: string
-  /**
-   * This hash is determined by dependency lockfiles.
-   * This is checked on server startup to avoid unnecessary re-bundles.
-   */
-  lockfileHash: string
-  /**
-   * This hash is determined by user config.
-   * This is checked on server startup to avoid unnecessary re-bundles.
-   */
-  configHash: string
-  /**
-   * The browser hash is determined by the main hash plus additional dependencies
-   * discovered at runtime. This is used to invalidate browser requests to
-   * optimized deps.
-   */
-  browserHash: string
-  /**
-   * Metadata for each already optimized dependency
-   */
-  optimized: Record<string, OptimizedDepInfo>
-  /**
-   * Metadata for non-entry optimized chunks and dynamic imports
-   */
-  chunks: Record<string, OptimizedDepInfo>
-  /**
-   * Metadata for each newly discovered dependency after processing
-   */
-  discovered: Record<string, OptimizedDepInfo>
-  /**
-   * OptimizedDepInfo list
-   */
-  depInfoList: OptimizedDepInfo[]
-}
-
 /**
  * Scan and optimize dependencies within a project.
  * Used by Vite CLI when running `vite optimize`.
@@ -301,91 +164,8 @@ export async function optimizeServerSsrDeps(
   return result.metadata
 }
 
-export function initDepsOptimizerMetadata(
-  config: ResolvedConfig,
-  ssr: boolean,
-  timestamp?: string,
-): DepOptimizationMetadata {
-  const { lockfileHash, configHash, hash } = getDepHash(config, ssr)
-  return {
-    hash,
-    lockfileHash,
-    configHash,
-    browserHash: getOptimizedBrowserHash(hash, {}, timestamp),
-    optimized: {},
-    chunks: {},
-    discovered: {},
-    depInfoList: [],
-  }
-}
-
-export function addOptimizedDepInfo(
-  metadata: DepOptimizationMetadata,
-  type: 'optimized' | 'discovered' | 'chunks',
-  depInfo: OptimizedDepInfo,
-): OptimizedDepInfo {
-  metadata[type][depInfo.id] = depInfo
-  metadata.depInfoList.push(depInfo)
-  return depInfo
-}
-
 let firstLoadCachedDepOptimizationMetadata = true
 
-/**
- * Creates the initial dep optimization metadata, loading it from the deps cache
- * if it exists and pre-bundling isn't forced
- */
-export async function loadCachedDepOptimizationMetadata(
-  config: ResolvedConfig,
-  ssr: boolean,
-  force = config.optimizeDeps.force,
-  asCommand = false,
-): Promise<DepOptimizationMetadata | undefined> {
-  const log = asCommand ? config.logger.info : debug
-
-  if (firstLoadCachedDepOptimizationMetadata) {
-    firstLoadCachedDepOptimizationMetadata = false
-    // Fire up a clean up of stale processing deps dirs if older process exited early
-    setTimeout(() => cleanupDepsCacheStaleDirs(config), 0)
-  }
-
-  const depsCacheDir = getDepsCacheDir(config, ssr)
-
-  if (!force) {
-    let cachedMetadata: DepOptimizationMetadata | undefined
-    try {
-      const cachedMetadataPath = path.join(depsCacheDir, METADATA_FILENAME)
-      cachedMetadata = parseDepsOptimizerMetadata(
-        await fsp.readFile(cachedMetadataPath, 'utf-8'),
-        depsCacheDir,
-      )
-    } catch (e) {}
-    // hash is consistent, no need to re-bundle
-    if (cachedMetadata) {
-      if (cachedMetadata.lockfileHash !== getLockfileHash(config, ssr)) {
-        config.logger.info(
-          'Re-optimizing dependencies because lockfile has changed',
-        )
-      } else if (cachedMetadata.configHash !== getConfigHash(config, ssr)) {
-        config.logger.info(
-          'Re-optimizing dependencies because vite config has changed',
-        )
-      } else {
-        log?.('Hash is consistent. Skipping. Use --force to override.')
-        // Nothing to commit or cancel as we are using the cache, we only
-        // need to resolve the processing promise so requests can move on
-        return cachedMetadata
-      }
-    }
-  } else {
-    config.logger.info('Forced re-optimization of dependencies')
-  }
-
-  // Start with a fresh cache
-  debug?.(colors.green(`removing old cache dir ${depsCacheDir}`))
-  await fsp.rm(depsCacheDir, { recursive: true, force: true })
-}
-
 /**
  * Initial optimizeDeps at server start. Perform a fast scan using esbuild to
  * find deps to pre-bundle and include user hard-coded dependencies
@@ -447,422 +227,6 @@ export function depsLogString(qualifiedIds: string[]): string {
   return colors.yellow(qualifiedIds.join(`, `))
 }
 
-/**
- * Internally, Vite uses this function to prepare a optimizeDeps run. When Vite starts, we can get
- * the metadata and start the server without waiting for the optimizeDeps processing to be completed
- */
-export function runOptimizeDeps(
-  resolvedConfig: ResolvedConfig,
-  depsInfo: Record<string, OptimizedDepInfo>,
-  ssr: boolean,
-): {
-  cancel: () => Promise<void>
-  result: Promise<DepOptimizationResult>
-} {
-  const optimizerContext = { cancelled: false }
-
-  const config: ResolvedConfig = {
-    ...resolvedConfig,
-    command: 'build',
-  }
-
-  const depsCacheDir = getDepsCacheDir(resolvedConfig, ssr)
-  const processingCacheDir = getProcessingDepsCacheDir(resolvedConfig, ssr)
-
-  // Create a temporary directory so we don't need to delete optimized deps
-  // until they have been processed. This also avoids leaving the deps cache
-  // directory in a corrupted state if there is an error
-  fs.mkdirSync(processingCacheDir, { recursive: true })
-
-  // a hint for Node.js
-  // all files in the cache directory should be recognized as ES modules
-  debug?.(colors.green(`creating package.json in ${processingCacheDir}`))
-  fs.writeFileSync(
-    path.resolve(processingCacheDir, 'package.json'),
-    `{\n  "type": "module"\n}\n`,
-  )
-
-  const metadata = initDepsOptimizerMetadata(config, ssr)
-
-  metadata.browserHash = getOptimizedBrowserHash(
-    metadata.hash,
-    depsFromOptimizedDepInfo(depsInfo),
-  )
-
-  // We prebundle dependencies with esbuild and cache them, but there is no need
-  // to wait here. Code that needs to access the cached deps needs to await
-  // the optimizedDepInfo.processing promise for each dep
-
-  const qualifiedIds = Object.keys(depsInfo)
-  let cleaned = false
-  let committed = false
-  const cleanUp = () => {
-    // If commit was already called, ignore the clean up even if a cancel was requested
-    // This minimizes the chances of leaving the deps cache in a corrupted state
-    if (!cleaned && !committed) {
-      cleaned = true
-      // No need to wait, we can clean up in the background because temp folders
-      // are unique per run
-      debug?.(colors.green(`removing cache dir ${processingCacheDir}`))
-      try {
-        // When exiting the process, `fsp.rm` may not take effect, so we use `fs.rmSync`
-        fs.rmSync(processingCacheDir, { recursive: true, force: true })
-      } catch (error) {
-        // Ignore errors
-      }
-    }
-  }
-
-  const successfulResult: DepOptimizationResult = {
-    metadata,
-    cancel: cleanUp,
-    commit: async () => {
-      if (cleaned) {
-        throw new Error(
-          'Can not commit a Deps Optimization run as it was cancelled',
-        )
-      }
-      // Ignore clean up requests after this point so the temp folder isn't deleted before
-      // we finish committing the new deps cache files to the deps folder
-      committed = true
-
-      // Write metadata file, then commit the processing folder to the global deps cache
-      // Rewire the file paths from the temporary processing dir to the final deps cache dir
-      const dataPath = path.join(processingCacheDir, METADATA_FILENAME)
-      debug?.(
-        colors.green(`creating ${METADATA_FILENAME} in ${processingCacheDir}`),
-      )
-      fs.writeFileSync(
-        dataPath,
-        stringifyDepsOptimizerMetadata(metadata, depsCacheDir),
-      )
-
-      // In order to minimize the time where the deps folder isn't in a consistent state,
-      // we first rename the old depsCacheDir to a temporary path, then we rename the
-      // new processing cache dir to the depsCacheDir. In systems where doing so in sync
-      // is safe, we do an atomic operation (at least for this thread). For Windows, we
-      // found there are cases where the rename operation may finish before it's done
-      // so we do a graceful rename checking that the folder has been properly renamed.
-      // We found that the rename-rename (then delete the old folder in the background)
-      // is safer than a delete-rename operation.
-      const temporaryPath = depsCacheDir + getTempSuffix()
-      const depsCacheDirPresent = fs.existsSync(depsCacheDir)
-      if (isWindows) {
-        if (depsCacheDirPresent) {
-          debug?.(colors.green(`renaming ${depsCacheDir} to ${temporaryPath}`))
-          await safeRename(depsCacheDir, temporaryPath)
-        }
-        debug?.(
-          colors.green(`renaming ${processingCacheDir} to ${depsCacheDir}`),
-        )
-        await safeRename(processingCacheDir, depsCacheDir)
-      } else {
-        if (depsCacheDirPresent) {
-          debug?.(colors.green(`renaming ${depsCacheDir} to ${temporaryPath}`))
-          fs.renameSync(depsCacheDir, temporaryPath)
-        }
-        debug?.(
-          colors.green(`renaming ${processingCacheDir} to ${depsCacheDir}`),
-        )
-        fs.renameSync(processingCacheDir, depsCacheDir)
-      }
-
-      // Delete temporary path in the background
-      if (depsCacheDirPresent) {
-        debug?.(colors.green(`removing cache temp dir ${temporaryPath}`))
-        fsp.rm(temporaryPath, { recursive: true, force: true })
-      }
-    },
-  }
-
-  if (!qualifiedIds.length) {
-    // No deps to optimize, we still commit the processing cache dir to remove
-    // the previous optimized deps if they exist, and let the next server start
-    // skip the scanner step if the lockfile hasn't changed
-    return {
-      cancel: async () => cleanUp(),
-      result: Promise.resolve(successfulResult),
-    }
-  }
-
-  const cancelledResult: DepOptimizationResult = {
-    metadata,
-    commit: async () => cleanUp(),
-    cancel: cleanUp,
-  }
-
-  const start = performance.now()
-
-  const preparedRun = prepareEsbuildOptimizerRun(
-    resolvedConfig,
-    depsInfo,
-    ssr,
-    processingCacheDir,
-    optimizerContext,
-  )
-
-  const runResult = preparedRun.then(({ context, idToExports }) => {
-    function disposeContext() {
-      return context?.dispose().catch((e) => {
-        config.logger.error('Failed to dispose esbuild context', { error: e })
-      })
-    }
-    if (!context || optimizerContext.cancelled) {
-      disposeContext()
-      return cancelledResult
-    }
-
-    return context
-      .rebuild()
-      .then((result) => {
-        const meta = result.metafile!
-
-        // the paths in `meta.outputs` are relative to `process.cwd()`
-        const processingCacheDirOutputPath = path.relative(
-          process.cwd(),
-          processingCacheDir,
-        )
-
-        for (const id in depsInfo) {
-          const output = esbuildOutputFromId(
-            meta.outputs,
-            id,
-            processingCacheDir,
-          )
-
-          const { exportsData, ...info } = depsInfo[id]
-          addOptimizedDepInfo(metadata, 'optimized', {
-            ...info,
-            // We only need to hash the output.imports in to check for stability, but adding the hash
-            // and file path gives us a unique hash that may be useful for other things in the future
-            fileHash: getHash(
-              metadata.hash +
-                depsInfo[id].file +
-                JSON.stringify(output.imports),
-            ),
-            browserHash: metadata.browserHash,
-            // After bundling we have more information and can warn the user about legacy packages
-            // that require manual configuration
-            needsInterop: needsInterop(
-              config,
-              ssr,
-              id,
-              idToExports[id],
-              output,
-            ),
-          })
-        }
-
-        for (const o of Object.keys(meta.outputs)) {
-          if (!jsMapExtensionRE.test(o)) {
-            const id = path
-              .relative(processingCacheDirOutputPath, o)
-              .replace(jsExtensionRE, '')
-            const file = getOptimizedDepPath(id, resolvedConfig, ssr)
-            if (
-              !findOptimizedDepInfoInRecord(
-                metadata.optimized,
-                (depInfo) => depInfo.file === file,
-              )
-            ) {
-              addOptimizedDepInfo(metadata, 'chunks', {
-                id,
-                file,
-                needsInterop: false,
-                browserHash: metadata.browserHash,
-              })
-            }
-          }
-        }
-
-        debug?.(
-          `Dependencies bundled in ${(performance.now() - start).toFixed(2)}ms`,
-        )
-
-        return successfulResult
-      })
-
-      .catch((e) => {
-        if (e.errors && e.message.includes('The build was canceled')) {
-          // esbuild logs an error when cancelling, but this is expected so
-          // return an empty result instead
-          return cancelledResult
-        }
-        throw e
-      })
-      .finally(() => {
-        return disposeContext()
-      })
-  })
-
-  runResult.catch(() => {
-    cleanUp()
-  })
-
-  return {
-    async cancel() {
-      optimizerContext.cancelled = true
-      const { context } = await preparedRun
-      await context?.cancel()
-      cleanUp()
-    },
-    result: runResult,
-  }
-}
-
-async function prepareEsbuildOptimizerRun(
-  resolvedConfig: ResolvedConfig,
-  depsInfo: Record<string, OptimizedDepInfo>,
-  ssr: boolean,
-  processingCacheDir: string,
-  optimizerContext: { cancelled: boolean },
-): Promise<{
-  context?: BuildContext
-  idToExports: Record<string, ExportsData>
-}> {
-  const config: ResolvedConfig = {
-    ...resolvedConfig,
-    command: 'build',
-  }
-
-  // esbuild generates nested directory output with lowest common ancestor base
-  // this is unpredictable and makes it difficult to analyze entry / output
-  // mapping. So what we do here is:
-  // 1. flatten all ids to eliminate slash
-  // 2. in the plugin, read the entry ourselves as virtual files to retain the
-  //    path.
-  const flatIdDeps: Record<string, string> = {}
-  const idToExports: Record<string, ExportsData> = {}
-
-  const optimizeDeps = getDepOptimizationConfig(config, ssr)
-
-  const { plugins: pluginsFromConfig = [], ...esbuildOptions } =
-    optimizeDeps?.esbuildOptions ?? {}
-
-  await Promise.all(
-    Object.keys(depsInfo).map(async (id) => {
-      const src = depsInfo[id].src!
-      const exportsData = await (depsInfo[id].exportsData ??
-        extractExportsData(src, config, ssr))
-      if (exportsData.jsxLoader && !esbuildOptions.loader?.['.js']) {
-        // Ensure that optimization won't fail by defaulting '.js' to the JSX parser.
-        // This is useful for packages such as Gatsby.
-        esbuildOptions.loader = {
-          '.js': 'jsx',
-          ...esbuildOptions.loader,
-        }
-      }
-      const flatId = flattenId(id)
-      flatIdDeps[flatId] = src
-      idToExports[id] = exportsData
-    }),
-  )
-
-  if (optimizerContext.cancelled) return { context: undefined, idToExports }
-
-  const define = {
-    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode),
-  }
-
-  const platform =
-    ssr && config.ssr?.target !== 'webworker' ? 'node' : 'browser'
-
-  const external = [...(optimizeDeps?.exclude ?? [])]
-
-  const plugins = [...pluginsFromConfig]
-  if (external.length) {
-    plugins.push(esbuildCjsExternalPlugin(external, platform))
-  }
-  plugins.push(esbuildDepPlugin(flatIdDeps, external, config, ssr))
-
-  const context = await esbuild.context({
-    absWorkingDir: process.cwd(),
-    entryPoints: Object.keys(flatIdDeps),
-    bundle: true,
-    // We can't use platform 'neutral', as esbuild has custom handling
-    // when the platform is 'node' or 'browser' that can't be emulated
-    // by using mainFields and conditions
-    platform,
-    define,
-    format: 'esm',
-    // See https://github.com/evanw/esbuild/issues/1921#issuecomment-1152991694
-    banner:
-      platform === 'node'
-        ? {
-            js: `import { createRequire } from 'module';const require = createRequire(import.meta.url);`,
-          }
-        : undefined,
-    target: ESBUILD_MODULES_TARGET,
-    external,
-    logLevel: 'error',
-    splitting: true,
-    sourcemap: true,
-    outdir: processingCacheDir,
-    ignoreAnnotations: true,
-    metafile: true,
-    plugins,
-    charset: 'utf8',
-    ...esbuildOptions,
-    supported: {
-      ...defaultEsbuildSupported,
-      ...esbuildOptions.supported,
-    },
-  })
-  return { context, idToExports }
-}
-
-export async function addManuallyIncludedOptimizeDeps(
-  deps: Record<string, string>,
-  config: ResolvedConfig,
-  ssr: boolean,
-): Promise<void> {
-  const { logger } = config
-  const optimizeDeps = getDepOptimizationConfig(config, ssr)
-  const optimizeDepsInclude = optimizeDeps?.include ?? []
-  if (optimizeDepsInclude.length) {
-    const unableToOptimize = (id: string, msg: string) => {
-      if (optimizeDepsInclude.includes(id)) {
-        logger.warn(
-          `${msg}: ${colors.cyan(id)}, present in '${
-            ssr ? 'ssr.' : ''
-          }optimizeDeps.include'`,
-        )
-      }
-    }
-
-    const includes = [...optimizeDepsInclude]
-    for (let i = 0; i < includes.length; i++) {
-      const id = includes[i]
-      if (glob.isDynamicPattern(id)) {
-        const globIds = expandGlobIds(id, config)
-        includes.splice(i, 1, ...globIds)
-        i += globIds.length - 1
-      }
-    }
-
-    const resolve = createOptimizeDepsIncludeResolver(config, ssr)
-    for (const id of includes) {
-      // normalize 'foo   >bar` as 'foo > bar' to prevent same id being added
-      // and for pretty printing
-      const normalizedId = normalizeId(id)
-      if (!deps[normalizedId]) {
-        const entry = await resolve(id)
-        if (entry) {
-          if (isOptimizable(entry, optimizeDeps)) {
-            if (!entry.endsWith('?__vite_skip_optimization')) {
-              deps[normalizedId] = entry
-            }
-          } else {
-            unableToOptimize(id, 'Cannot optimize dependency')
-          }
-        } else {
-          unableToOptimize(id, 'Failed to resolve dependency')
-        }
-      }
-    }
-  }
-}
-
 // Convert to { id: src }
 export function depsFromOptimizedDepInfo(
   depsInfo: Record<string, OptimizedDepInfo>,
@@ -1059,60 +423,6 @@ function esbuildOutputFromId(
   }
 }
 
-export async function extractExportsData(
-  filePath: string,
-  config: ResolvedConfig,
-  ssr: boolean,
-): Promise<ExportsData> {
-  await init
-
-  const optimizeDeps = getDepOptimizationConfig(config, ssr)
-
-  const esbuildOptions = optimizeDeps?.esbuildOptions ?? {}
-  if (optimizeDeps.extensions?.some((ext) => filePath.endsWith(ext))) {
-    // For custom supported extensions, build the entry file to transform it into JS,
-    // and then parse with es-module-lexer. Note that the `bundle` option is not `true`,
-    // so only the entry file is being transformed.
-    const result = await build({
-      ...esbuildOptions,
-      entryPoints: [filePath],
-      write: false,
-      format: 'esm',
-    })
-    const [, exports, , hasModuleSyntax] = parse(result.outputFiles[0].text)
-    return {
-      hasModuleSyntax,
-      exports: exports.map((e) => e.n),
-    }
-  }
-
-  let parseResult: ReturnType<typeof parse>
-  let usedJsxLoader = false
-
-  const entryContent = await fsp.readFile(filePath, 'utf-8')
-  try {
-    parseResult = parse(entryContent)
-  } catch {
-    const loader = esbuildOptions.loader?.[path.extname(filePath)] || 'jsx'
-    debug?.(
-      `Unable to parse: ${filePath}.\n Trying again with a ${loader} transform.`,
-    )
-    const transformed = await transformWithEsbuild(entryContent, filePath, {
-      loader,
-    })
-    parseResult = parse(transformed.code)
-    usedJsxLoader = true
-  }
-
-  const [, exports, , hasModuleSyntax] = parseResult
-  const exportsData: ExportsData = {
-    hasModuleSyntax,
-    exports: exports.map((e) => e.n),
-    jsxLoader: usedJsxLoader,
-  }
-  return exportsData
-}
-
 function needsInterop(
   config: ResolvedConfig,
   ssr: boolean,
diff --git a/packages/vite/src/node/optimizer/index/DepOptimizationConfig.ts b/packages/vite/src/node/optimizer/index/DepOptimizationConfig.ts
new file mode 100644
index 000000000..5d0aa2a3c
--- /dev/null
+++ b/packages/vite/src/node/optimizer/index/DepOptimizationConfig.ts
@@ -0,0 +1,84 @@
+import type { BuildContext, BuildOptions as EsbuildBuildOptions } from 'esbuild'
+
+
+export interface DepOptimizationConfig {
+  /**
+   * Force optimize listed dependencies (must be resolvable import paths,
+   * cannot be globs).
+   */
+  include?: string[]
+  /**
+   * Do not optimize these dependencies (must be resolvable import paths,
+   * cannot be globs).
+   */
+  exclude?: string[]
+  /**
+   * Forces ESM interop when importing these dependencies. Some legacy
+   * packages advertise themselves as ESM but use `require` internally
+   * @experimental
+   */
+  needsInterop?: string[]
+  /**
+   * Options to pass to esbuild during the dep scanning and optimization
+   *
+   * Certain options are omitted since changing them would not be compatible
+   * with Vite's dep optimization.
+   *
+   * - `external` is also omitted, use Vite's `optimizeDeps.exclude` option
+   * - `plugins` are merged with Vite's dep plugin
+   *
+   * https://esbuild.github.io/api
+   */
+  esbuildOptions?: Omit<
+    EsbuildBuildOptions,
+    | 'bundle'
+    | 'entryPoints'
+    | 'external'
+    | 'write'
+    | 'watch'
+    | 'outdir'
+    | 'outfile'
+    | 'outbase'
+    | 'outExtension'
+    | 'metafile'
+  >
+  /**
+   * List of file extensions that can be optimized. A corresponding esbuild
+   * plugin must exist to handle the specific extension.
+   *
+   * By default, Vite can optimize `.mjs`, `.js`, `.ts`, and `.mts` files. This option
+   * allows specifying additional extensions.
+   *
+   * @experimental
+   */
+  extensions?: string[]
+  /**
+   * Deps optimization during build was removed in Vite 5.1. This option is
+   * now redundant and will be removed in a future version. Switch to using
+   * `optimizeDeps.noDiscovery` and an empty or undefined `optimizeDeps.include`.
+   * true or 'dev' disables the optimizer, false or 'build' leaves it enabled.
+   * @default 'build'
+   * @deprecated
+   * @experimental
+   */
+  disabled?: boolean | 'build' | 'dev'
+  /**
+   * Automatic dependency discovery. When `noDiscovery` is true, only dependencies
+   * listed in `include` will be optimized. The scanner isn't run for cold start
+   * in this case. CJS-only dependencies must be present in `include` during dev.
+   * @default false
+   * @experimental
+   */
+  noDiscovery?: boolean
+  /**
+   * When enabled, it will hold the first optimized deps results until all static
+   * imports are crawled on cold start. This avoids the need for full-page reloads
+   * when new dependencies are discovered and they trigger the generation of new
+   * common chunks. If all dependencies are found by the scanner plus the explicitly
+   * defined ones in `include`, it is better to disable this option to let the
+   * browser process more requests in parallel.
+   * @default true
+   * @experimental
+   */
+  holdUntilCrawlEnd?: boolean
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/optimizer/index/addManuallyIncludedOptimizeDeps.ts b/packages/vite/src/node/optimizer/index/addManuallyIncludedOptimizeDeps.ts
new file mode 100644
index 000000000..a3b0a80be
--- /dev/null
+++ b/packages/vite/src/node/optimizer/index/addManuallyIncludedOptimizeDeps.ts
@@ -0,0 +1,61 @@
+import colors from 'picocolors'
+import glob from 'fast-glob'
+import { getDepOptimizationConfig } from 'packages/vite/src/node/config';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { isOptimizable } from 'packages/vite/src/node/utils';
+import { normalizeId } from 'packages/vite/src/node/utils';
+import { expandGlobIds } from 'packages/vite/src/node/optimizer/resolve';
+import { createOptimizeDepsIncludeResolver } from 'packages/vite/src/node/optimizer/resolve';
+
+
+export async function addManuallyIncludedOptimizeDeps(
+  deps: Record<string, string>,
+  config: ResolvedConfig,
+  ssr: boolean,
+): Promise<void> {
+  const { logger } = config
+  const optimizeDeps = getDepOptimizationConfig(config, ssr)
+  const optimizeDepsInclude = optimizeDeps?.include ?? []
+  if (optimizeDepsInclude.length) {
+    const unableToOptimize = (id: string, msg: string) => {
+      if (optimizeDepsInclude.includes(id)) {
+        logger.warn(
+          `${msg}: ${colors.cyan(id)}, present in '${
+            ssr ? 'ssr.' : ''
+          }optimizeDeps.include'`,
+        )
+      }
+    }
+
+    const includes = [...optimizeDepsInclude]
+    for (let i = 0; i < includes.length; i++) {
+      const id = includes[i]
+      if (glob.isDynamicPattern(id)) {
+        const globIds = expandGlobIds(id, config)
+        includes.splice(i, 1, ...globIds)
+        i += globIds.length - 1
+      }
+    }
+
+    const resolve = createOptimizeDepsIncludeResolver(config, ssr)
+    for (const id of includes) {
+      // normalize 'foo   >bar` as 'foo > bar' to prevent same id being added
+      // and for pretty printing
+      const normalizedId = normalizeId(id)
+      if (!deps[normalizedId]) {
+        const entry = await resolve(id)
+        if (entry) {
+          if (isOptimizable(entry, optimizeDeps)) {
+            if (!entry.endsWith('?__vite_skip_optimization')) {
+              deps[normalizedId] = entry
+            }
+          } else {
+            unableToOptimize(id, 'Cannot optimize dependency')
+          }
+        } else {
+          unableToOptimize(id, 'Failed to resolve dependency')
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/optimizer/index/extractExportsData.ts b/packages/vite/src/node/optimizer/index/extractExportsData.ts
new file mode 100644
index 000000000..a9540b5b9
--- /dev/null
+++ b/packages/vite/src/node/optimizer/index/extractExportsData.ts
@@ -0,0 +1,70 @@
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import esbuild, { build } from 'esbuild'
+import { init, parse } from 'es-module-lexer'
+import { getDepOptimizationConfig } from 'packages/vite/src/node/config';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { transformWithEsbuild } from 'packages/vite/src/node/plugins/esbuild';
+
+
+export type ExportsData = {
+  hasModuleSyntax: boolean
+  // exported names (for `export { a as b }`, `b` is exported name)
+  exports: readonly string[]
+  // hint if the dep requires loading as jsx
+  jsxLoader?: boolean
+}
+
+export async function extractExportsData(
+  filePath: string,
+  config: ResolvedConfig,
+  ssr: boolean,
+): Promise<ExportsData> {
+  await init
+
+  const optimizeDeps = getDepOptimizationConfig(config, ssr)
+
+  const esbuildOptions = optimizeDeps?.esbuildOptions ?? {}
+  if (optimizeDeps.extensions?.some((ext) => filePath.endsWith(ext))) {
+    // For custom supported extensions, build the entry file to transform it into JS,
+    // and then parse with es-module-lexer. Note that the `bundle` option is not `true`,
+    // so only the entry file is being transformed.
+    const result = await build({
+      ...esbuildOptions,
+      entryPoints: [filePath],
+      write: false,
+      format: 'esm',
+    })
+    const [, exports, , hasModuleSyntax] = parse(result.outputFiles[0].text)
+    return {
+      hasModuleSyntax,
+      exports: exports.map((e) => e.n),
+    }
+  }
+
+  let parseResult: ReturnType<typeof parse>
+  let usedJsxLoader = false
+
+  const entryContent = await fsp.readFile(filePath, 'utf-8')
+  try {
+    parseResult = parse(entryContent)
+  } catch {
+    const loader = esbuildOptions.loader?.[path.extname(filePath)] || 'jsx'
+    debug?.(
+      `Unable to parse: ${filePath}.\n Trying again with a ${loader} transform.`,
+    )
+    const transformed = await transformWithEsbuild(entryContent, filePath, {
+      loader,
+    })
+    parseResult = parse(transformed.code)
+    usedJsxLoader = true
+  }
+
+  const [, exports, , hasModuleSyntax] = parseResult
+  const exportsData: ExportsData = {
+    hasModuleSyntax,
+    exports: exports.map((e) => e.n),
+    jsxLoader: usedJsxLoader,
+  }
+  return exportsData
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata.ts b/packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata.ts
new file mode 100644
index 000000000..157298771
--- /dev/null
+++ b/packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata.ts
@@ -0,0 +1,131 @@
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import colors from 'picocolors'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { METADATA_FILENAME } from 'packages/vite/src/node/constants';
+import { createDebugger } from 'packages/vite/src/node/utils';
+
+
+const export debug = createDebugger('vite:deps')
+
+export type ExportsData = {
+  hasModuleSyntax: boolean
+  // exported names (for `export { a as b }`, `b` is exported name)
+  exports: readonly string[]
+  // hint if the dep requires loading as jsx
+  jsxLoader?: boolean
+}
+
+export interface OptimizedDepInfo {
+  id: string
+  file: string
+  src?: string
+  needsInterop?: boolean
+  browserHash?: string
+  fileHash?: string
+  /**
+   * During optimization, ids can still be resolved to their final location
+   * but the bundles may not yet be saved to disk
+   */
+  processing?: Promise<void>
+  /**
+   * ExportData cache, discovered deps will parse the src entry to get exports
+   * data used both to define if interop is needed and when pre-bundling
+   */
+  exportsData?: Promise<ExportsData>
+}
+
+export interface DepOptimizationMetadata {
+  /**
+   * The main hash is determined by user config and dependency lockfiles.
+   * This is checked on server startup to avoid unnecessary re-bundles.
+   */
+  hash: string
+  /**
+   * This hash is determined by dependency lockfiles.
+   * This is checked on server startup to avoid unnecessary re-bundles.
+   */
+  lockfileHash: string
+  /**
+   * This hash is determined by user config.
+   * This is checked on server startup to avoid unnecessary re-bundles.
+   */
+  configHash: string
+  /**
+   * The browser hash is determined by the main hash plus additional dependencies
+   * discovered at runtime. This is used to invalidate browser requests to
+   * optimized deps.
+   */
+  browserHash: string
+  /**
+   * Metadata for each already optimized dependency
+   */
+  optimized: Record<string, OptimizedDepInfo>
+  /**
+   * Metadata for non-entry optimized chunks and dynamic imports
+   */
+  chunks: Record<string, OptimizedDepInfo>
+  /**
+   * Metadata for each newly discovered dependency after processing
+   */
+  discovered: Record<string, OptimizedDepInfo>
+  /**
+   * OptimizedDepInfo list
+   */
+  depInfoList: OptimizedDepInfo[]
+}
+
+/**
+ * Creates the initial dep optimization metadata, loading it from the deps cache
+ * if it exists and pre-bundling isn't forced
+ */
+export async function loadCachedDepOptimizationMetadata(
+  config: ResolvedConfig,
+  ssr: boolean,
+  force = config.optimizeDeps.force,
+  asCommand = false,
+): Promise<DepOptimizationMetadata | undefined> {
+  const log = asCommand ? config.logger.info : debug
+
+  if (firstLoadCachedDepOptimizationMetadata) {
+    firstLoadCachedDepOptimizationMetadata = false
+    // Fire up a clean up of stale processing deps dirs if older process exited early
+    setTimeout(() => cleanupDepsCacheStaleDirs(config), 0)
+  }
+
+  const depsCacheDir = getDepsCacheDir(config, ssr)
+
+  if (!force) {
+    let cachedMetadata: DepOptimizationMetadata | undefined
+    try {
+      const cachedMetadataPath = path.join(depsCacheDir, METADATA_FILENAME)
+      cachedMetadata = parseDepsOptimizerMetadata(
+        await fsp.readFile(cachedMetadataPath, 'utf-8'),
+        depsCacheDir,
+      )
+    } catch (e) {}
+    // hash is consistent, no need to re-bundle
+    if (cachedMetadata) {
+      if (cachedMetadata.lockfileHash !== getLockfileHash(config, ssr)) {
+        config.logger.info(
+          'Re-optimizing dependencies because lockfile has changed',
+        )
+      } else if (cachedMetadata.configHash !== getConfigHash(config, ssr)) {
+        config.logger.info(
+          'Re-optimizing dependencies because vite config has changed',
+        )
+      } else {
+        log?.('Hash is consistent. Skipping. Use --force to override.')
+        // Nothing to commit or cancel as we are using the cache, we only
+        // need to resolve the processing promise so requests can move on
+        return cachedMetadata
+      }
+    }
+  } else {
+    config.logger.info('Forced re-optimization of dependencies')
+  }
+
+  // Start with a fresh cache
+  debug?.(colors.green(`removing old cache dir ${depsCacheDir}`))
+  await fsp.rm(depsCacheDir, { recursive: true, force: true })
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun.ts b/packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun.ts
new file mode 100644
index 000000000..37e1560b0
--- /dev/null
+++ b/packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun.ts
@@ -0,0 +1,136 @@
+import type { BuildContext, BuildOptions as EsbuildBuildOptions } from 'esbuild'
+import esbuild, { build } from 'esbuild'
+import { getDepOptimizationConfig } from 'packages/vite/src/node/config';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { defaultEsbuildSupported } from 'packages/vite/src/node/plugins/esbuild';
+import { ESBUILD_MODULES_TARGET } from 'packages/vite/src/node/constants';
+import { esbuildCjsExternalPlugin } from 'packages/vite/src/node/optimizer/esbuildDepPlugin';
+
+
+export type ExportsData = {
+  hasModuleSyntax: boolean
+  // exported names (for `export { a as b }`, `b` is exported name)
+  exports: readonly string[]
+  // hint if the dep requires loading as jsx
+  jsxLoader?: boolean
+}
+
+export interface OptimizedDepInfo {
+  id: string
+  file: string
+  src?: string
+  needsInterop?: boolean
+  browserHash?: string
+  fileHash?: string
+  /**
+   * During optimization, ids can still be resolved to their final location
+   * but the bundles may not yet be saved to disk
+   */
+  processing?: Promise<void>
+  /**
+   * ExportData cache, discovered deps will parse the src entry to get exports
+   * data used both to define if interop is needed and when pre-bundling
+   */
+  exportsData?: Promise<ExportsData>
+}
+
+export async function prepareEsbuildOptimizerRun(
+  resolvedConfig: ResolvedConfig,
+  depsInfo: Record<string, OptimizedDepInfo>,
+  ssr: boolean,
+  processingCacheDir: string,
+  optimizerContext: { cancelled: boolean },
+): Promise<{
+  context?: BuildContext
+  idToExports: Record<string, ExportsData>
+}> {
+  const config: ResolvedConfig = {
+    ...resolvedConfig,
+    command: 'build',
+  }
+
+  // esbuild generates nested directory output with lowest common ancestor base
+  // this is unpredictable and makes it difficult to analyze entry / output
+  // mapping. So what we do here is:
+  // 1. flatten all ids to eliminate slash
+  // 2. in the plugin, read the entry ourselves as virtual files to retain the
+  //    path.
+  const flatIdDeps: Record<string, string> = {}
+  const idToExports: Record<string, ExportsData> = {}
+
+  const optimizeDeps = getDepOptimizationConfig(config, ssr)
+
+  const { plugins: pluginsFromConfig = [], ...esbuildOptions } =
+    optimizeDeps?.esbuildOptions ?? {}
+
+  await Promise.all(
+    Object.keys(depsInfo).map(async (id) => {
+      const src = depsInfo[id].src!
+      const exportsData = await (depsInfo[id].exportsData ??
+        extractExportsData(src, config, ssr))
+      if (exportsData.jsxLoader && !esbuildOptions.loader?.['.js']) {
+        // Ensure that optimization won't fail by defaulting '.js' to the JSX parser.
+        // This is useful for packages such as Gatsby.
+        esbuildOptions.loader = {
+          '.js': 'jsx',
+          ...esbuildOptions.loader,
+        }
+      }
+      const flatId = flattenId(id)
+      flatIdDeps[flatId] = src
+      idToExports[id] = exportsData
+    }),
+  )
+
+  if (optimizerContext.cancelled) return { context: undefined, idToExports }
+
+  const define = {
+    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || config.mode),
+  }
+
+  const platform =
+    ssr && config.ssr?.target !== 'webworker' ? 'node' : 'browser'
+
+  const external = [...(optimizeDeps?.exclude ?? [])]
+
+  const plugins = [...pluginsFromConfig]
+  if (external.length) {
+    plugins.push(esbuildCjsExternalPlugin(external, platform))
+  }
+  plugins.push(esbuildDepPlugin(flatIdDeps, external, config, ssr))
+
+  const context = await esbuild.context({
+    absWorkingDir: process.cwd(),
+    entryPoints: Object.keys(flatIdDeps),
+    bundle: true,
+    // We can't use platform 'neutral', as esbuild has custom handling
+    // when the platform is 'node' or 'browser' that can't be emulated
+    // by using mainFields and conditions
+    platform,
+    define,
+    format: 'esm',
+    // See https://github.com/evanw/esbuild/issues/1921#issuecomment-1152991694
+    banner:
+      platform === 'node'
+        ? {
+            js: `import { createRequire } from 'module';const require = createRequire(import.meta.url);`,
+          }
+        : undefined,
+    target: ESBUILD_MODULES_TARGET,
+    external,
+    logLevel: 'error',
+    splitting: true,
+    sourcemap: true,
+    outdir: processingCacheDir,
+    ignoreAnnotations: true,
+    metafile: true,
+    plugins,
+    charset: 'utf8',
+    ...esbuildOptions,
+    supported: {
+      ...defaultEsbuildSupported,
+      ...esbuildOptions.supported,
+    },
+  })
+  return { context, idToExports }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/optimizer/index/runOptimizeDeps.ts b/packages/vite/src/node/optimizer/index/runOptimizeDeps.ts
new file mode 100644
index 000000000..02743a788
--- /dev/null
+++ b/packages/vite/src/node/optimizer/index/runOptimizeDeps.ts
@@ -0,0 +1,381 @@
+import fs from 'node:fs'
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import { performance } from 'node:perf_hooks'
+import colors from 'picocolors'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { getHash } from 'packages/vite/src/node/utils';
+import { METADATA_FILENAME } from 'packages/vite/src/node/constants';
+import { isWindows } from 'packages/vite/src/shared/utils';
+
+
+const export jsMapExtensionRE = /\.js\.map$/i
+
+export type ExportsData = {
+  hasModuleSyntax: boolean
+  // exported names (for `export { a as b }`, `b` is exported name)
+  exports: readonly string[]
+  // hint if the dep requires loading as jsx
+  jsxLoader?: boolean
+}
+
+export interface OptimizedDepInfo {
+  id: string
+  file: string
+  src?: string
+  needsInterop?: boolean
+  browserHash?: string
+  fileHash?: string
+  /**
+   * During optimization, ids can still be resolved to their final location
+   * but the bundles may not yet be saved to disk
+   */
+  processing?: Promise<void>
+  /**
+   * ExportData cache, discovered deps will parse the src entry to get exports
+   * data used both to define if interop is needed and when pre-bundling
+   */
+  exportsData?: Promise<ExportsData>
+}
+
+export interface DepOptimizationMetadata {
+  /**
+   * The main hash is determined by user config and dependency lockfiles.
+   * This is checked on server startup to avoid unnecessary re-bundles.
+   */
+  hash: string
+  /**
+   * This hash is determined by dependency lockfiles.
+   * This is checked on server startup to avoid unnecessary re-bundles.
+   */
+  lockfileHash: string
+  /**
+   * This hash is determined by user config.
+   * This is checked on server startup to avoid unnecessary re-bundles.
+   */
+  configHash: string
+  /**
+   * The browser hash is determined by the main hash plus additional dependencies
+   * discovered at runtime. This is used to invalidate browser requests to
+   * optimized deps.
+   */
+  browserHash: string
+  /**
+   * Metadata for each already optimized dependency
+   */
+  optimized: Record<string, OptimizedDepInfo>
+  /**
+   * Metadata for non-entry optimized chunks and dynamic imports
+   */
+  chunks: Record<string, OptimizedDepInfo>
+  /**
+   * Metadata for each newly discovered dependency after processing
+   */
+  discovered: Record<string, OptimizedDepInfo>
+  /**
+   * OptimizedDepInfo list
+   */
+  depInfoList: OptimizedDepInfo[]
+}
+
+export interface DepOptimizationResult {
+  metadata: DepOptimizationMetadata
+  /**
+   * When doing a re-run, if there are newly discovered dependencies
+   * the page reload will be delayed until the next rerun so we need
+   * to be able to discard the result
+   */
+  commit: () => Promise<void>
+  cancel: () => void
+}
+
+export function initDepsOptimizerMetadata(
+  config: ResolvedConfig,
+  ssr: boolean,
+  timestamp?: string,
+): DepOptimizationMetadata {
+  const { lockfileHash, configHash, hash } = getDepHash(config, ssr)
+  return {
+    hash,
+    lockfileHash,
+    configHash,
+    browserHash: getOptimizedBrowserHash(hash, {}, timestamp),
+    optimized: {},
+    chunks: {},
+    discovered: {},
+    depInfoList: [],
+  }
+}
+
+export function addOptimizedDepInfo(
+  metadata: DepOptimizationMetadata,
+  type: 'optimized' | 'discovered' | 'chunks',
+  depInfo: OptimizedDepInfo,
+): OptimizedDepInfo {
+  metadata[type][depInfo.id] = depInfo
+  metadata.depInfoList.push(depInfo)
+  return depInfo
+}
+
+/**
+ * Internally, Vite uses this function to prepare a optimizeDeps run. When Vite starts, we can get
+ * the metadata and start the server without waiting for the optimizeDeps processing to be completed
+ */
+export function runOptimizeDeps(
+  resolvedConfig: ResolvedConfig,
+  depsInfo: Record<string, OptimizedDepInfo>,
+  ssr: boolean,
+): {
+  cancel: () => Promise<void>
+  result: Promise<DepOptimizationResult>
+} {
+  const optimizerContext = { cancelled: false }
+
+  const config: ResolvedConfig = {
+    ...resolvedConfig,
+    command: 'build',
+  }
+
+  const depsCacheDir = getDepsCacheDir(resolvedConfig, ssr)
+  const processingCacheDir = getProcessingDepsCacheDir(resolvedConfig, ssr)
+
+  // Create a temporary directory so we don't need to delete optimized deps
+  // until they have been processed. This also avoids leaving the deps cache
+  // directory in a corrupted state if there is an error
+  fs.mkdirSync(processingCacheDir, { recursive: true })
+
+  // a hint for Node.js
+  // all files in the cache directory should be recognized as ES modules
+  debug?.(colors.green(`creating package.json in ${processingCacheDir}`))
+  fs.writeFileSync(
+    path.resolve(processingCacheDir, 'package.json'),
+    `{\n  "type": "module"\n}\n`,
+  )
+
+  const metadata = initDepsOptimizerMetadata(config, ssr)
+
+  metadata.browserHash = getOptimizedBrowserHash(
+    metadata.hash,
+    depsFromOptimizedDepInfo(depsInfo),
+  )
+
+  // We prebundle dependencies with esbuild and cache them, but there is no need
+  // to wait here. Code that needs to access the cached deps needs to await
+  // the optimizedDepInfo.processing promise for each dep
+
+  const qualifiedIds = Object.keys(depsInfo)
+  let cleaned = false
+  let committed = false
+  const cleanUp = () => {
+    // If commit was already called, ignore the clean up even if a cancel was requested
+    // This minimizes the chances of leaving the deps cache in a corrupted state
+    if (!cleaned && !committed) {
+      cleaned = true
+      // No need to wait, we can clean up in the background because temp folders
+      // are unique per run
+      debug?.(colors.green(`removing cache dir ${processingCacheDir}`))
+      try {
+        // When exiting the process, `fsp.rm` may not take effect, so we use `fs.rmSync`
+        fs.rmSync(processingCacheDir, { recursive: true, force: true })
+      } catch (error) {
+        // Ignore errors
+      }
+    }
+  }
+
+  const successfulResult: DepOptimizationResult = {
+    metadata,
+    cancel: cleanUp,
+    commit: async () => {
+      if (cleaned) {
+        throw new Error(
+          'Can not commit a Deps Optimization run as it was cancelled',
+        )
+      }
+      // Ignore clean up requests after this point so the temp folder isn't deleted before
+      // we finish committing the new deps cache files to the deps folder
+      committed = true
+
+      // Write metadata file, then commit the processing folder to the global deps cache
+      // Rewire the file paths from the temporary processing dir to the final deps cache dir
+      const dataPath = path.join(processingCacheDir, METADATA_FILENAME)
+      debug?.(
+        colors.green(`creating ${METADATA_FILENAME} in ${processingCacheDir}`),
+      )
+      fs.writeFileSync(
+        dataPath,
+        stringifyDepsOptimizerMetadata(metadata, depsCacheDir),
+      )
+
+      // In order to minimize the time where the deps folder isn't in a consistent state,
+      // we first rename the old depsCacheDir to a temporary path, then we rename the
+      // new processing cache dir to the depsCacheDir. In systems where doing so in sync
+      // is safe, we do an atomic operation (at least for this thread). For Windows, we
+      // found there are cases where the rename operation may finish before it's done
+      // so we do a graceful rename checking that the folder has been properly renamed.
+      // We found that the rename-rename (then delete the old folder in the background)
+      // is safer than a delete-rename operation.
+      const temporaryPath = depsCacheDir + getTempSuffix()
+      const depsCacheDirPresent = fs.existsSync(depsCacheDir)
+      if (isWindows) {
+        if (depsCacheDirPresent) {
+          debug?.(colors.green(`renaming ${depsCacheDir} to ${temporaryPath}`))
+          await safeRename(depsCacheDir, temporaryPath)
+        }
+        debug?.(
+          colors.green(`renaming ${processingCacheDir} to ${depsCacheDir}`),
+        )
+        await safeRename(processingCacheDir, depsCacheDir)
+      } else {
+        if (depsCacheDirPresent) {
+          debug?.(colors.green(`renaming ${depsCacheDir} to ${temporaryPath}`))
+          fs.renameSync(depsCacheDir, temporaryPath)
+        }
+        debug?.(
+          colors.green(`renaming ${processingCacheDir} to ${depsCacheDir}`),
+        )
+        fs.renameSync(processingCacheDir, depsCacheDir)
+      }
+
+      // Delete temporary path in the background
+      if (depsCacheDirPresent) {
+        debug?.(colors.green(`removing cache temp dir ${temporaryPath}`))
+        fsp.rm(temporaryPath, { recursive: true, force: true })
+      }
+    },
+  }
+
+  if (!qualifiedIds.length) {
+    // No deps to optimize, we still commit the processing cache dir to remove
+    // the previous optimized deps if they exist, and let the next server start
+    // skip the scanner step if the lockfile hasn't changed
+    return {
+      cancel: async () => cleanUp(),
+      result: Promise.resolve(successfulResult),
+    }
+  }
+
+  const cancelledResult: DepOptimizationResult = {
+    metadata,
+    commit: async () => cleanUp(),
+    cancel: cleanUp,
+  }
+
+  const start = performance.now()
+
+  const preparedRun = prepareEsbuildOptimizerRun(
+    resolvedConfig,
+    depsInfo,
+    ssr,
+    processingCacheDir,
+    optimizerContext,
+  )
+
+  const runResult = preparedRun.then(({ context, idToExports }) => {
+    function disposeContext() {
+      return context?.dispose().catch((e) => {
+        config.logger.error('Failed to dispose esbuild context', { error: e })
+      })
+    }
+    if (!context || optimizerContext.cancelled) {
+      disposeContext()
+      return cancelledResult
+    }
+
+    return context
+      .rebuild()
+      .then((result) => {
+        const meta = result.metafile!
+
+        // the paths in `meta.outputs` are relative to `process.cwd()`
+        const processingCacheDirOutputPath = path.relative(
+          process.cwd(),
+          processingCacheDir,
+        )
+
+        for (const id in depsInfo) {
+          const output = esbuildOutputFromId(
+            meta.outputs,
+            id,
+            processingCacheDir,
+          )
+
+          const { exportsData, ...info } = depsInfo[id]
+          addOptimizedDepInfo(metadata, 'optimized', {
+            ...info,
+            // We only need to hash the output.imports in to check for stability, but adding the hash
+            // and file path gives us a unique hash that may be useful for other things in the future
+            fileHash: getHash(
+              metadata.hash +
+                depsInfo[id].file +
+                JSON.stringify(output.imports),
+            ),
+            browserHash: metadata.browserHash,
+            // After bundling we have more information and can warn the user about legacy packages
+            // that require manual configuration
+            needsInterop: needsInterop(
+              config,
+              ssr,
+              id,
+              idToExports[id],
+              output,
+            ),
+          })
+        }
+
+        for (const o of Object.keys(meta.outputs)) {
+          if (!jsMapExtensionRE.test(o)) {
+            const id = path
+              .relative(processingCacheDirOutputPath, o)
+              .replace(jsExtensionRE, '')
+            const file = getOptimizedDepPath(id, resolvedConfig, ssr)
+            if (
+              !findOptimizedDepInfoInRecord(
+                metadata.optimized,
+                (depInfo) => depInfo.file === file,
+              )
+            ) {
+              addOptimizedDepInfo(metadata, 'chunks', {
+                id,
+                file,
+                needsInterop: false,
+                browserHash: metadata.browserHash,
+              })
+            }
+          }
+        }
+
+        debug?.(
+          `Dependencies bundled in ${(performance.now() - start).toFixed(2)}ms`,
+        )
+
+        return successfulResult
+      })
+
+      .catch((e) => {
+        if (e.errors && e.message.includes('The build was canceled')) {
+          // esbuild logs an error when cancelling, but this is expected so
+          // return an empty result instead
+          return cancelledResult
+        }
+        throw e
+      })
+      .finally(() => {
+        return disposeContext()
+      })
+  })
+
+  runResult.catch(() => {
+    cleanUp()
+  })
+
+  return {
+    async cancel() {
+      optimizerContext.cancelled = true
+      const { context } = await preparedRun
+      await context?.cancel()
+      cleanUp()
+    },
+    result: runResult,
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/optimizer/optimizer.ts b/packages/vite/src/node/optimizer/optimizer.ts
index 3f76e480a..046df3009 100644
--- a/packages/vite/src/node/optimizer/optimizer.ts
+++ b/packages/vite/src/node/optimizer/optimizer.ts
@@ -1,25 +1,29 @@
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { loadCachedDepOptimizationMetadata } from 'packages/vite/src/node/optimizer/index/loadCachedDepOptimizationMetadata';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { DepOptimizationResult } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { initDepsOptimizerMetadata } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { addOptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { runOptimizeDeps } from 'packages/vite/src/node/optimizer/index/runOptimizeDeps';
+import { OptimizedDepInfo } from 'packages/vite/src/node/optimizer/index/prepareEsbuildOptimizerRun';
+import { addManuallyIncludedOptimizeDeps } from 'packages/vite/src/node/optimizer/index/addManuallyIncludedOptimizeDeps';
+import { extractExportsData } from 'packages/vite/src/node/optimizer/index/extractExportsData';
 import colors from 'picocolors'
 import { createDebugger, getHash, promiseWithResolvers } from '../utils'
 import type { PromiseWithResolvers } from '../utils'
 import { getDepOptimizationConfig } from '../config'
 import type { ResolvedConfig, ViteDevServer } from '..'
 import {
-  addManuallyIncludedOptimizeDeps,
-  addOptimizedDepInfo,
+  ,
   createIsOptimizedDepFile,
   createIsOptimizedDepUrl,
   depsFromOptimizedDepInfo,
   depsLogString,
   discoverProjectDependencies,
-  extractExportsData,
   getOptimizedDepPath,
-  initDepsOptimizerMetadata,
-  loadCachedDepOptimizationMetadata,
   optimizeServerSsrDeps,
-  runOptimizeDeps,
   toDiscoveredDependencies,
 } from '.'
-import type { DepOptimizationResult, DepsOptimizer, OptimizedDepInfo } from '.'
 
 const debug = createDebugger('vite:deps')
 
diff --git a/packages/vite/src/node/optimizer/resolve.ts b/packages/vite/src/node/optimizer/resolve.ts
index 822b19e18..5e2041a30 100644
--- a/packages/vite/src/node/optimizer/resolve.ts
+++ b/packages/vite/src/node/optimizer/resolve.ts
@@ -1,7 +1,7 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import path from 'node:path'
 import glob from 'fast-glob'
 import micromatch from 'micromatch'
-import type { ResolvedConfig } from '../config'
 import { escapeRegex, getNpmPackageName } from '../utils'
 import { resolvePackageData } from '../packages'
 import { slash } from '../../shared/utils'
diff --git a/packages/vite/src/node/plugin.ts b/packages/vite/src/node/plugin.ts
index 8ef2f2281..2240dd95d 100644
--- a/packages/vite/src/node/plugin.ts
+++ b/packages/vite/src/node/plugin.ts
@@ -1,3 +1,10 @@
+import { UserConfig } from 'packages/vite/src/node/config/UserConfig';
+import { ConfigEnv } from 'packages/vite/src/node/config/resolveConfig';
+import { UserConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ConfigEnv } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { UserConfig } from 'packages/vite/src/node/config/loadConfigFromFile';
+import { HmrContext } from 'packages/vite/src/node/server/hmr/handleHMRUpdate';
 import type {
   CustomPluginOptions,
   LoadResult,
@@ -9,11 +16,9 @@ import type {
   TransformResult,
 } from 'rollup'
 export type { PluginContext } from 'rollup'
-import type { ConfigEnv, ResolvedConfig, UserConfig } from './config'
 import type { ServerHook } from './server'
 import type { IndexHtmlTransform } from './plugins/html'
 import type { ModuleNode } from './server/moduleGraph'
-import type { HmrContext } from './server/hmr'
 import type { PreviewServerHook } from './preview'
 
 /**
diff --git a/packages/vite/src/node/plugins/asset.ts b/packages/vite/src/node/plugins/asset.ts
index 1415211d5..0e4221cf0 100644
--- a/packages/vite/src/node/plugins/asset.ts
+++ b/packages/vite/src/node/plugins/asset.ts
@@ -1,3 +1,4 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import path from 'node:path'
 import { parse as parseUrl } from 'node:url'
 import fsp from 'node:fs/promises'
@@ -15,7 +16,6 @@ import {
   toOutputFilePathInJS,
 } from '../build'
 import type { Plugin } from '../plugin'
-import type { ResolvedConfig } from '../config'
 import { checkPublicFile } from '../publicDir'
 import {
   encodeURIPath,
diff --git a/packages/vite/src/node/plugins/assetImportMetaUrl.ts b/packages/vite/src/node/plugins/assetImportMetaUrl.ts
index 588f6e08b..924658276 100644
--- a/packages/vite/src/node/plugins/assetImportMetaUrl.ts
+++ b/packages/vite/src/node/plugins/assetImportMetaUrl.ts
@@ -1,16 +1,21 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { tryFsResolve } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { tryFsResolve } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
 import path from 'node:path'
 import MagicString from 'magic-string'
 import { stripLiteral } from 'strip-literal'
 import type { Plugin } from '../plugin'
-import type { ResolvedConfig } from '../config'
 import type { ResolveFn } from '../'
 import { injectQuery, isParentDirectory, transformStableResult } from '../utils'
 import { CLIENT_ENTRY } from '../constants'
 import { slash } from '../../shared/utils'
 import { fileToUrl } from './asset'
 import { preloadHelperId } from './importAnalysisBuild'
-import type { InternalResolveOptions } from './resolve'
-import { tryFsResolve } from './resolve'
 import { hasViteIgnoreRE } from './importAnalysis'
 
 /**
diff --git a/packages/vite/src/node/plugins/clientInjections.ts b/packages/vite/src/node/plugins/clientInjections.ts
index c66f3877e..accf28907 100644
--- a/packages/vite/src/node/plugins/clientInjections.ts
+++ b/packages/vite/src/node/plugins/clientInjections.ts
@@ -1,6 +1,6 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import path from 'node:path'
 import type { Plugin } from '../plugin'
-import type { ResolvedConfig } from '../config'
 import { CLIENT_ENTRY, ENV_ENTRY } from '../constants'
 import { isObject, normalizePath, resolveHostname } from '../utils'
 import { replaceDefine, serializeDefine } from './define'
diff --git a/packages/vite/src/node/plugins/css.ts b/packages/vite/src/node/plugins/css.ts
index 26ba17c19..9d7570f37 100644
--- a/packages/vite/src/node/plugins/css.ts
+++ b/packages/vite/src/node/plugins/css.ts
@@ -1,3 +1,135 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { commonjsProxyRE } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { cssModuleRE } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isModuleCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { cssModulesCache } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { removedPureCssFilesCache } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { cssPlugin } from 'packages/vite/src/node/plugins/css';
+import { cssModuleRE } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { commonjsProxyRE } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { styleAttrRE } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { transformOnlyRE } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { cssBundleName } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { directRequestRE } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isDirectCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { cssUrlAssetRE } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { cssPostPlugin } from 'packages/vite/src/node/plugins/css';
+import { commonjsProxyRE } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { cssAnalysisPlugin } from 'packages/vite/src/node/plugins/css';
+import { PreprocessLang } from 'packages/vite/src/node/plugins/css/compileCSSPreprocessors';
+import { compileCSSPreprocessors } from 'packages/vite/src/node/plugins/css/compileCSSPreprocessors';
+import { compileCSSPreprocessors } from 'packages/vite/src/node/plugins/css';
+import { cssModuleRE } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { PreprocessLang } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { PostCssDialectLang } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { CssLang } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { getCssResolversKeys } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { compileCSSPreprocessors } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { getAtImportResolvers } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { compileCSS } from 'packages/vite/src/node/plugins/css/compileCSS';
+import { compileCSS } from 'packages/vite/src/node/plugins/css';
+import { decoder } from 'packages/vite/src/node/plugins/css/minifyCSS';
+import { cssBundleName } from 'packages/vite/src/node/plugins/css/minifyCSS';
+import { minifyCSS } from 'packages/vite/src/node/plugins/css/minifyCSS';
+import { minifyCSS } from 'packages/vite/src/node/plugins/css';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/makeScssWorker';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/makeScssWorker';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeScssWorker';
+import { SassStylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeScssWorker';
+import { cleanScssBugUrl } from 'packages/vite/src/node/plugins/css/makeScssWorker';
+import { fixScssBugImportValue } from 'packages/vite/src/node/plugins/css/makeScssWorker';
+import { makeScssWorker } from 'packages/vite/src/node/plugins/css/makeScssWorker';
+import { makeScssWorker } from 'packages/vite/src/node/plugins/css';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/makeModernScssWorker';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/makeModernScssWorker';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeModernScssWorker';
+import { SassStylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeModernScssWorker';
+import { cleanScssBugUrl } from 'packages/vite/src/node/plugins/css/makeModernScssWorker';
+import { makeModernScssWorker } from 'packages/vite/src/node/plugins/css/makeModernScssWorker';
+import { makeModernScssWorker } from 'packages/vite/src/node/plugins/css';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/makeModernCompilerScssWorker';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/makeModernCompilerScssWorker';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeModernCompilerScssWorker';
+import { SassStylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeModernCompilerScssWorker';
+import { cleanScssBugUrl } from 'packages/vite/src/node/plugins/css/makeModernCompilerScssWorker';
+import { makeModernScssWorker } from 'packages/vite/src/node/plugins/css/makeModernCompilerScssWorker';
+import { makeModernCompilerScssWorker } from 'packages/vite/src/node/plugins/css/makeModernCompilerScssWorker';
+import { makeModernCompilerScssWorker } from 'packages/vite/src/node/plugins/css';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { SassStylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { StylePreprocessorResults } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { SassStylePreprocessor } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { cleanScssBugUrl } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { makeScssWorker } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { makeModernScssWorker } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { makeModernCompilerScssWorker } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { scssProcessor } from 'packages/vite/src/node/plugins/css/scssProcessor';
+import { scssProcessor } from 'packages/vite/src/node/plugins/css';
+import { cssUrlRE } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { cssDataUriRE } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { importCssRE } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { CssUrlReplacer } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { rewriteCssUrls } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { rewriteCssDataUris } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { rewriteImportCss } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { rebaseUrls } from 'packages/vite/src/node/plugins/css/rebaseUrls';
+import { rebaseUrls } from 'packages/vite/src/node/plugins/css';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { cssUrlRE } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { cssDataUriRE } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { importCssRE } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { CssUrlReplacer } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { rewriteCssUrls } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { rebaseUrls } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { makeLessWorker } from 'packages/vite/src/node/plugins/css/makeLessWorker';
+import { makeLessWorker } from 'packages/vite/src/node/plugins/css';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { StylePreprocessorResults } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { StylePreprocessor } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { cssUrlRE } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { cssDataUriRE } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { importCssRE } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { CssUrlReplacer } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { rewriteCssUrls } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { rebaseUrls } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { makeLessWorker } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { lessProcessor } from 'packages/vite/src/node/plugins/css/lessProcessor';
+import { lessProcessor } from 'packages/vite/src/node/plugins/css';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/makeStylWorker';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeStylWorker';
+import { StylusStylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/makeStylWorker';
+import { makeStylWorker } from 'packages/vite/src/node/plugins/css/makeStylWorker';
+import { makeStylWorker } from 'packages/vite/src/node/plugins/css';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { PreprocessorAdditionalData } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { StylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { StylusStylePreprocessorOptions } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { StylePreprocessorResults } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { StylusStylePreprocessor } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { makeStylWorker } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { stylProcessor } from 'packages/vite/src/node/plugins/css/stylProcessor';
+import { stylProcessor } from 'packages/vite/src/node/plugins/css';
+import { decoder } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { cssModuleRE } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { styleAttrRE } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { PreprocessLang } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { PostCssDialectLang } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { CSSAtImportResolvers } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { getAtImportResolvers } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { compileCSS } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { CssUrlReplacer } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { skipUrlReplacer } from 'packages/vite/src/node/plugins/css/compileLightningCSS';
+import { compileLightningCSS } from 'packages/vite/src/node/plugins/css';
 import fs from 'node:fs'
 import fsp from 'node:fs/promises'
 import path from 'node:path'
@@ -42,7 +174,6 @@ import {
   ESBUILD_MODULES_TARGET,
   SPECIAL_QUERY_RE,
 } from '../constants'
-import type { ResolvedConfig } from '../config'
 import type { Plugin } from '../plugin'
 import { checkPublicFile } from '../publicDir'
 import {
@@ -84,8 +215,6 @@ import {
 } from './asset'
 import type { ESBuildOptions } from './esbuild'
 import { getChunkOriginalFileName } from './manifest'
-
-const decoder = new TextDecoder()
 // const debug = createDebugger('vite:css')
 
 export interface CSSOptions {
@@ -185,61 +314,21 @@ export function resolveCSSOptions(
   }
   return { ...options, lightningcss: undefined }
 }
-
-const cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`)
-const directRequestRE = /[?&]direct\b/
 const htmlProxyRE = /[?&]html-proxy\b/
 const htmlProxyIndexRE = /&index=(\d+)/
-const commonjsProxyRE = /\?commonjs-proxy/
 const inlineRE = /[?&]inline\b/
 const inlineCSSRE = /[?&]inline-css\b/
-const styleAttrRE = /[?&]style-attr\b/
-const functionCallRE = /^[A-Z_][\w-]*\(/i
-const transformOnlyRE = /[?&]transform-only\b/
 const nonEscapedDoubleQuoteRe = /(?<!\\)"/g
 
-const cssBundleName = 'style.css'
-
-const enum PreprocessLang {
-  less = 'less',
-  sass = 'sass',
-  scss = 'scss',
-  styl = 'styl',
-  stylus = 'stylus',
-}
-const enum PureCssLang {
-  css = 'css',
-}
-const enum PostCssDialectLang {
-  sss = 'sugarss',
-}
-type CssLang =
-  | keyof typeof PureCssLang
-  | keyof typeof PreprocessLang
-  | keyof typeof PostCssDialectLang
-
-export const isCSSRequest = (request: string): boolean =>
-  CSS_LANGS_RE.test(request)
+export 
 
-export const isModuleCSSRequest = (request: string): boolean =>
-  cssModuleRE.test(request)
+export 
 
-export const isDirectCSSRequest = (request: string): boolean =>
-  CSS_LANGS_RE.test(request) && directRequestRE.test(request)
+export 
 
 export const isDirectRequest = (request: string): boolean =>
   directRequestRE.test(request)
 
-const cssModulesCache = new WeakMap<
-  ResolvedConfig,
-  Map<string, Record<string, string>>
->()
-
-export const removedPureCssFilesCache = new WeakMap<
-  ResolvedConfig,
-  Map<string, RenderedChunk>
->()
-
 const postcssConfigCache = new WeakMap<
   ResolvedConfig,
   PostCSSConfigResult | null | Promise<PostCSSConfigResult | null>
@@ -249,784 +338,6 @@ function encodePublicUrlsInCSS(config: ResolvedConfig) {
   return config.command === 'build'
 }
 
-const cssUrlAssetRE = /__VITE_CSS_URL__([\da-f]+)__/g
-
-/**
- * Plugin applied before user plugins
- */
-export function cssPlugin(config: ResolvedConfig): Plugin {
-  const isBuild = config.command === 'build'
-  let moduleCache: Map<string, Record<string, string>>
-
-  const resolveUrl = config.createResolver({
-    preferRelative: true,
-    tryIndex: false,
-    extensions: [],
-  })
-
-  let preprocessorWorkerController: PreprocessorWorkerController | undefined
-
-  // warm up cache for resolved postcss config
-  if (config.css?.transformer !== 'lightningcss') {
-    resolvePostcssConfig(config)
-  }
-
-  return {
-    name: 'vite:css',
-
-    buildStart() {
-      // Ensure a new cache for every build (i.e. rebuilding in watch mode)
-      moduleCache = new Map<string, Record<string, string>>()
-      cssModulesCache.set(config, moduleCache)
-
-      removedPureCssFilesCache.set(config, new Map<string, RenderedChunk>())
-
-      preprocessorWorkerController = createPreprocessorWorkerController(
-        normalizeMaxWorkers(config.css.preprocessorMaxWorkers),
-      )
-      preprocessorWorkerControllerCache.set(
-        config,
-        preprocessorWorkerController,
-      )
-    },
-
-    buildEnd() {
-      preprocessorWorkerController?.close()
-    },
-
-    async load(id) {
-      if (!isCSSRequest(id)) return
-
-      if (urlRE.test(id)) {
-        if (isModuleCSSRequest(id)) {
-          throw new Error(
-            `?url is not supported with CSS modules. (tried to import ${JSON.stringify(
-              id,
-            )})`,
-          )
-        }
-
-        // *.css?url
-        // in dev, it's handled by assets plugin.
-        if (isBuild) {
-          id = injectQuery(removeUrlQuery(id), 'transform-only')
-          return (
-            `import ${JSON.stringify(id)};` +
-            `export default "__VITE_CSS_URL__${Buffer.from(id).toString(
-              'hex',
-            )}__"`
-          )
-        }
-      }
-    },
-
-    async transform(raw, id) {
-      if (
-        !isCSSRequest(id) ||
-        commonjsProxyRE.test(id) ||
-        SPECIAL_QUERY_RE.test(id)
-      ) {
-        return
-      }
-      const urlReplacer: CssUrlReplacer = async (url, importer) => {
-        const decodedUrl = decodeURI(url)
-        if (checkPublicFile(decodedUrl, config)) {
-          if (encodePublicUrlsInCSS(config)) {
-            return publicFileToBuiltUrl(decodedUrl, config)
-          } else {
-            return joinUrlSegments(config.base, decodedUrl)
-          }
-        }
-        const [id, fragment] = decodedUrl.split('#')
-        let resolved = await resolveUrl(id, importer)
-        if (resolved) {
-          if (fragment) resolved += '#' + fragment
-          return fileToUrl(resolved, config, this)
-        }
-        if (config.command === 'build') {
-          const isExternal = config.build.rollupOptions.external
-            ? resolveUserExternal(
-                config.build.rollupOptions.external,
-                decodedUrl, // use URL as id since id could not be resolved
-                id,
-                false,
-              )
-            : false
-
-          if (!isExternal) {
-            // #9800 If we cannot resolve the css url, leave a warning.
-            config.logger.warnOnce(
-              `\n${decodedUrl} referenced in ${id} didn't resolve at build time, it will remain unchanged to be resolved at runtime`,
-            )
-          }
-        }
-        return url
-      }
-
-      const {
-        code: css,
-        modules,
-        deps,
-        map,
-      } = await compileCSS(
-        id,
-        raw,
-        config,
-        preprocessorWorkerController!,
-        urlReplacer,
-      )
-      if (modules) {
-        moduleCache.set(id, modules)
-      }
-
-      if (deps) {
-        for (const file of deps) {
-          this.addWatchFile(file)
-        }
-      }
-
-      return {
-        code: css,
-        map,
-      }
-    },
-  }
-}
-
-/**
- * Plugin applied after user plugins
- */
-export function cssPostPlugin(config: ResolvedConfig): Plugin {
-  // styles initialization in buildStart causes a styling loss in watch
-  const styles: Map<string, string> = new Map<string, string>()
-  // queue to emit css serially to guarantee the files are emitted in a deterministic order
-  let codeSplitEmitQueue = createSerialPromiseQueue<string>()
-  const urlEmitQueue = createSerialPromiseQueue<unknown>()
-  let pureCssChunks: Set<RenderedChunk>
-
-  // when there are multiple rollup outputs and extracting CSS, only emit once,
-  // since output formats have no effect on the generated CSS.
-  let hasEmitted = false
-  let chunkCSSMap: Map<string, string>
-
-  const rollupOptionsOutput = config.build.rollupOptions.output
-  const assetFileNames = (
-    Array.isArray(rollupOptionsOutput)
-      ? rollupOptionsOutput[0]
-      : rollupOptionsOutput
-  )?.assetFileNames
-  const getCssAssetDirname = (cssAssetName: string) => {
-    const cssAssetNameDir = path.dirname(cssAssetName)
-    if (!assetFileNames) {
-      return path.join(config.build.assetsDir, cssAssetNameDir)
-    } else if (typeof assetFileNames === 'string') {
-      return path.join(path.dirname(assetFileNames), cssAssetNameDir)
-    } else {
-      return path.dirname(
-        assetFileNames({
-          name: cssAssetName,
-          type: 'asset',
-          source: '/* vite internal call, ignore */',
-        }),
-      )
-    }
-  }
-
-  return {
-    name: 'vite:css-post',
-
-    renderStart() {
-      // Ensure new caches for every build (i.e. rebuilding in watch mode)
-      pureCssChunks = new Set<RenderedChunk>()
-      hasEmitted = false
-      chunkCSSMap = new Map()
-      codeSplitEmitQueue = createSerialPromiseQueue()
-    },
-
-    async transform(css, id, options) {
-      if (
-        !isCSSRequest(id) ||
-        commonjsProxyRE.test(id) ||
-        SPECIAL_QUERY_RE.test(id)
-      ) {
-        return
-      }
-
-      css = stripBomTag(css)
-
-      // cache css compile result to map
-      // and then use the cache replace inline-style-flag
-      // when `generateBundle` in vite:build-html plugin and devHtmlHook
-      const inlineCSS = inlineCSSRE.test(id)
-      const isHTMLProxy = htmlProxyRE.test(id)
-      if (inlineCSS && isHTMLProxy) {
-        if (styleAttrRE.test(id)) {
-          css = css.replace(/"/g, '&quot;')
-        }
-        const index = htmlProxyIndexRE.exec(id)?.[1]
-        if (index == null) {
-          throw new Error(`HTML proxy index in "${id}" not found`)
-        }
-        addToHTMLProxyTransformResult(
-          `${getHash(cleanUrl(id))}_${Number.parseInt(index)}`,
-          css,
-        )
-        return `export default ''`
-      }
-
-      const inlined = inlineRE.test(id)
-      const modules = cssModulesCache.get(config)!.get(id)
-
-      // #6984, #7552
-      // `foo.module.css` => modulesCode
-      // `foo.module.css?inline` => cssContent
-      const modulesCode =
-        modules &&
-        !inlined &&
-        dataToEsm(modules, { namedExports: true, preferConst: true })
-
-      if (config.command === 'serve') {
-        const getContentWithSourcemap = async (content: string) => {
-          if (config.css?.devSourcemap) {
-            const sourcemap = this.getCombinedSourcemap()
-            if (sourcemap.mappings) {
-              await injectSourcesContent(sourcemap, cleanUrl(id), config.logger)
-            }
-            return getCodeWithSourcemap('css', content, sourcemap)
-          }
-          return content
-        }
-
-        if (isDirectCSSRequest(id)) {
-          return null
-        }
-        // server only
-        if (options?.ssr) {
-          return modulesCode || `export default ${JSON.stringify(css)}`
-        }
-        if (inlined) {
-          return `export default ${JSON.stringify(css)}`
-        }
-
-        const cssContent = await getContentWithSourcemap(css)
-        const code = [
-          `import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(
-            path.posix.join(config.base, CLIENT_PUBLIC_PATH),
-          )}`,
-          `const __vite__id = ${JSON.stringify(id)}`,
-          `const __vite__css = ${JSON.stringify(cssContent)}`,
-          `__vite__updateStyle(__vite__id, __vite__css)`,
-          // css modules exports change on edit so it can't self accept
-          `${modulesCode || 'import.meta.hot.accept()'}`,
-          `import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`,
-        ].join('\n')
-        return { code, map: { mappings: '' } }
-      }
-
-      // build CSS handling ----------------------------------------------------
-
-      // record css
-      if (!inlined) {
-        styles.set(id, css)
-      }
-
-      let code: string
-      if (modulesCode) {
-        code = modulesCode
-      } else if (inlined) {
-        let content = css
-        if (config.build.cssMinify) {
-          content = await minifyCSS(content, config, true)
-        }
-        code = `export default ${JSON.stringify(content)}`
-      } else {
-        // empty module when it's not a CSS module nor `?inline`
-        code = ''
-      }
-
-      return {
-        code,
-        map: { mappings: '' },
-        // avoid the css module from being tree-shaken so that we can retrieve
-        // it in renderChunk()
-        moduleSideEffects: modulesCode || inlined ? false : 'no-treeshake',
-      }
-    },
-
-    async renderChunk(code, chunk, opts) {
-      let chunkCSS = ''
-      // the chunk is empty if it's a dynamic entry chunk that only contains a CSS import
-      const isJsChunkEmpty = code === '' && !chunk.isEntry
-      let isPureCssChunk = true
-      const ids = Object.keys(chunk.modules)
-      for (const id of ids) {
-        if (styles.has(id)) {
-          // ?transform-only is used for ?url and shouldn't be included in normal CSS chunks
-          if (!transformOnlyRE.test(id)) {
-            chunkCSS += styles.get(id)
-            // a css module contains JS, so it makes this not a pure css chunk
-            if (cssModuleRE.test(id)) {
-              isPureCssChunk = false
-            }
-          }
-        } else if (!isJsChunkEmpty) {
-          // if the module does not have a style, then it's not a pure css chunk.
-          // this is true because in the `transform` hook above, only modules
-          // that are css gets added to the `styles` map.
-          isPureCssChunk = false
-        }
-      }
-
-      const publicAssetUrlMap = publicAssetUrlCache.get(config)!
-
-      // resolve asset URL placeholders to their built file URLs
-      const resolveAssetUrlsInCss = (
-        chunkCSS: string,
-        cssAssetName: string,
-      ) => {
-        const encodedPublicUrls = encodePublicUrlsInCSS(config)
-
-        const relative = config.base === './' || config.base === ''
-        const cssAssetDirname =
-          encodedPublicUrls || relative
-            ? slash(getCssAssetDirname(cssAssetName))
-            : undefined
-
-        const toRelative = (filename: string) => {
-          // relative base + extracted CSS
-          const relativePath = path.posix.relative(cssAssetDirname!, filename)
-          return relativePath[0] === '.' ? relativePath : './' + relativePath
-        }
-
-        // replace asset url references with resolved url.
-        chunkCSS = chunkCSS.replace(assetUrlRE, (_, fileHash, postfix = '') => {
-          const filename = this.getFileName(fileHash) + postfix
-          chunk.viteMetadata!.importedAssets.add(cleanUrl(filename))
-          return encodeURIPath(
-            toOutputFilePathInCss(
-              filename,
-              'asset',
-              cssAssetName,
-              'css',
-              config,
-              toRelative,
-            ),
-          )
-        })
-        // resolve public URL from CSS paths
-        if (encodedPublicUrls) {
-          const relativePathToPublicFromCSS = path.posix.relative(
-            cssAssetDirname!,
-            '',
-          )
-          chunkCSS = chunkCSS.replace(publicAssetUrlRE, (_, hash) => {
-            const publicUrl = publicAssetUrlMap.get(hash)!.slice(1)
-            return encodeURIPath(
-              toOutputFilePathInCss(
-                publicUrl,
-                'public',
-                cssAssetName,
-                'css',
-                config,
-                () => `${relativePathToPublicFromCSS}/${publicUrl}`,
-              ),
-            )
-          })
-        }
-        return chunkCSS
-      }
-
-      function ensureFileExt(name: string, ext: string) {
-        return normalizePath(
-          path.format({ ...path.parse(name), base: undefined, ext }),
-        )
-      }
-
-      let s: MagicString | undefined
-      const urlEmitTasks: Array<{
-        cssAssetName: string
-        originalFilename: string
-        content: string
-        start: number
-        end: number
-      }> = []
-
-      if (code.includes('__VITE_CSS_URL__')) {
-        let match: RegExpExecArray | null
-        cssUrlAssetRE.lastIndex = 0
-        while ((match = cssUrlAssetRE.exec(code))) {
-          const [full, idHex] = match
-          const id = Buffer.from(idHex, 'hex').toString()
-          const originalFilename = cleanUrl(id)
-          const cssAssetName = ensureFileExt(
-            path.basename(originalFilename),
-            '.css',
-          )
-          if (!styles.has(id)) {
-            throw new Error(
-              `css content for ${JSON.stringify(id)} was not found`,
-            )
-          }
-
-          let cssContent = styles.get(id)!
-
-          cssContent = resolveAssetUrlsInCss(cssContent, cssAssetName)
-
-          urlEmitTasks.push({
-            cssAssetName,
-            originalFilename,
-            content: cssContent,
-            start: match.index,
-            end: match.index + full.length,
-          })
-        }
-      }
-
-      // should await even if this chunk does not include __VITE_CSS_URL__
-      // so that code after this line runs in the same order
-      await urlEmitQueue.run(async () =>
-        Promise.all(
-          urlEmitTasks.map(async (info) => {
-            info.content = await finalizeCss(info.content, true, config)
-          }),
-        ),
-      )
-      if (urlEmitTasks.length > 0) {
-        const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(
-          opts.format,
-          config.isWorker,
-        )
-        s ||= new MagicString(code)
-
-        for (const {
-          cssAssetName,
-          originalFilename,
-          content,
-          start,
-          end,
-        } of urlEmitTasks) {
-          const referenceId = this.emitFile({
-            name: cssAssetName,
-            type: 'asset',
-            source: content,
-          })
-          generatedAssets
-            .get(config)!
-            .set(referenceId, { originalName: originalFilename })
-
-          const filename = this.getFileName(referenceId)
-          chunk.viteMetadata!.importedAssets.add(cleanUrl(filename))
-          const replacement = toOutputFilePathInJS(
-            filename,
-            'asset',
-            chunk.fileName,
-            'js',
-            config,
-            toRelativeRuntime,
-          )
-          const replacementString =
-            typeof replacement === 'string'
-              ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1)
-              : `"+${replacement.runtime}+"`
-          s.update(start, end, replacementString)
-        }
-      }
-
-      if (chunkCSS) {
-        if (isPureCssChunk && (opts.format === 'es' || opts.format === 'cjs')) {
-          // this is a shared CSS-only chunk that is empty.
-          pureCssChunks.add(chunk)
-        }
-
-        if (config.build.cssCodeSplit) {
-          if (opts.format === 'es' || opts.format === 'cjs') {
-            const isEntry = chunk.isEntry && isPureCssChunk
-            const cssFullAssetName = ensureFileExt(chunk.name, '.css')
-            // if facadeModuleId doesn't exist or doesn't have a CSS extension,
-            // that means a JS entry file imports a CSS file.
-            // in this case, only use the filename for the CSS chunk name like JS chunks.
-            const cssAssetName =
-              chunk.isEntry &&
-              (!chunk.facadeModuleId || !isCSSRequest(chunk.facadeModuleId))
-                ? path.basename(cssFullAssetName)
-                : cssFullAssetName
-            const originalFilename = getChunkOriginalFileName(
-              chunk,
-              config.root,
-              opts.format,
-            )
-
-            chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssAssetName)
-
-            // wait for previous tasks as well
-            chunkCSS = await codeSplitEmitQueue.run(async () => {
-              return finalizeCss(chunkCSS, true, config)
-            })
-
-            // emit corresponding css file
-            const referenceId = this.emitFile({
-              name: cssAssetName,
-              type: 'asset',
-              source: chunkCSS,
-            })
-            generatedAssets
-              .get(config)!
-              .set(referenceId, { originalName: originalFilename, isEntry })
-            chunk.viteMetadata!.importedCss.add(this.getFileName(referenceId))
-          } else if (!config.build.ssr) {
-            // legacy build and inline css
-
-            // Entry chunk CSS will be collected into `chunk.viteMetadata.importedCss`
-            // and injected later by the `'vite:build-html'` plugin into the `index.html`
-            // so it will be duplicated. (https://github.com/vitejs/vite/issues/2062#issuecomment-782388010)
-            // But because entry chunk can be imported by dynamic import,
-            // we shouldn't remove the inlined CSS. (#10285)
-
-            chunkCSS = await finalizeCss(chunkCSS, true, config)
-            let cssString = JSON.stringify(chunkCSS)
-            cssString =
-              renderAssetUrlInJS(
-                this,
-                config,
-                chunk,
-                opts,
-                cssString,
-              )?.toString() || cssString
-            const style = `__vite_style__`
-            const injectCode =
-              `var ${style} = document.createElement('style');` +
-              `${style}.textContent = ${cssString};` +
-              `document.head.appendChild(${style});`
-            let injectionPoint
-            const wrapIdx = code.indexOf('System.register')
-            if (wrapIdx >= 0) {
-              const executeFnStart = code.indexOf('execute:', wrapIdx)
-              injectionPoint = code.indexOf('{', executeFnStart) + 1
-            } else {
-              const insertMark = "'use strict';"
-              injectionPoint = code.indexOf(insertMark) + insertMark.length
-            }
-            s ||= new MagicString(code)
-            s.appendRight(injectionPoint, injectCode)
-          }
-        } else {
-          // resolve public URL from CSS paths, we need to use absolute paths
-          chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssBundleName)
-          // finalizeCss is called for the aggregated chunk in generateBundle
-
-          chunkCSSMap.set(chunk.fileName, chunkCSS)
-        }
-      }
-
-      if (s) {
-        if (config.build.sourcemap) {
-          return {
-            code: s.toString(),
-            map: s.generateMap({ hires: 'boundary' }),
-          }
-        } else {
-          return { code: s.toString() }
-        }
-      }
-      return null
-    },
-
-    augmentChunkHash(chunk) {
-      if (chunk.viteMetadata?.importedCss.size) {
-        let hash = ''
-        for (const id of chunk.viteMetadata.importedCss) {
-          hash += id
-        }
-        return hash
-      }
-    },
-
-    async generateBundle(opts, bundle) {
-      // @ts-expect-error asset emits are skipped in legacy bundle
-      if (opts.__vite_skip_asset_emit__) {
-        return
-      }
-
-      function extractCss() {
-        let css = ''
-        const collected = new Set<OutputChunk>()
-        // will be populated in order they are used by entry points
-        const dynamicImports = new Set<string>()
-
-        function collect(chunk: OutputChunk | OutputAsset) {
-          if (!chunk || chunk.type !== 'chunk' || collected.has(chunk)) return
-          collected.add(chunk)
-
-          // First collect all styles from the synchronous imports (lowest priority)
-          chunk.imports.forEach((importName) => collect(bundle[importName]))
-          // Save dynamic imports in deterministic order to add the styles later (to have the highest priority)
-          chunk.dynamicImports.forEach((importName) =>
-            dynamicImports.add(importName),
-          )
-          // Then collect the styles of the current chunk (might overwrite some styles from previous imports)
-          css += chunkCSSMap.get(chunk.preliminaryFileName) ?? ''
-        }
-
-        // The bundle is guaranteed to be deterministic, if not then we have a bug in rollup.
-        // So we use it to ensure a deterministic order of styles
-        for (const chunk of Object.values(bundle)) {
-          if (chunk.type === 'chunk' && chunk.isEntry) {
-            collect(chunk)
-          }
-        }
-        // Now collect the dynamic chunks, this is done last to have the styles overwrite the previous ones
-        for (const chunkName of dynamicImports) {
-          collect(bundle[chunkName])
-        }
-
-        return css
-      }
-      let extractedCss = !hasEmitted && extractCss()
-      if (extractedCss) {
-        hasEmitted = true
-        extractedCss = await finalizeCss(extractedCss, true, config)
-        this.emitFile({
-          name: cssBundleName,
-          type: 'asset',
-          source: extractedCss,
-        })
-      }
-
-      // remove empty css chunks and their imports
-      if (pureCssChunks.size) {
-        // map each pure css chunk (rendered chunk) to it's corresponding bundle
-        // chunk. we check that by `preliminaryFileName` as they have different
-        // `filename`s (rendered chunk has the !~{XXX}~ placeholder)
-        const prelimaryNameToChunkMap = Object.fromEntries(
-          Object.values(bundle)
-            .filter((chunk): chunk is OutputChunk => chunk.type === 'chunk')
-            .map((chunk) => [chunk.preliminaryFileName, chunk.fileName]),
-        )
-
-        // When running in watch mode the generateBundle is called once per output format
-        // in this case the `bundle` is not populated with the other output files
-        // but they are still in `pureCssChunks`.
-        // So we need to filter the names and only use those who are defined
-        const pureCssChunkNames = [...pureCssChunks]
-          .map((pureCssChunk) => prelimaryNameToChunkMap[pureCssChunk.fileName])
-          .filter(Boolean)
-
-        const replaceEmptyChunk = getEmptyChunkReplacer(
-          pureCssChunkNames,
-          opts.format,
-        )
-
-        for (const file in bundle) {
-          const chunk = bundle[file]
-          if (chunk.type === 'chunk') {
-            let chunkImportsPureCssChunk = false
-            // remove pure css chunk from other chunk's imports,
-            // and also register the emitted CSS files under the importer
-            // chunks instead.
-            chunk.imports = chunk.imports.filter((file) => {
-              if (pureCssChunkNames.includes(file)) {
-                const { importedCss, importedAssets } = (
-                  bundle[file] as OutputChunk
-                ).viteMetadata!
-                importedCss.forEach((file) =>
-                  chunk.viteMetadata!.importedCss.add(file),
-                )
-                importedAssets.forEach((file) =>
-                  chunk.viteMetadata!.importedAssets.add(file),
-                )
-                chunkImportsPureCssChunk = true
-                return false
-              }
-              return true
-            })
-            if (chunkImportsPureCssChunk) {
-              chunk.code = replaceEmptyChunk(chunk.code)
-            }
-          }
-        }
-
-        const removedPureCssFiles = removedPureCssFilesCache.get(config)!
-        pureCssChunkNames.forEach((fileName) => {
-          removedPureCssFiles.set(fileName, bundle[fileName] as RenderedChunk)
-          delete bundle[fileName]
-          delete bundle[`${fileName}.map`]
-        })
-      }
-    },
-  }
-}
-
-export function cssAnalysisPlugin(config: ResolvedConfig): Plugin {
-  let server: ViteDevServer
-
-  return {
-    name: 'vite:css-analysis',
-
-    configureServer(_server) {
-      server = _server
-    },
-
-    async transform(_, id, options) {
-      if (
-        !isCSSRequest(id) ||
-        commonjsProxyRE.test(id) ||
-        SPECIAL_QUERY_RE.test(id)
-      ) {
-        return
-      }
-
-      const ssr = options?.ssr === true
-      const { moduleGraph } = server
-      const thisModule = moduleGraph.getModuleById(id)
-
-      // Handle CSS @import dependency HMR and other added modules via this.addWatchFile.
-      // JS-related HMR is handled in the import-analysis plugin.
-      if (thisModule) {
-        // CSS modules cannot self-accept since it exports values
-        const isSelfAccepting =
-          !cssModulesCache.get(config)?.get(id) &&
-          !inlineRE.test(id) &&
-          !htmlProxyRE.test(id)
-        // attached by pluginContainer.addWatchFile
-        const pluginImports = (this as unknown as TransformPluginContext)
-          ._addedImports
-        if (pluginImports) {
-          // record deps in the module graph so edits to @import css can trigger
-          // main import to hot update
-          const depModules = new Set<string | ModuleNode>()
-          const devBase = config.base
-          for (const file of pluginImports) {
-            depModules.add(
-              isCSSRequest(file)
-                ? moduleGraph.createFileOnlyEntry(file)
-                : await moduleGraph.ensureEntryFromUrl(
-                    stripBase(
-                      await fileToUrl(file, config, this),
-                      (config.server?.origin ?? '') + devBase,
-                    ),
-                    ssr,
-                  ),
-            )
-          }
-          moduleGraph.updateModuleInfo(
-            thisModule,
-            depModules,
-            null,
-            // The root CSS proxy module is self-accepting and should not
-            // have an explicit accept list
-            new Set(),
-            null,
-            isSelfAccepting,
-            ssr,
-          )
-        } else {
-          thisModule.isSelfAccepting = isSelfAccepting
-        }
-      }
-    },
-  }
-}
-
 /**
  * Create a replacer function that takes code and replaces given pure CSS chunk imports
  * @param pureCssChunkNames The chunks that only contain pure CSS and should be replaced
@@ -1062,408 +373,6 @@ export function getEmptyChunkReplacer(
     )
 }
 
-interface CSSAtImportResolvers {
-  css: ResolveFn
-  sass: ResolveFn
-  less: ResolveFn
-}
-
-function createCSSResolvers(config: ResolvedConfig): CSSAtImportResolvers {
-  let cssResolve: ResolveFn | undefined
-  let sassResolve: ResolveFn | undefined
-  let lessResolve: ResolveFn | undefined
-  return {
-    get css() {
-      return (
-        cssResolve ||
-        (cssResolve = config.createResolver({
-          extensions: ['.css'],
-          mainFields: ['style'],
-          conditions: ['style'],
-          tryIndex: false,
-          preferRelative: true,
-        }))
-      )
-    },
-
-    get sass() {
-      return (
-        sassResolve ||
-        (sassResolve = config.createResolver({
-          extensions: ['.scss', '.sass', '.css'],
-          mainFields: ['sass', 'style'],
-          conditions: ['sass', 'style'],
-          tryIndex: true,
-          tryPrefix: '_',
-          preferRelative: true,
-        }))
-      )
-    },
-
-    get less() {
-      return (
-        lessResolve ||
-        (lessResolve = config.createResolver({
-          extensions: ['.less', '.css'],
-          mainFields: ['less', 'style'],
-          conditions: ['less', 'style'],
-          tryIndex: false,
-          preferRelative: true,
-        }))
-      )
-    },
-  }
-}
-
-function getCssResolversKeys(
-  resolvers: CSSAtImportResolvers,
-): Array<keyof CSSAtImportResolvers> {
-  return Object.keys(resolvers) as unknown as Array<keyof CSSAtImportResolvers>
-}
-
-async function compileCSSPreprocessors(
-  id: string,
-  lang: PreprocessLang,
-  code: string,
-  config: ResolvedConfig,
-  workerController: PreprocessorWorkerController,
-): Promise<{ code: string; map?: ExistingRawSourceMap; deps?: Set<string> }> {
-  const { preprocessorOptions, devSourcemap } = config.css ?? {}
-  const atImportResolvers = getAtImportResolvers(config)
-
-  const preProcessor = workerController[lang]
-  let opts = (preprocessorOptions && preprocessorOptions[lang]) || {}
-  // support @import from node dependencies by default
-  switch (lang) {
-    case PreprocessLang.scss:
-    case PreprocessLang.sass:
-      opts = {
-        includePaths: ['node_modules'],
-        alias: config.resolve.alias,
-        ...opts,
-      }
-      break
-    case PreprocessLang.less:
-    case PreprocessLang.styl:
-    case PreprocessLang.stylus:
-      opts = {
-        paths: ['node_modules'],
-        alias: config.resolve.alias,
-        ...opts,
-      }
-  }
-  // important: set this for relative import resolving
-  opts.filename = cleanUrl(id)
-  opts.enableSourcemap = devSourcemap ?? false
-
-  const preprocessResult = await preProcessor(
-    code,
-    config.root,
-    opts,
-    atImportResolvers,
-  )
-  if (preprocessResult.error) {
-    throw preprocessResult.error
-  }
-
-  let deps: Set<string> | undefined
-  if (preprocessResult.deps) {
-    const normalizedFilename = normalizePath(opts.filename)
-    // sometimes sass registers the file itself as a dep
-    deps = new Set(
-      [...preprocessResult.deps].filter(
-        (dep) => normalizePath(dep) !== normalizedFilename,
-      ),
-    )
-  }
-
-  return {
-    code: preprocessResult.code,
-    map: combineSourcemapsIfExists(
-      opts.filename,
-      preprocessResult.map,
-      preprocessResult.additionalMap,
-    ),
-    deps,
-  }
-}
-
-const configToAtImportResolvers = new WeakMap<
-  ResolvedConfig,
-  CSSAtImportResolvers
->()
-function getAtImportResolvers(config: ResolvedConfig) {
-  let atImportResolvers = configToAtImportResolvers.get(config)
-  if (!atImportResolvers) {
-    atImportResolvers = createCSSResolvers(config)
-    configToAtImportResolvers.set(config, atImportResolvers)
-  }
-  return atImportResolvers
-}
-
-async function compileCSS(
-  id: string,
-  code: string,
-  config: ResolvedConfig,
-  workerController: PreprocessorWorkerController,
-  urlReplacer?: CssUrlReplacer,
-): Promise<{
-  code: string
-  map?: SourceMapInput
-  ast?: PostCSS.Result
-  modules?: Record<string, string>
-  deps?: Set<string>
-}> {
-  if (config.css?.transformer === 'lightningcss') {
-    return compileLightningCSS(id, code, config, urlReplacer)
-  }
-
-  const { modules: modulesOptions, devSourcemap } = config.css || {}
-  const isModule = modulesOptions !== false && cssModuleRE.test(id)
-  // although at serve time it can work without processing, we do need to
-  // crawl them in order to register watch dependencies.
-  const needInlineImport = code.includes('@import')
-  const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code)
-  const lang = CSS_LANGS_RE.exec(id)?.[1] as CssLang | undefined
-  const postcssConfig = await resolvePostcssConfig(config)
-
-  // 1. plain css that needs no processing
-  if (
-    lang === 'css' &&
-    !postcssConfig &&
-    !isModule &&
-    !needInlineImport &&
-    !hasUrl
-  ) {
-    return { code, map: null }
-  }
-
-  let modules: Record<string, string> | undefined
-  const deps = new Set<string>()
-
-  // 2. pre-processors: sass etc.
-  let preprocessorMap: ExistingRawSourceMap | undefined
-  if (isPreProcessor(lang)) {
-    const preprocessorResult = await compileCSSPreprocessors(
-      id,
-      lang,
-      code,
-      config,
-      workerController,
-    )
-    code = preprocessorResult.code
-    preprocessorMap = preprocessorResult.map
-    preprocessorResult.deps?.forEach((dep) => deps.add(dep))
-  }
-
-  // 3. postcss
-  const atImportResolvers = getAtImportResolvers(config)
-  const postcssOptions = (postcssConfig && postcssConfig.options) || {}
-
-  const postcssPlugins =
-    postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : []
-
-  if (needInlineImport) {
-    postcssPlugins.unshift(
-      (await importPostcssImport()).default({
-        async resolve(id, basedir) {
-          const publicFile = checkPublicFile(id, config)
-          if (publicFile) {
-            return publicFile
-          }
-
-          const resolved = await atImportResolvers.css(
-            id,
-            path.join(basedir, '*'),
-          )
-
-          if (resolved) {
-            return path.resolve(resolved)
-          }
-
-          // postcss-import falls back to `resolve` dep if this is unresolved,
-          // but we've shimmed to remove the `resolve` dep to cut on bundle size.
-          // warn here to provide a better error message.
-          if (!path.isAbsolute(id)) {
-            config.logger.error(
-              colors.red(
-                `Unable to resolve \`@import "${id}"\` from ${basedir}`,
-              ),
-            )
-          }
-
-          return id
-        },
-        async load(id) {
-          const code = await fs.promises.readFile(id, 'utf-8')
-          const lang = CSS_LANGS_RE.exec(id)?.[1] as CssLang | undefined
-          if (isPreProcessor(lang)) {
-            const result = await compileCSSPreprocessors(
-              id,
-              lang,
-              code,
-              config,
-              workerController,
-            )
-            result.deps?.forEach((dep) => deps.add(dep))
-            // TODO: support source map
-            return result.code
-          }
-          return code
-        },
-        nameLayer(index) {
-          return `vite--anon-layer-${getHash(id)}-${index}`
-        },
-      }),
-    )
-  }
-
-  if (urlReplacer) {
-    postcssPlugins.push(
-      UrlRewritePostcssPlugin({
-        replacer: urlReplacer,
-        logger: config.logger,
-      }),
-    )
-  }
-
-  if (isModule) {
-    postcssPlugins.unshift(
-      (await importPostcssModules()).default({
-        ...modulesOptions,
-        localsConvention: modulesOptions?.localsConvention,
-        getJSON(
-          cssFileName: string,
-          _modules: Record<string, string>,
-          outputFileName: string,
-        ) {
-          modules = _modules
-          if (modulesOptions && typeof modulesOptions.getJSON === 'function') {
-            modulesOptions.getJSON(cssFileName, _modules, outputFileName)
-          }
-        },
-        async resolve(id: string, importer: string) {
-          for (const key of getCssResolversKeys(atImportResolvers)) {
-            const resolved = await atImportResolvers[key](id, importer)
-            if (resolved) {
-              return path.resolve(resolved)
-            }
-          }
-
-          return id
-        },
-      }),
-    )
-  }
-
-  if (!postcssPlugins.length) {
-    return {
-      code,
-      map: preprocessorMap,
-      deps,
-    }
-  }
-
-  let postcssResult: PostCSS.Result
-  try {
-    const source = removeDirectQuery(id)
-    const postcss = await importPostcss()
-    // postcss is an unbundled dep and should be lazy imported
-    postcssResult = await postcss.default(postcssPlugins).process(code, {
-      ...postcssOptions,
-      parser: lang === 'sss' ? loadSss(config.root) : postcssOptions.parser,
-      to: source,
-      from: source,
-      ...(devSourcemap
-        ? {
-            map: {
-              inline: false,
-              annotation: false,
-              // postcss may return virtual files
-              // we cannot obtain content of them, so this needs to be enabled
-              sourcesContent: true,
-              // when "prev: preprocessorMap", the result map may include duplicate filename in `postcssResult.map.sources`
-              // prev: preprocessorMap,
-            },
-          }
-        : {}),
-    })
-
-    // record CSS dependencies from @imports
-    for (const message of postcssResult.messages) {
-      if (message.type === 'dependency') {
-        deps.add(normalizePath(message.file as string))
-      } else if (message.type === 'dir-dependency') {
-        // https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#3-dependencies
-        const { dir, glob: globPattern = '**' } = message
-        const pattern =
-          glob.escapePath(normalizePath(path.resolve(path.dirname(id), dir))) +
-          `/` +
-          globPattern
-        const files = glob.sync(pattern, {
-          ignore: ['**/node_modules/**'],
-        })
-        for (let i = 0; i < files.length; i++) {
-          deps.add(files[i])
-        }
-      } else if (message.type === 'warning') {
-        const warning = message as PostCSS.Warning
-        let msg = `[vite:css] ${warning.text}`
-        msg += `\n${generateCodeFrame(
-          code,
-          {
-            line: warning.line,
-            column: warning.column - 1, // 1-based
-          },
-          warning.endLine !== undefined && warning.endColumn !== undefined
-            ? {
-                line: warning.endLine,
-                column: warning.endColumn - 1, // 1-based
-              }
-            : undefined,
-        )}`
-        config.logger.warn(colors.yellow(msg))
-      }
-    }
-  } catch (e) {
-    e.message = `[postcss] ${e.message}`
-    e.code = code
-    e.loc = {
-      file: e.file,
-      line: e.line,
-      column: e.column - 1, // 1-based
-    }
-    throw e
-  }
-
-  if (!devSourcemap) {
-    return {
-      ast: postcssResult,
-      code: postcssResult.css,
-      map: { mappings: '' },
-      modules,
-      deps,
-    }
-  }
-
-  const rawPostcssMap = postcssResult.map.toJSON()
-
-  const postcssMap = await formatPostcssSourceMap(
-    // version property of rawPostcssMap is declared as string
-    // but actually it is a number
-    rawPostcssMap as Omit<RawSourceMap, 'version'> as ExistingRawSourceMap,
-    cleanUrl(id),
-  )
-
-  return {
-    ast: postcssResult,
-    code: postcssResult.css,
-    map: combineSourcemapsIfExists(cleanUrl(id), postcssMap, preprocessorMap),
-    modules,
-    deps,
-  }
-}
-
 function createCachedImport<T>(imp: () => Promise<T>): () => T | Promise<T> {
   let cached: T | Promise<T>
   return () => {
@@ -1622,17 +531,6 @@ async function resolvePostcssConfig(
   postcssConfigCache.set(config, result)
   return result
 }
-
-type CssUrlReplacer = (
-  url: string,
-  importer?: string,
-) => string | Promise<string>
-// https://drafts.csswg.org/css-syntax-3/#identifier-code-point
-export const cssUrlRE =
-  /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
-export const cssDataUriRE =
-  /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
-export const importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/
 // Assuming a function name won't be longer than 256 chars
 // eslint-disable-next-line regexp/no-unused-capturing-group -- doesn't detect asyncReplace usage
 const cssImageSetRE = /(?<=image-set\()((?:[\w\-]{1,256}\([^)]*\)|[^)])*)(?=\))/
@@ -1685,36 +583,6 @@ const UrlRewritePostcssPlugin: PostCSS.PluginCreator<{
 }
 UrlRewritePostcssPlugin.postcss = true
 
-function rewriteCssUrls(
-  css: string,
-  replacer: CssUrlReplacer,
-): Promise<string> {
-  return asyncReplace(css, cssUrlRE, async (match) => {
-    const [matched, rawUrl] = match
-    return await doUrlReplace(rawUrl.trim(), matched, replacer)
-  })
-}
-
-function rewriteCssDataUris(
-  css: string,
-  replacer: CssUrlReplacer,
-): Promise<string> {
-  return asyncReplace(css, cssDataUriRE, async (match) => {
-    const [matched, rawUrl] = match
-    return await doUrlReplace(rawUrl.trim(), matched, replacer, 'data-uri')
-  })
-}
-
-function rewriteImportCss(
-  css: string,
-  replacer: CssUrlReplacer,
-): Promise<string> {
-  return asyncReplace(css, importCssRE, async (match) => {
-    const [matched, rawUrl] = match
-    return await doImportCSSReplace(rawUrl, matched, replacer)
-  })
-}
-
 // TODO: image and cross-fade could contain a "url" that needs to be processed
 // https://drafts.csswg.org/css-images-4/#image-notation
 // https://drafts.csswg.org/css-images-4/#cross-fade-function
@@ -1739,14 +607,6 @@ async function rewriteCssImageSet(
     return url
   })
 }
-function skipUrlReplacer(rawUrl: string) {
-  return (
-    isExternalUrl(rawUrl) ||
-    isDataUrl(rawUrl) ||
-    rawUrl[0] === '#' ||
-    functionCallRE.test(rawUrl)
-  )
-}
 async function doUrlReplace(
   rawUrl: string,
   matched: string,
@@ -1799,65 +659,6 @@ async function doImportCSSReplace(
   return `@import ${wrap}${await replacer(rawUrl)}${wrap}`
 }
 
-async function minifyCSS(
-  css: string,
-  config: ResolvedConfig,
-  inlined: boolean,
-) {
-  // We want inlined CSS to not end with a linebreak, while ensuring that
-  // regular CSS assets do end with a linebreak.
-  // See https://github.com/vitejs/vite/pull/13893#issuecomment-1678628198
-
-  if (config.build.cssMinify === 'lightningcss') {
-    const { code, warnings } = (await importLightningCSS()).transform({
-      ...config.css?.lightningcss,
-      targets: convertTargets(config.build.cssTarget),
-      cssModules: undefined,
-      filename: cssBundleName,
-      code: Buffer.from(css),
-      minify: true,
-    })
-    if (warnings.length) {
-      config.logger.warn(
-        colors.yellow(
-          `warnings when minifying css:\n${warnings
-            .map((w) => w.message)
-            .join('\n')}`,
-        ),
-      )
-    }
-
-    // NodeJS res.code = Buffer
-    // Deno res.code = Uint8Array
-    // For correct decode compiled css need to use TextDecoder
-    // LightningCSS output does not return a linebreak at the end
-    return decoder.decode(code) + (inlined ? '' : '\n')
-  }
-  try {
-    const { code, warnings } = await transform(css, {
-      loader: 'css',
-      target: config.build.cssTarget || undefined,
-      ...resolveMinifyCssEsbuildOptions(config.esbuild || {}),
-    })
-    if (warnings.length) {
-      const msgs = await formatMessages(warnings, { kind: 'warning' })
-      config.logger.warn(
-        colors.yellow(`warnings when minifying css:\n${msgs.join('\n')}`),
-      )
-    }
-    // esbuild output does return a linebreak at the end
-    return inlined ? code.trimEnd() : code
-  } catch (e) {
-    if (e.errors) {
-      e.message = '[esbuild css minify] ' + e.message
-      const msgs = await formatMessages(e.errors, { kind: 'error' })
-      e.frame = '\n' + msgs.join('\n')
-      e.loc = e.errors[0].location
-    }
-    throw e
-  }
-}
-
 function resolveMinifyCssEsbuildOptions(
   options: ESBuildOptions,
 ): TransformOptions {
@@ -1923,75 +724,6 @@ export async function hoistAtRules(css: string): Promise<string> {
 
 // Preprocessor support. This logic is largely replicated from @vue/compiler-sfc
 
-type PreprocessorAdditionalDataResult =
-  | string
-  | { content: string; map?: ExistingRawSourceMap }
-
-type PreprocessorAdditionalData =
-  | string
-  | ((
-      source: string,
-      filename: string,
-    ) =>
-      | PreprocessorAdditionalDataResult
-      | Promise<PreprocessorAdditionalDataResult>)
-
-type StylePreprocessorOptions = {
-  [key: string]: any
-  additionalData?: PreprocessorAdditionalData
-  maxWorkers?: number | true
-  filename: string
-  alias: Alias[]
-  enableSourcemap: boolean
-}
-
-type SassStylePreprocessorOptions = StylePreprocessorOptions &
-  Omit<Sass.LegacyOptions<'async'>, 'data' | 'file' | 'outFile'> & {
-    api?: 'legacy' | 'modern' | 'modern-compiler'
-  }
-
-type StylusStylePreprocessorOptions = StylePreprocessorOptions & {
-  define?: Record<string, any>
-}
-
-type StylePreprocessor = {
-  process: (
-    source: string,
-    root: string,
-    options: StylePreprocessorOptions,
-    resolvers: CSSAtImportResolvers,
-  ) => StylePreprocessorResults | Promise<StylePreprocessorResults>
-  close: () => void
-}
-
-type SassStylePreprocessor = {
-  process: (
-    source: string,
-    root: string,
-    options: SassStylePreprocessorOptions,
-    resolvers: CSSAtImportResolvers,
-  ) => StylePreprocessorResults | Promise<StylePreprocessorResults>
-  close: () => void
-}
-
-type StylusStylePreprocessor = {
-  process: (
-    source: string,
-    root: string,
-    options: StylusStylePreprocessorOptions,
-    resolvers: CSSAtImportResolvers,
-  ) => StylePreprocessorResults | Promise<StylePreprocessorResults>
-  close: () => void
-}
-
-export interface StylePreprocessorResults {
-  code: string
-  map?: ExistingRawSourceMap | undefined
-  additionalMap?: ExistingRawSourceMap | undefined
-  error?: RollupError
-  deps: string[]
-}
-
 const loadedPreprocessorPath: Partial<
   Record<PreprocessLang | PostCssDialectLang | 'sass-embedded', string>
 > = {}
@@ -2053,774 +785,14 @@ function loadSss(root: string) {
 declare const window: unknown | undefined
 declare const location: { href: string } | undefined
 
-// in unix, scss might append `location.href` in environments that shim `location`
-// see https://github.com/sass/dart-sass/issues/710
-function cleanScssBugUrl(url: string) {
-  if (
-    // check bug via `window` and `location` global
-    typeof window !== 'undefined' &&
-    typeof location !== 'undefined' &&
-    typeof location?.href === 'string'
-  ) {
-    const prefix = location.href.replace(/\/$/, '')
-    return url.replace(prefix, '')
-  } else {
-    return url
-  }
-}
-
-function fixScssBugImportValue(
-  data: Sass.LegacyImporterResult,
-): Sass.LegacyImporterResult {
-  // the scss bug doesn't load files properly so we have to load it ourselves
-  // to prevent internal error when it loads itself
-  if (
-    // check bug via `window` and `location` global
-    typeof window !== 'undefined' &&
-    typeof location !== 'undefined' &&
-    data &&
-    'file' in data &&
-    (!('contents' in data) || data.contents == null)
-  ) {
-    // @ts-expect-error we need to preserve file property for HMR
-    data.contents = fs.readFileSync(data.file, 'utf-8')
-  }
-  return data
-}
-
-// #region Sass
-// .scss/.sass processor
-const makeScssWorker = (
-  resolvers: CSSAtImportResolvers,
-  alias: Alias[],
-  maxWorkers: number | undefined,
-) => {
-  const internalImporter = async (
-    url: string,
-    importer: string,
-    filename: string,
-  ) => {
-    importer = cleanScssBugUrl(importer)
-    const resolved = await resolvers.sass(url, importer)
-    if (resolved) {
-      try {
-        const data = await rebaseUrls(
-          resolved,
-          filename,
-          alias,
-          '$',
-          resolvers.sass,
-        )
-        return fixScssBugImportValue(data)
-      } catch (data) {
-        return data
-      }
-    } else {
-      return null
-    }
-  }
-
-  const worker = new WorkerWithFallback(
-    () =>
-      async (
-        sassPath: string,
-        data: string,
-        // additionalData can a function that is not cloneable but it won't be used
-        options: SassStylePreprocessorOptions & { additionalData: undefined },
-      ) => {
-        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
-        const sass: typeof Sass = require(sassPath)
-        // eslint-disable-next-line no-restricted-globals
-        const path: typeof import('node:path') = require('node:path')
-
-        // NOTE: `sass` always runs it's own importer first, and only falls back to
-        // the `importer` option when it can't resolve a path
-        const _internalImporter: Sass.LegacyAsyncImporter = (
-          url,
-          importer,
-          done,
-        ) => {
-          internalImporter(url, importer, options.filename).then((data) =>
-            done?.(data),
-          )
-        }
-        const importer = [_internalImporter]
-        if (options.importer) {
-          Array.isArray(options.importer)
-            ? importer.unshift(...options.importer)
-            : importer.unshift(options.importer)
-        }
-
-        const finalOptions: Sass.LegacyOptions<'async'> = {
-          ...options,
-          data,
-          file: options.filename,
-          outFile: options.filename,
-          importer,
-          ...(options.enableSourcemap
-            ? {
-                sourceMap: true,
-                omitSourceMapUrl: true,
-                sourceMapRoot: path.dirname(options.filename),
-              }
-            : {}),
-        }
-        return new Promise<ScssWorkerResult>((resolve, reject) => {
-          sass.render(finalOptions, (err, res) => {
-            if (err) {
-              reject(err)
-            } else {
-              resolve({
-                css: res!.css.toString(),
-                map: res!.map?.toString(),
-                stats: res!.stats,
-              })
-            }
-          })
-        })
-      },
-    {
-      parentFunctions: { internalImporter },
-      shouldUseFake(_sassPath, _data, options) {
-        // functions and importer is a function and is not serializable
-        // in that case, fallback to running in main thread
-        return !!(
-          (options.functions && Object.keys(options.functions).length > 0) ||
-          (options.importer &&
-            (!Array.isArray(options.importer) || options.importer.length > 0))
-        )
-      },
-      max: maxWorkers,
-    },
-  )
-  return worker
-}
-
-const makeModernScssWorker = (
-  resolvers: CSSAtImportResolvers,
-  alias: Alias[],
-  maxWorkers: number | undefined,
-) => {
-  const internalCanonicalize = async (
-    url: string,
-    importer: string,
-  ): Promise<string | null> => {
-    importer = cleanScssBugUrl(importer)
-    const resolved = await resolvers.sass(url, importer)
-    return resolved ?? null
-  }
-
-  const internalLoad = async (file: string, rootFile: string) => {
-    const result = await rebaseUrls(file, rootFile, alias, '$', resolvers.sass)
-    if (result.contents) {
-      return result.contents
-    }
-    return await fsp.readFile(result.file, 'utf-8')
-  }
-
-  const worker = new WorkerWithFallback(
-    () =>
-      async (
-        sassPath: string,
-        data: string,
-        // additionalData can a function that is not cloneable but it won't be used
-        options: SassStylePreprocessorOptions & { additionalData: undefined },
-      ) => {
-        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
-        const sass: typeof Sass = require(sassPath)
-        // eslint-disable-next-line no-restricted-globals
-        const path: typeof import('node:path') = require('node:path')
-
-        const { fileURLToPath, pathToFileURL }: typeof import('node:url') =
-          // eslint-disable-next-line no-restricted-globals
-          require('node:url')
-
-        const sassOptions = { ...options } as Sass.StringOptions<'async'>
-        sassOptions.url = pathToFileURL(options.filename)
-        sassOptions.sourceMap = options.enableSourcemap
-
-        const internalImporter: Sass.Importer<'async'> = {
-          async canonicalize(url, context) {
-            const importer = context.containingUrl
-              ? fileURLToPath(context.containingUrl)
-              : options.filename
-            const resolved = await internalCanonicalize(url, importer)
-            return resolved ? pathToFileURL(resolved) : null
-          },
-          async load(canonicalUrl) {
-            const ext = path.extname(canonicalUrl.pathname)
-            let syntax: Sass.Syntax = 'scss'
-            if (ext === '.sass') {
-              syntax = 'indented'
-            } else if (ext === '.css') {
-              syntax = 'css'
-            }
-            const contents = await internalLoad(
-              fileURLToPath(canonicalUrl),
-              options.filename,
-            )
-            return { contents, syntax }
-          },
-        }
-        sassOptions.importers = [
-          ...(sassOptions.importers ?? []),
-          internalImporter,
-        ]
-
-        const result = await sass.compileStringAsync(data, sassOptions)
-        return {
-          css: result.css,
-          map: result.sourceMap ? JSON.stringify(result.sourceMap) : undefined,
-          stats: {
-            includedFiles: result.loadedUrls
-              .filter((url) => url.protocol === 'file:')
-              .map((url) => fileURLToPath(url)),
-          },
-        } satisfies ScssWorkerResult
-      },
-    {
-      parentFunctions: {
-        internalCanonicalize,
-        internalLoad,
-      },
-      shouldUseFake(_sassPath, _data, options) {
-        // functions and importer is a function and is not serializable
-        // in that case, fallback to running in main thread
-        return !!(
-          (options.functions && Object.keys(options.functions).length > 0) ||
-          (options.importers &&
-            (!Array.isArray(options.importers) || options.importers.length > 0))
-        )
-      },
-      max: maxWorkers,
-    },
-  )
-  return worker
-}
-
-// this is mostly a copy&paste of makeModernScssWorker
-// however sharing code between two is hard because
-// makeModernScssWorker above needs function inlined for worker.
-const makeModernCompilerScssWorker = (
-  resolvers: CSSAtImportResolvers,
-  alias: Alias[],
-  _maxWorkers: number | undefined,
-) => {
-  let compiler: Sass.AsyncCompiler | undefined
-
-  const worker: Awaited<ReturnType<typeof makeModernScssWorker>> = {
-    async run(sassPath, data, options) {
-      // need pathToFileURL for windows since import("D:...") fails
-      // https://github.com/nodejs/node/issues/31710
-      const sass: typeof Sass = (await import(pathToFileURL(sassPath).href))
-        .default
-      compiler ??= await sass.initAsyncCompiler()
-
-      const sassOptions = { ...options } as Sass.StringOptions<'async'>
-      sassOptions.url = pathToFileURL(options.filename)
-      sassOptions.sourceMap = options.enableSourcemap
-
-      const internalImporter: Sass.Importer<'async'> = {
-        async canonicalize(url, context) {
-          const importer = context.containingUrl
-            ? fileURLToPath(context.containingUrl)
-            : options.filename
-          const resolved = await resolvers.sass(url, cleanScssBugUrl(importer))
-          return resolved ? pathToFileURL(resolved) : null
-        },
-        async load(canonicalUrl) {
-          const ext = path.extname(canonicalUrl.pathname)
-          let syntax: Sass.Syntax = 'scss'
-          if (ext === '.sass') {
-            syntax = 'indented'
-          } else if (ext === '.css') {
-            syntax = 'css'
-          }
-          const result = await rebaseUrls(
-            fileURLToPath(canonicalUrl),
-            options.filename,
-            alias,
-            '$',
-            resolvers.sass,
-          )
-          const contents =
-            result.contents ?? (await fsp.readFile(result.file, 'utf-8'))
-          return { contents, syntax }
-        },
-      }
-      sassOptions.importers = [
-        ...(sassOptions.importers ?? []),
-        internalImporter,
-      ]
-
-      const result = await compiler.compileStringAsync(data, sassOptions)
-      return {
-        css: result.css,
-        map: result.sourceMap ? JSON.stringify(result.sourceMap) : undefined,
-        stats: {
-          includedFiles: result.loadedUrls
-            .filter((url) => url.protocol === 'file:')
-            .map((url) => fileURLToPath(url)),
-        },
-      } satisfies ScssWorkerResult
-    },
-    async stop() {
-      compiler?.dispose()
-      compiler = undefined
-    },
-  }
-
-  return worker
-}
-
 type ScssWorkerResult = {
   css: string
   map?: string | undefined
   stats: Pick<Sass.LegacyResult['stats'], 'includedFiles'>
 }
-
-const scssProcessor = (
-  maxWorkers: number | undefined,
-): SassStylePreprocessor => {
-  const workerMap = new Map<unknown, ReturnType<typeof makeScssWorker>>()
-
-  return {
-    close() {
-      for (const worker of workerMap.values()) {
-        worker.stop()
-      }
-    },
-    async process(source, root, options, resolvers) {
-      const sassPackage = loadSassPackage(root)
-      // TODO: change default in v6
-      // options.api ?? sassPackage.name === "sass-embedded" ? "modern-compiler" : "modern";
-      const api = options.api ?? 'legacy'
-
-      if (!workerMap.has(options.alias)) {
-        workerMap.set(
-          options.alias,
-          api === 'modern-compiler'
-            ? makeModernCompilerScssWorker(resolvers, options.alias, maxWorkers)
-            : api === 'modern'
-              ? makeModernScssWorker(resolvers, options.alias, maxWorkers)
-              : makeScssWorker(resolvers, options.alias, maxWorkers),
-        )
-      }
-      const worker = workerMap.get(options.alias)!
-
-      const { content: data, map: additionalMap } = await getSource(
-        source,
-        options.filename,
-        options.additionalData,
-        options.enableSourcemap,
-      )
-
-      const optionsWithoutAdditionalData = {
-        ...options,
-        additionalData: undefined,
-      }
-      try {
-        const result = await worker.run(
-          sassPackage.path,
-          data,
-          optionsWithoutAdditionalData,
-        )
-        const deps = result.stats.includedFiles.map((f) => cleanScssBugUrl(f))
-        const map: ExistingRawSourceMap | undefined = result.map
-          ? JSON.parse(result.map.toString())
-          : undefined
-
-        return {
-          code: result.css.toString(),
-          map,
-          additionalMap,
-          deps,
-        }
-      } catch (e) {
-        // normalize SASS error
-        e.message = `[sass] ${e.message}`
-        e.id = e.file
-        e.frame = e.formatted
-        return { code: '', error: e, deps: [] }
-      }
-    },
-  }
-}
 // #endregion
-
-/**
- * relative url() inside \@imported sass and less files must be rebased to use
- * root file as base.
- */
-async function rebaseUrls(
-  file: string,
-  rootFile: string,
-  alias: Alias[],
-  variablePrefix: string,
-  resolver: ResolveFn,
-): Promise<{ file: string; contents?: string }> {
-  file = path.resolve(file) // ensure os-specific flashes
-  // in the same dir, no need to rebase
-  const fileDir = path.dirname(file)
-  const rootDir = path.dirname(rootFile)
-  if (fileDir === rootDir) {
-    return { file }
-  }
-
-  const content = await fsp.readFile(file, 'utf-8')
-  // no url()
-  const hasUrls = cssUrlRE.test(content)
-  // data-uri() calls
-  const hasDataUris = cssDataUriRE.test(content)
-  // no @import xxx.css
-  const hasImportCss = importCssRE.test(content)
-
-  if (!hasUrls && !hasDataUris && !hasImportCss) {
-    return { file }
-  }
-
-  let rebased
-  const rebaseFn = async (url: string) => {
-    if (url[0] === '/') return url
-    // ignore url's starting with variable
-    if (url.startsWith(variablePrefix)) return url
-    // match alias, no need to rewrite
-    for (const { find } of alias) {
-      const matches =
-        typeof find === 'string' ? url.startsWith(find) : find.test(url)
-      if (matches) {
-        return url
-      }
-    }
-    const absolute = (await resolver(url, file)) || path.resolve(fileDir, url)
-    const relative = path.relative(rootDir, absolute)
-    return normalizePath(relative)
-  }
-
-  // fix css imports in less such as `@import "foo.css"`
-  if (hasImportCss) {
-    rebased = await rewriteImportCss(content, rebaseFn)
-  }
-
-  if (hasUrls) {
-    rebased = await rewriteCssUrls(rebased || content, rebaseFn)
-  }
-
-  if (hasDataUris) {
-    rebased = await rewriteCssDataUris(rebased || content, rebaseFn)
-  }
-
-  return {
-    file,
-    contents: rebased,
-  }
-}
-
-// #region Less
-// .less
-const makeLessWorker = (
-  resolvers: CSSAtImportResolvers,
-  alias: Alias[],
-  maxWorkers: number | undefined,
-) => {
-  const viteLessResolve = async (
-    filename: string,
-    dir: string,
-    rootFile: string,
-  ) => {
-    const resolved = await resolvers.less(filename, path.join(dir, '*'))
-    if (!resolved) return undefined
-
-    const result = await rebaseUrls(
-      resolved,
-      rootFile,
-      alias,
-      '@',
-      resolvers.less,
-    )
-    if (result) {
-      return {
-        resolved,
-        contents: 'contents' in result ? result.contents : undefined,
-      }
-    }
-    return result
-  }
-
-  const worker = new WorkerWithFallback(
-    () => {
-      // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
-      const fsp = require('node:fs/promises')
-      // eslint-disable-next-line no-restricted-globals
-      const path = require('node:path')
-
-      let ViteLessManager: any
-      const createViteLessPlugin = (
-        less: typeof Less,
-        rootFile: string,
-      ): Less.Plugin => {
-        const { FileManager } = less
-        ViteLessManager ??= class ViteManager extends FileManager {
-          rootFile
-          constructor(rootFile: string) {
-            super()
-            this.rootFile = rootFile
-          }
-          override supports(filename: string) {
-            return !/^(?:https?:)?\/\//.test(filename)
-          }
-          override supportsSync() {
-            return false
-          }
-          override async loadFile(
-            filename: string,
-            dir: string,
-            opts: any,
-            env: any,
-          ): Promise<Less.FileLoadResult> {
-            const result = await viteLessResolve(filename, dir, this.rootFile)
-            if (result) {
-              return {
-                filename: path.resolve(result.resolved),
-                contents:
-                  result.contents ??
-                  (await fsp.readFile(result.resolved, 'utf-8')),
-              }
-            } else {
-              return super.loadFile(filename, dir, opts, env)
-            }
-          }
-        }
-
-        return {
-          install(_, pluginManager) {
-            pluginManager.addFileManager(new ViteLessManager(rootFile))
-          },
-          minVersion: [3, 0, 0],
-        }
-      }
-
-      return async (
-        lessPath: string,
-        content: string,
-        // additionalData can a function that is not cloneable but it won't be used
-        options: StylePreprocessorOptions & { additionalData: undefined },
-      ) => {
-        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
-        const nodeLess: typeof Less = require(lessPath)
-        const viteResolverPlugin = createViteLessPlugin(
-          nodeLess,
-          options.filename,
-        )
-        const result = await nodeLess.render(content, {
-          ...options,
-          plugins: [viteResolverPlugin, ...(options.plugins || [])],
-          ...(options.enableSourcemap
-            ? {
-                sourceMap: {
-                  outputSourceFiles: true,
-                  sourceMapFileInline: false,
-                },
-              }
-            : {}),
-        })
-        return result
-      }
-    },
-    {
-      parentFunctions: { viteLessResolve },
-      shouldUseFake(_lessPath, _content, options) {
-        // plugins are a function and is not serializable
-        // in that case, fallback to running in main thread
-        return options.plugins?.length > 0
-      },
-      max: maxWorkers,
-    },
-  )
-  return worker
-}
-
-const lessProcessor = (maxWorkers: number | undefined): StylePreprocessor => {
-  const workerMap = new Map<unknown, ReturnType<typeof makeLessWorker>>()
-
-  return {
-    close() {
-      for (const worker of workerMap.values()) {
-        worker.stop()
-      }
-    },
-    async process(source, root, options, resolvers) {
-      const lessPath = loadPreprocessorPath(PreprocessLang.less, root)
-
-      if (!workerMap.has(options.alias)) {
-        workerMap.set(
-          options.alias,
-          makeLessWorker(resolvers, options.alias, maxWorkers),
-        )
-      }
-      const worker = workerMap.get(options.alias)!
-
-      const { content, map: additionalMap } = await getSource(
-        source,
-        options.filename,
-        options.additionalData,
-        options.enableSourcemap,
-      )
-
-      let result: Less.RenderOutput | undefined
-      const optionsWithoutAdditionalData = {
-        ...options,
-        additionalData: undefined,
-      }
-      try {
-        result = await worker.run(
-          lessPath,
-          content,
-          optionsWithoutAdditionalData,
-        )
-      } catch (e) {
-        const error = e as Less.RenderError
-        // normalize error info
-        const normalizedError: RollupError = new Error(
-          `[less] ${error.message || error.type}`,
-        ) as RollupError
-        normalizedError.loc = {
-          file: error.filename || options.filename,
-          line: error.line,
-          column: error.column,
-        }
-        return { code: '', error: normalizedError, deps: [] }
-      }
-
-      const map: ExistingRawSourceMap = result.map && JSON.parse(result.map)
-      if (map) {
-        delete map.sourcesContent
-      }
-
-      return {
-        code: result.css.toString(),
-        map,
-        additionalMap,
-        deps: result.imports,
-      }
-    },
-  }
-}
 // #endregion
 
-// #region Stylus
-// .styl
-const makeStylWorker = (maxWorkers: number | undefined) => {
-  const worker = new WorkerWithFallback(
-    () => {
-      return async (
-        stylusPath: string,
-        content: string,
-        root: string,
-        // additionalData can a function that is not cloneable but it won't be used
-        options: StylusStylePreprocessorOptions & { additionalData: undefined },
-      ) => {
-        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
-        const nodeStylus: typeof Stylus = require(stylusPath)
-
-        const ref = nodeStylus(content, options)
-        if (options.define) {
-          for (const key in options.define) {
-            ref.define(key, options.define[key])
-          }
-        }
-        if (options.enableSourcemap) {
-          ref.set('sourcemap', {
-            comment: false,
-            inline: false,
-            basePath: root,
-          })
-        }
-
-        return {
-          code: ref.render(),
-          // @ts-expect-error sourcemap exists
-          map: ref.sourcemap as ExistingRawSourceMap | undefined,
-          deps: ref.deps(),
-        }
-      }
-    },
-    {
-      shouldUseFake(_stylusPath, _content, _root, options) {
-        // define can include functions and those are not serializable
-        // in that case, fallback to running in main thread
-        return !!(
-          options.define &&
-          Object.values(options.define).some((d) => typeof d === 'function')
-        )
-      },
-      max: maxWorkers,
-    },
-  )
-  return worker
-}
-
-const stylProcessor = (
-  maxWorkers: number | undefined,
-): StylusStylePreprocessor => {
-  const workerMap = new Map<unknown, ReturnType<typeof makeStylWorker>>()
-
-  return {
-    close() {
-      for (const worker of workerMap.values()) {
-        worker.stop()
-      }
-    },
-    async process(source, root, options, resolvers) {
-      const stylusPath = loadPreprocessorPath(PreprocessLang.stylus, root)
-
-      if (!workerMap.has(options.alias)) {
-        workerMap.set(options.alias, makeStylWorker(maxWorkers))
-      }
-      const worker = workerMap.get(options.alias)!
-
-      // Get source with preprocessor options.additionalData. Make sure a new line separator
-      // is added to avoid any render error, as added stylus content may not have semi-colon separators
-      const { content, map: additionalMap } = await getSource(
-        source,
-        options.filename,
-        options.additionalData,
-        options.enableSourcemap,
-        '\n',
-      )
-      // Get preprocessor options.imports dependencies as stylus
-      // does not return them with its builtin `.deps()` method
-      const importsDeps = (options.imports ?? []).map((dep: string) =>
-        path.resolve(dep),
-      )
-      const optionsWithoutAdditionalData = {
-        ...options,
-        additionalData: undefined,
-      }
-      try {
-        const { code, map, deps } = await worker.run(
-          stylusPath,
-          content,
-          root,
-          optionsWithoutAdditionalData,
-        )
-        return {
-          code,
-          map: formatStylusSourceMap(map, root),
-          additionalMap,
-          // Concat imports deps with computed deps
-          deps: [...deps, ...importsDeps],
-        }
-      } catch (e) {
-        const wrapped = new Error(`[stylus] ${e.message}`)
-        wrapped.name = e.name
-        wrapped.stack = e.stack
-        return { code: '', error: wrapped, deps: [] }
-      }
-    },
-  }
-}
-
 function formatStylusSourceMap(
   mapBefore: ExistingRawSourceMap | undefined,
   root: string,
@@ -2932,118 +904,6 @@ function isPreProcessor(lang: any): lang is PreprocessLang {
 }
 
 const importLightningCSS = createCachedImport(() => import('lightningcss'))
-async function compileLightningCSS(
-  id: string,
-  src: string,
-  config: ResolvedConfig,
-  urlReplacer?: CssUrlReplacer,
-): ReturnType<typeof compileCSS> {
-  const deps = new Set<string>()
-  // Relative path is needed to get stable hash when using CSS modules
-  const filename = cleanUrl(path.relative(config.root, id))
-  const toAbsolute = (filePath: string) =>
-    path.isAbsolute(filePath) ? filePath : path.join(config.root, filePath)
-
-  const res = styleAttrRE.test(id)
-    ? (await importLightningCSS()).transformStyleAttribute({
-        filename,
-        code: Buffer.from(src),
-        targets: config.css?.lightningcss?.targets,
-        minify: config.isProduction && !!config.build.cssMinify,
-        analyzeDependencies: true,
-      })
-    : await (
-        await importLightningCSS()
-      ).bundleAsync({
-        ...config.css?.lightningcss,
-        filename,
-        resolver: {
-          read(filePath) {
-            if (filePath === filename) {
-              return src
-            }
-            // This happens with html-proxy (#13776)
-            if (!filePath.endsWith('.css')) {
-              return src
-            }
-            return fs.readFileSync(toAbsolute(filePath), 'utf-8')
-          },
-          async resolve(id, from) {
-            const publicFile = checkPublicFile(id, config)
-            if (publicFile) {
-              return publicFile
-            }
-
-            const resolved = await getAtImportResolvers(config).css(
-              id,
-              toAbsolute(from),
-            )
-
-            if (resolved) {
-              deps.add(resolved)
-              return resolved
-            }
-            return id
-          },
-        },
-        minify: config.isProduction && !!config.build.cssMinify,
-        sourceMap:
-          config.command === 'build'
-            ? !!config.build.sourcemap
-            : config.css?.devSourcemap,
-        analyzeDependencies: true,
-        cssModules: cssModuleRE.test(id)
-          ? (config.css?.lightningcss?.cssModules ?? true)
-          : undefined,
-      })
-
-  // NodeJS res.code = Buffer
-  // Deno res.code = Uint8Array
-  // For correct decode compiled css need to use TextDecoder
-  let css = decoder.decode(res.code)
-  for (const dep of res.dependencies!) {
-    switch (dep.type) {
-      case 'url':
-        if (skipUrlReplacer(dep.url)) {
-          css = css.replace(dep.placeholder, () => dep.url)
-          break
-        }
-        deps.add(dep.url)
-        if (urlReplacer) {
-          const replaceUrl = await urlReplacer(dep.url, id)
-          css = css.replace(dep.placeholder, () => replaceUrl)
-        } else {
-          css = css.replace(dep.placeholder, () => dep.url)
-        }
-        break
-      default:
-        throw new Error(`Unsupported dependency type: ${dep.type}`)
-    }
-  }
-
-  let modules: Record<string, string> | undefined
-  if ('exports' in res && res.exports) {
-    modules = {}
-    // https://github.com/parcel-bundler/lightningcss/issues/291
-    const sortedEntries = Object.entries(res.exports).sort((a, b) =>
-      a[0].localeCompare(b[0]),
-    )
-    for (const [key, value] of sortedEntries) {
-      modules[key] = value.name
-      // https://lightningcss.dev/css-modules.html#class-composition
-      for (const c of value.composes) {
-        modules[key] += ' ' + c.name
-      }
-    }
-  }
-
-  return {
-    code: css,
-    map: 'map' in res ? res.map?.toString() : undefined,
-    deps,
-    modules,
-  }
-}
 
 // Convert https://esbuild.github.io/api/#target
 // To https://github.com/parcel-bundler/lightningcss/blob/master/node/targets.d.ts
diff --git a/packages/vite/src/node/plugins/css/compileCSS.ts b/packages/vite/src/node/plugins/css/compileCSS.ts
new file mode 100644
index 000000000..c939adbe3
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/compileCSS.ts
@@ -0,0 +1,449 @@
+import path from 'node:path'
+import glob from 'fast-glob'
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import colors from 'picocolors'
+import type * as PostCSS from 'postcss'
+import type { RawSourceMap } from '@ampproject/remapping'
+import { CSS_LANGS_RE } from 'packages/vite/src/node/constants';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { getHash } from 'packages/vite/src/node/utils';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { removeDirectQuery } from 'packages/vite/src/node/utils';
+import { generateCodeFrame } from 'packages/vite/src/node/utils';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { ResolveFn } from 'packages/vite/src/node/index';
+
+
+const export cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`)
+
+export const enum PreprocessLang {
+  less = 'less',
+  sass = 'sass',
+  scss = 'scss',
+  styl = 'styl',
+  stylus = 'stylus',
+}
+
+export const enum PureCssLang {
+  css = 'css',
+}
+
+export const enum PostCssDialectLang {
+  sss = 'sugarss',
+}
+
+export type CssLang =
+  | keyof typeof PureCssLang
+  | keyof typeof PreprocessLang
+  | keyof typeof PostCssDialectLang
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export function getCssResolversKeys(
+  resolvers: CSSAtImportResolvers,
+): Array<keyof CSSAtImportResolvers> {
+  return Object.keys(resolvers) as unknown as Array<keyof CSSAtImportResolvers>
+}
+
+export async function compileCSSPreprocessors(
+  id: string,
+  lang: PreprocessLang,
+  code: string,
+  config: ResolvedConfig,
+  workerController: PreprocessorWorkerController,
+): Promise<{ code: string; map?: ExistingRawSourceMap; deps?: Set<string> }> {
+  const { preprocessorOptions, devSourcemap } = config.css ?? {}
+  const atImportResolvers = getAtImportResolvers(config)
+
+  const preProcessor = workerController[lang]
+  let opts = (preprocessorOptions && preprocessorOptions[lang]) || {}
+  // support @import from node dependencies by default
+  switch (lang) {
+    case PreprocessLang.scss:
+    case PreprocessLang.sass:
+      opts = {
+        includePaths: ['node_modules'],
+        alias: config.resolve.alias,
+        ...opts,
+      }
+      break
+    case PreprocessLang.less:
+    case PreprocessLang.styl:
+    case PreprocessLang.stylus:
+      opts = {
+        paths: ['node_modules'],
+        alias: config.resolve.alias,
+        ...opts,
+      }
+  }
+  // important: set this for relative import resolving
+  opts.filename = cleanUrl(id)
+  opts.enableSourcemap = devSourcemap ?? false
+
+  const preprocessResult = await preProcessor(
+    code,
+    config.root,
+    opts,
+    atImportResolvers,
+  )
+  if (preprocessResult.error) {
+    throw preprocessResult.error
+  }
+
+  let deps: Set<string> | undefined
+  if (preprocessResult.deps) {
+    const normalizedFilename = normalizePath(opts.filename)
+    // sometimes sass registers the file itself as a dep
+    deps = new Set(
+      [...preprocessResult.deps].filter(
+        (dep) => normalizePath(dep) !== normalizedFilename,
+      ),
+    )
+  }
+
+  return {
+    code: preprocessResult.code,
+    map: combineSourcemapsIfExists(
+      opts.filename,
+      preprocessResult.map,
+      preprocessResult.additionalMap,
+    ),
+    deps,
+  }
+}
+
+export function createCSSResolvers(config: ResolvedConfig): CSSAtImportResolvers {
+  let cssResolve: ResolveFn | undefined
+  let sassResolve: ResolveFn | undefined
+  let lessResolve: ResolveFn | undefined
+  return {
+    get css() {
+      return (
+        cssResolve ||
+        (cssResolve = config.createResolver({
+          extensions: ['.css'],
+          mainFields: ['style'],
+          conditions: ['style'],
+          tryIndex: false,
+          preferRelative: true,
+        }))
+      )
+    },
+
+    get sass() {
+      return (
+        sassResolve ||
+        (sassResolve = config.createResolver({
+          extensions: ['.scss', '.sass', '.css'],
+          mainFields: ['sass', 'style'],
+          conditions: ['sass', 'style'],
+          tryIndex: true,
+          tryPrefix: '_',
+          preferRelative: true,
+        }))
+      )
+    },
+
+    get less() {
+      return (
+        lessResolve ||
+        (lessResolve = config.createResolver({
+          extensions: ['.less', '.css'],
+          mainFields: ['less', 'style'],
+          conditions: ['less', 'style'],
+          tryIndex: false,
+          preferRelative: true,
+        }))
+      )
+    },
+  }
+}
+
+const export configToAtImportResolvers = new WeakMap<
+  ResolvedConfig,
+  CSSAtImportResolvers
+>()
+
+export function getAtImportResolvers(config: ResolvedConfig) {
+  let atImportResolvers = configToAtImportResolvers.get(config)
+  if (!atImportResolvers) {
+    atImportResolvers = createCSSResolvers(config)
+    configToAtImportResolvers.set(config, atImportResolvers)
+  }
+  return atImportResolvers
+}
+
+export async function compileCSS(
+  id: string,
+  code: string,
+  config: ResolvedConfig,
+  workerController: PreprocessorWorkerController,
+  urlReplacer?: CssUrlReplacer,
+): Promise<{
+  code: string
+  map?: SourceMapInput
+  ast?: PostCSS.Result
+  modules?: Record<string, string>
+  deps?: Set<string>
+}> {
+  if (config.css?.transformer === 'lightningcss') {
+    return compileLightningCSS(id, code, config, urlReplacer)
+  }
+
+  const { modules: modulesOptions, devSourcemap } = config.css || {}
+  const isModule = modulesOptions !== false && cssModuleRE.test(id)
+  // although at serve time it can work without processing, we do need to
+  // crawl them in order to register watch dependencies.
+  const needInlineImport = code.includes('@import')
+  const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code)
+  const lang = CSS_LANGS_RE.exec(id)?.[1] as CssLang | undefined
+  const postcssConfig = await resolvePostcssConfig(config)
+
+  // 1. plain css that needs no processing
+  if (
+    lang === 'css' &&
+    !postcssConfig &&
+    !isModule &&
+    !needInlineImport &&
+    !hasUrl
+  ) {
+    return { code, map: null }
+  }
+
+  let modules: Record<string, string> | undefined
+  const deps = new Set<string>()
+
+  // 2. pre-processors: sass etc.
+  let preprocessorMap: ExistingRawSourceMap | undefined
+  if (isPreProcessor(lang)) {
+    const preprocessorResult = await compileCSSPreprocessors(
+      id,
+      lang,
+      code,
+      config,
+      workerController,
+    )
+    code = preprocessorResult.code
+    preprocessorMap = preprocessorResult.map
+    preprocessorResult.deps?.forEach((dep) => deps.add(dep))
+  }
+
+  // 3. postcss
+  const atImportResolvers = getAtImportResolvers(config)
+  const postcssOptions = (postcssConfig && postcssConfig.options) || {}
+
+  const postcssPlugins =
+    postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : []
+
+  if (needInlineImport) {
+    postcssPlugins.unshift(
+      (await importPostcssImport()).default({
+        async resolve(id, basedir) {
+          const publicFile = checkPublicFile(id, config)
+          if (publicFile) {
+            return publicFile
+          }
+
+          const resolved = await atImportResolvers.css(
+            id,
+            path.join(basedir, '*'),
+          )
+
+          if (resolved) {
+            return path.resolve(resolved)
+          }
+
+          // postcss-import falls back to `resolve` dep if this is unresolved,
+          // but we've shimmed to remove the `resolve` dep to cut on bundle size.
+          // warn here to provide a better error message.
+          if (!path.isAbsolute(id)) {
+            config.logger.error(
+              colors.red(
+                `Unable to resolve \`@import "${id}"\` from ${basedir}`,
+              ),
+            )
+          }
+
+          return id
+        },
+        async load(id) {
+          const code = await fs.promises.readFile(id, 'utf-8')
+          const lang = CSS_LANGS_RE.exec(id)?.[1] as CssLang | undefined
+          if (isPreProcessor(lang)) {
+            const result = await compileCSSPreprocessors(
+              id,
+              lang,
+              code,
+              config,
+              workerController,
+            )
+            result.deps?.forEach((dep) => deps.add(dep))
+            // TODO: support source map
+            return result.code
+          }
+          return code
+        },
+        nameLayer(index) {
+          return `vite--anon-layer-${getHash(id)}-${index}`
+        },
+      }),
+    )
+  }
+
+  if (urlReplacer) {
+    postcssPlugins.push(
+      UrlRewritePostcssPlugin({
+        replacer: urlReplacer,
+        logger: config.logger,
+      }),
+    )
+  }
+
+  if (isModule) {
+    postcssPlugins.unshift(
+      (await importPostcssModules()).default({
+        ...modulesOptions,
+        localsConvention: modulesOptions?.localsConvention,
+        getJSON(
+          cssFileName: string,
+          _modules: Record<string, string>,
+          outputFileName: string,
+        ) {
+          modules = _modules
+          if (modulesOptions && typeof modulesOptions.getJSON === 'function') {
+            modulesOptions.getJSON(cssFileName, _modules, outputFileName)
+          }
+        },
+        async resolve(id: string, importer: string) {
+          for (const key of getCssResolversKeys(atImportResolvers)) {
+            const resolved = await atImportResolvers[key](id, importer)
+            if (resolved) {
+              return path.resolve(resolved)
+            }
+          }
+
+          return id
+        },
+      }),
+    )
+  }
+
+  if (!postcssPlugins.length) {
+    return {
+      code,
+      map: preprocessorMap,
+      deps,
+    }
+  }
+
+  let postcssResult: PostCSS.Result
+  try {
+    const source = removeDirectQuery(id)
+    const postcss = await importPostcss()
+    // postcss is an unbundled dep and should be lazy imported
+    postcssResult = await postcss.default(postcssPlugins).process(code, {
+      ...postcssOptions,
+      parser: lang === 'sss' ? loadSss(config.root) : postcssOptions.parser,
+      to: source,
+      from: source,
+      ...(devSourcemap
+        ? {
+            map: {
+              inline: false,
+              annotation: false,
+              // postcss may return virtual files
+              // we cannot obtain content of them, so this needs to be enabled
+              sourcesContent: true,
+              // when "prev: preprocessorMap", the result map may include duplicate filename in `postcssResult.map.sources`
+              // prev: preprocessorMap,
+            },
+          }
+        : {}),
+    })
+
+    // record CSS dependencies from @imports
+    for (const message of postcssResult.messages) {
+      if (message.type === 'dependency') {
+        deps.add(normalizePath(message.file as string))
+      } else if (message.type === 'dir-dependency') {
+        // https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#3-dependencies
+        const { dir, glob: globPattern = '**' } = message
+        const pattern =
+          glob.escapePath(normalizePath(path.resolve(path.dirname(id), dir))) +
+          `/` +
+          globPattern
+        const files = glob.sync(pattern, {
+          ignore: ['**/node_modules/**'],
+        })
+        for (let i = 0; i < files.length; i++) {
+          deps.add(files[i])
+        }
+      } else if (message.type === 'warning') {
+        const warning = message as PostCSS.Warning
+        let msg = `[vite:css] ${warning.text}`
+        msg += `\n${generateCodeFrame(
+          code,
+          {
+            line: warning.line,
+            column: warning.column - 1, // 1-based
+          },
+          warning.endLine !== undefined && warning.endColumn !== undefined
+            ? {
+                line: warning.endLine,
+                column: warning.endColumn - 1, // 1-based
+              }
+            : undefined,
+        )}`
+        config.logger.warn(colors.yellow(msg))
+      }
+    }
+  } catch (e) {
+    e.message = `[postcss] ${e.message}`
+    e.code = code
+    e.loc = {
+      file: e.file,
+      line: e.line,
+      column: e.column - 1, // 1-based
+    }
+    throw e
+  }
+
+  if (!devSourcemap) {
+    return {
+      ast: postcssResult,
+      code: postcssResult.css,
+      map: { mappings: '' },
+      modules,
+      deps,
+    }
+  }
+
+  const rawPostcssMap = postcssResult.map.toJSON()
+
+  const postcssMap = await formatPostcssSourceMap(
+    // version property of rawPostcssMap is declared as string
+    // but actually it is a number
+    rawPostcssMap as Omit<RawSourceMap, 'version'> as ExistingRawSourceMap,
+    cleanUrl(id),
+  )
+
+  return {
+    ast: postcssResult,
+    code: postcssResult.css,
+    map: combineSourcemapsIfExists(cleanUrl(id), postcssMap, preprocessorMap),
+    modules,
+    deps,
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/compileCSSPreprocessors.ts b/packages/vite/src/node/plugins/css/compileCSSPreprocessors.ts
new file mode 100644
index 000000000..289ca71a0
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/compileCSSPreprocessors.ts
@@ -0,0 +1,88 @@
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+
+
+export const enum PreprocessLang {
+  less = 'less',
+  sass = 'sass',
+  scss = 'scss',
+  styl = 'styl',
+  stylus = 'stylus',
+}
+
+export async function compileCSSPreprocessors(
+  id: string,
+  lang: PreprocessLang,
+  code: string,
+  config: ResolvedConfig,
+  workerController: PreprocessorWorkerController,
+): Promise<{ code: string; map?: ExistingRawSourceMap; deps?: Set<string> }> {
+  const { preprocessorOptions, devSourcemap } = config.css ?? {}
+  const atImportResolvers = getAtImportResolvers(config)
+
+  const preProcessor = workerController[lang]
+  let opts = (preprocessorOptions && preprocessorOptions[lang]) || {}
+  // support @import from node dependencies by default
+  switch (lang) {
+    case PreprocessLang.scss:
+    case PreprocessLang.sass:
+      opts = {
+        includePaths: ['node_modules'],
+        alias: config.resolve.alias,
+        ...opts,
+      }
+      break
+    case PreprocessLang.less:
+    case PreprocessLang.styl:
+    case PreprocessLang.stylus:
+      opts = {
+        paths: ['node_modules'],
+        alias: config.resolve.alias,
+        ...opts,
+      }
+  }
+  // important: set this for relative import resolving
+  opts.filename = cleanUrl(id)
+  opts.enableSourcemap = devSourcemap ?? false
+
+  const preprocessResult = await preProcessor(
+    code,
+    config.root,
+    opts,
+    atImportResolvers,
+  )
+  if (preprocessResult.error) {
+    throw preprocessResult.error
+  }
+
+  let deps: Set<string> | undefined
+  if (preprocessResult.deps) {
+    const normalizedFilename = normalizePath(opts.filename)
+    // sometimes sass registers the file itself as a dep
+    deps = new Set(
+      [...preprocessResult.deps].filter(
+        (dep) => normalizePath(dep) !== normalizedFilename,
+      ),
+    )
+  }
+
+  return {
+    code: preprocessResult.code,
+    map: combineSourcemapsIfExists(
+      opts.filename,
+      preprocessResult.map,
+      preprocessResult.additionalMap,
+    ),
+    deps,
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/compileLightningCSS.ts b/packages/vite/src/node/plugins/css/compileLightningCSS.ts
new file mode 100644
index 000000000..7041a99cb
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/compileLightningCSS.ts
@@ -0,0 +1,585 @@
+import fs from 'node:fs'
+import path from 'node:path'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { CSS_LANGS_RE } from 'packages/vite/src/node/constants';
+import glob from 'fast-glob'
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import colors from 'picocolors'
+import type * as PostCSS from 'postcss'
+import type { RawSourceMap } from '@ampproject/remapping'
+import { getHash } from 'packages/vite/src/node/utils';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { removeDirectQuery } from 'packages/vite/src/node/utils';
+import { generateCodeFrame } from 'packages/vite/src/node/utils';
+import { ResolveFn } from 'packages/vite/src/node/index';
+import { isExternalUrl } from 'packages/vite/src/node/utils';
+import { isDataUrl } from 'packages/vite/src/node/utils';
+
+
+const export decoder = new TextDecoder()
+
+const export cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`)
+
+const export styleAttrRE = /[?&]style-attr\b/
+
+export const enum PreprocessLang {
+  less = 'less',
+  sass = 'sass',
+  scss = 'scss',
+  styl = 'styl',
+  stylus = 'stylus',
+}
+
+export const enum PureCssLang {
+  css = 'css',
+}
+
+export const enum PostCssDialectLang {
+  sss = 'sugarss',
+}
+
+export type CssLang =
+  | keyof typeof PureCssLang
+  | keyof typeof PreprocessLang
+  | keyof typeof PostCssDialectLang
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export function getCssResolversKeys(
+  resolvers: CSSAtImportResolvers,
+): Array<keyof CSSAtImportResolvers> {
+  return Object.keys(resolvers) as unknown as Array<keyof CSSAtImportResolvers>
+}
+
+export async function compileCSSPreprocessors(
+  id: string,
+  lang: PreprocessLang,
+  code: string,
+  config: ResolvedConfig,
+  workerController: PreprocessorWorkerController,
+): Promise<{ code: string; map?: ExistingRawSourceMap; deps?: Set<string> }> {
+  const { preprocessorOptions, devSourcemap } = config.css ?? {}
+  const atImportResolvers = getAtImportResolvers(config)
+
+  const preProcessor = workerController[lang]
+  let opts = (preprocessorOptions && preprocessorOptions[lang]) || {}
+  // support @import from node dependencies by default
+  switch (lang) {
+    case PreprocessLang.scss:
+    case PreprocessLang.sass:
+      opts = {
+        includePaths: ['node_modules'],
+        alias: config.resolve.alias,
+        ...opts,
+      }
+      break
+    case PreprocessLang.less:
+    case PreprocessLang.styl:
+    case PreprocessLang.stylus:
+      opts = {
+        paths: ['node_modules'],
+        alias: config.resolve.alias,
+        ...opts,
+      }
+  }
+  // important: set this for relative import resolving
+  opts.filename = cleanUrl(id)
+  opts.enableSourcemap = devSourcemap ?? false
+
+  const preprocessResult = await preProcessor(
+    code,
+    config.root,
+    opts,
+    atImportResolvers,
+  )
+  if (preprocessResult.error) {
+    throw preprocessResult.error
+  }
+
+  let deps: Set<string> | undefined
+  if (preprocessResult.deps) {
+    const normalizedFilename = normalizePath(opts.filename)
+    // sometimes sass registers the file itself as a dep
+    deps = new Set(
+      [...preprocessResult.deps].filter(
+        (dep) => normalizePath(dep) !== normalizedFilename,
+      ),
+    )
+  }
+
+  return {
+    code: preprocessResult.code,
+    map: combineSourcemapsIfExists(
+      opts.filename,
+      preprocessResult.map,
+      preprocessResult.additionalMap,
+    ),
+    deps,
+  }
+}
+
+export function createCSSResolvers(config: ResolvedConfig): CSSAtImportResolvers {
+  let cssResolve: ResolveFn | undefined
+  let sassResolve: ResolveFn | undefined
+  let lessResolve: ResolveFn | undefined
+  return {
+    get css() {
+      return (
+        cssResolve ||
+        (cssResolve = config.createResolver({
+          extensions: ['.css'],
+          mainFields: ['style'],
+          conditions: ['style'],
+          tryIndex: false,
+          preferRelative: true,
+        }))
+      )
+    },
+
+    get sass() {
+      return (
+        sassResolve ||
+        (sassResolve = config.createResolver({
+          extensions: ['.scss', '.sass', '.css'],
+          mainFields: ['sass', 'style'],
+          conditions: ['sass', 'style'],
+          tryIndex: true,
+          tryPrefix: '_',
+          preferRelative: true,
+        }))
+      )
+    },
+
+    get less() {
+      return (
+        lessResolve ||
+        (lessResolve = config.createResolver({
+          extensions: ['.less', '.css'],
+          mainFields: ['less', 'style'],
+          conditions: ['less', 'style'],
+          tryIndex: false,
+          preferRelative: true,
+        }))
+      )
+    },
+  }
+}
+
+const export configToAtImportResolvers = new WeakMap<
+  ResolvedConfig,
+  CSSAtImportResolvers
+>()
+
+export function getAtImportResolvers(config: ResolvedConfig) {
+  let atImportResolvers = configToAtImportResolvers.get(config)
+  if (!atImportResolvers) {
+    atImportResolvers = createCSSResolvers(config)
+    configToAtImportResolvers.set(config, atImportResolvers)
+  }
+  return atImportResolvers
+}
+
+export async function compileCSS(
+  id: string,
+  code: string,
+  config: ResolvedConfig,
+  workerController: PreprocessorWorkerController,
+  urlReplacer?: CssUrlReplacer,
+): Promise<{
+  code: string
+  map?: SourceMapInput
+  ast?: PostCSS.Result
+  modules?: Record<string, string>
+  deps?: Set<string>
+}> {
+  if (config.css?.transformer === 'lightningcss') {
+    return compileLightningCSS(id, code, config, urlReplacer)
+  }
+
+  const { modules: modulesOptions, devSourcemap } = config.css || {}
+  const isModule = modulesOptions !== false && cssModuleRE.test(id)
+  // although at serve time it can work without processing, we do need to
+  // crawl them in order to register watch dependencies.
+  const needInlineImport = code.includes('@import')
+  const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code)
+  const lang = CSS_LANGS_RE.exec(id)?.[1] as CssLang | undefined
+  const postcssConfig = await resolvePostcssConfig(config)
+
+  // 1. plain css that needs no processing
+  if (
+    lang === 'css' &&
+    !postcssConfig &&
+    !isModule &&
+    !needInlineImport &&
+    !hasUrl
+  ) {
+    return { code, map: null }
+  }
+
+  let modules: Record<string, string> | undefined
+  const deps = new Set<string>()
+
+  // 2. pre-processors: sass etc.
+  let preprocessorMap: ExistingRawSourceMap | undefined
+  if (isPreProcessor(lang)) {
+    const preprocessorResult = await compileCSSPreprocessors(
+      id,
+      lang,
+      code,
+      config,
+      workerController,
+    )
+    code = preprocessorResult.code
+    preprocessorMap = preprocessorResult.map
+    preprocessorResult.deps?.forEach((dep) => deps.add(dep))
+  }
+
+  // 3. postcss
+  const atImportResolvers = getAtImportResolvers(config)
+  const postcssOptions = (postcssConfig && postcssConfig.options) || {}
+
+  const postcssPlugins =
+    postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : []
+
+  if (needInlineImport) {
+    postcssPlugins.unshift(
+      (await importPostcssImport()).default({
+        async resolve(id, basedir) {
+          const publicFile = checkPublicFile(id, config)
+          if (publicFile) {
+            return publicFile
+          }
+
+          const resolved = await atImportResolvers.css(
+            id,
+            path.join(basedir, '*'),
+          )
+
+          if (resolved) {
+            return path.resolve(resolved)
+          }
+
+          // postcss-import falls back to `resolve` dep if this is unresolved,
+          // but we've shimmed to remove the `resolve` dep to cut on bundle size.
+          // warn here to provide a better error message.
+          if (!path.isAbsolute(id)) {
+            config.logger.error(
+              colors.red(
+                `Unable to resolve \`@import "${id}"\` from ${basedir}`,
+              ),
+            )
+          }
+
+          return id
+        },
+        async load(id) {
+          const code = await fs.promises.readFile(id, 'utf-8')
+          const lang = CSS_LANGS_RE.exec(id)?.[1] as CssLang | undefined
+          if (isPreProcessor(lang)) {
+            const result = await compileCSSPreprocessors(
+              id,
+              lang,
+              code,
+              config,
+              workerController,
+            )
+            result.deps?.forEach((dep) => deps.add(dep))
+            // TODO: support source map
+            return result.code
+          }
+          return code
+        },
+        nameLayer(index) {
+          return `vite--anon-layer-${getHash(id)}-${index}`
+        },
+      }),
+    )
+  }
+
+  if (urlReplacer) {
+    postcssPlugins.push(
+      UrlRewritePostcssPlugin({
+        replacer: urlReplacer,
+        logger: config.logger,
+      }),
+    )
+  }
+
+  if (isModule) {
+    postcssPlugins.unshift(
+      (await importPostcssModules()).default({
+        ...modulesOptions,
+        localsConvention: modulesOptions?.localsConvention,
+        getJSON(
+          cssFileName: string,
+          _modules: Record<string, string>,
+          outputFileName: string,
+        ) {
+          modules = _modules
+          if (modulesOptions && typeof modulesOptions.getJSON === 'function') {
+            modulesOptions.getJSON(cssFileName, _modules, outputFileName)
+          }
+        },
+        async resolve(id: string, importer: string) {
+          for (const key of getCssResolversKeys(atImportResolvers)) {
+            const resolved = await atImportResolvers[key](id, importer)
+            if (resolved) {
+              return path.resolve(resolved)
+            }
+          }
+
+          return id
+        },
+      }),
+    )
+  }
+
+  if (!postcssPlugins.length) {
+    return {
+      code,
+      map: preprocessorMap,
+      deps,
+    }
+  }
+
+  let postcssResult: PostCSS.Result
+  try {
+    const source = removeDirectQuery(id)
+    const postcss = await importPostcss()
+    // postcss is an unbundled dep and should be lazy imported
+    postcssResult = await postcss.default(postcssPlugins).process(code, {
+      ...postcssOptions,
+      parser: lang === 'sss' ? loadSss(config.root) : postcssOptions.parser,
+      to: source,
+      from: source,
+      ...(devSourcemap
+        ? {
+            map: {
+              inline: false,
+              annotation: false,
+              // postcss may return virtual files
+              // we cannot obtain content of them, so this needs to be enabled
+              sourcesContent: true,
+              // when "prev: preprocessorMap", the result map may include duplicate filename in `postcssResult.map.sources`
+              // prev: preprocessorMap,
+            },
+          }
+        : {}),
+    })
+
+    // record CSS dependencies from @imports
+    for (const message of postcssResult.messages) {
+      if (message.type === 'dependency') {
+        deps.add(normalizePath(message.file as string))
+      } else if (message.type === 'dir-dependency') {
+        // https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#3-dependencies
+        const { dir, glob: globPattern = '**' } = message
+        const pattern =
+          glob.escapePath(normalizePath(path.resolve(path.dirname(id), dir))) +
+          `/` +
+          globPattern
+        const files = glob.sync(pattern, {
+          ignore: ['**/node_modules/**'],
+        })
+        for (let i = 0; i < files.length; i++) {
+          deps.add(files[i])
+        }
+      } else if (message.type === 'warning') {
+        const warning = message as PostCSS.Warning
+        let msg = `[vite:css] ${warning.text}`
+        msg += `\n${generateCodeFrame(
+          code,
+          {
+            line: warning.line,
+            column: warning.column - 1, // 1-based
+          },
+          warning.endLine !== undefined && warning.endColumn !== undefined
+            ? {
+                line: warning.endLine,
+                column: warning.endColumn - 1, // 1-based
+              }
+            : undefined,
+        )}`
+        config.logger.warn(colors.yellow(msg))
+      }
+    }
+  } catch (e) {
+    e.message = `[postcss] ${e.message}`
+    e.code = code
+    e.loc = {
+      file: e.file,
+      line: e.line,
+      column: e.column - 1, // 1-based
+    }
+    throw e
+  }
+
+  if (!devSourcemap) {
+    return {
+      ast: postcssResult,
+      code: postcssResult.css,
+      map: { mappings: '' },
+      modules,
+      deps,
+    }
+  }
+
+  const rawPostcssMap = postcssResult.map.toJSON()
+
+  const postcssMap = await formatPostcssSourceMap(
+    // version property of rawPostcssMap is declared as string
+    // but actually it is a number
+    rawPostcssMap as Omit<RawSourceMap, 'version'> as ExistingRawSourceMap,
+    cleanUrl(id),
+  )
+
+  return {
+    ast: postcssResult,
+    code: postcssResult.css,
+    map: combineSourcemapsIfExists(cleanUrl(id), postcssMap, preprocessorMap),
+    modules,
+    deps,
+  }
+}
+
+export type CssUrlReplacer = (
+  url: string,
+  importer?: string,
+) => string | Promise<string>
+
+const export functionCallRE = /^[A-Z_][\w-]*\(/i
+
+export function skipUrlReplacer(rawUrl: string) {
+  return (
+    isExternalUrl(rawUrl) ||
+    isDataUrl(rawUrl) ||
+    rawUrl[0] === '#' ||
+    functionCallRE.test(rawUrl)
+  )
+}
+
+export async function compileLightningCSS(
+  id: string,
+  src: string,
+  config: ResolvedConfig,
+  urlReplacer?: CssUrlReplacer,
+): ReturnType<typeof compileCSS> {
+  const deps = new Set<string>()
+  // Relative path is needed to get stable hash when using CSS modules
+  const filename = cleanUrl(path.relative(config.root, id))
+  const toAbsolute = (filePath: string) =>
+    path.isAbsolute(filePath) ? filePath : path.join(config.root, filePath)
+
+  const res = styleAttrRE.test(id)
+    ? (await importLightningCSS()).transformStyleAttribute({
+        filename,
+        code: Buffer.from(src),
+        targets: config.css?.lightningcss?.targets,
+        minify: config.isProduction && !!config.build.cssMinify,
+        analyzeDependencies: true,
+      })
+    : await (
+        await importLightningCSS()
+      ).bundleAsync({
+        ...config.css?.lightningcss,
+        filename,
+        resolver: {
+          read(filePath) {
+            if (filePath === filename) {
+              return src
+            }
+            // This happens with html-proxy (#13776)
+            if (!filePath.endsWith('.css')) {
+              return src
+            }
+            return fs.readFileSync(toAbsolute(filePath), 'utf-8')
+          },
+          async resolve(id, from) {
+            const publicFile = checkPublicFile(id, config)
+            if (publicFile) {
+              return publicFile
+            }
+
+            const resolved = await getAtImportResolvers(config).css(
+              id,
+              toAbsolute(from),
+            )
+
+            if (resolved) {
+              deps.add(resolved)
+              return resolved
+            }
+            return id
+          },
+        },
+        minify: config.isProduction && !!config.build.cssMinify,
+        sourceMap:
+          config.command === 'build'
+            ? !!config.build.sourcemap
+            : config.css?.devSourcemap,
+        analyzeDependencies: true,
+        cssModules: cssModuleRE.test(id)
+          ? (config.css?.lightningcss?.cssModules ?? true)
+          : undefined,
+      })
+
+  // NodeJS res.code = Buffer
+  // Deno res.code = Uint8Array
+  // For correct decode compiled css need to use TextDecoder
+  let css = decoder.decode(res.code)
+  for (const dep of res.dependencies!) {
+    switch (dep.type) {
+      case 'url':
+        if (skipUrlReplacer(dep.url)) {
+          css = css.replace(dep.placeholder, () => dep.url)
+          break
+        }
+        deps.add(dep.url)
+        if (urlReplacer) {
+          const replaceUrl = await urlReplacer(dep.url, id)
+          css = css.replace(dep.placeholder, () => replaceUrl)
+        } else {
+          css = css.replace(dep.placeholder, () => dep.url)
+        }
+        break
+      default:
+        throw new Error(`Unsupported dependency type: ${dep.type}`)
+    }
+  }
+
+  let modules: Record<string, string> | undefined
+  if ('exports' in res && res.exports) {
+    modules = {}
+    // https://github.com/parcel-bundler/lightningcss/issues/291
+    const sortedEntries = Object.entries(res.exports).sort((a, b) =>
+      a[0].localeCompare(b[0]),
+    )
+    for (const [key, value] of sortedEntries) {
+      modules[key] = value.name
+      // https://lightningcss.dev/css-modules.html#class-composition
+      for (const c of value.composes) {
+        modules[key] += ' ' + c.name
+      }
+    }
+  }
+
+  return {
+    code: css,
+    map: 'map' in res ? res.map?.toString() : undefined,
+    deps,
+    modules,
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/cssAnalysisPlugin.ts b/packages/vite/src/node/plugins/css/cssAnalysisPlugin.ts
new file mode 100644
index 000000000..5df79c534
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/cssAnalysisPlugin.ts
@@ -0,0 +1,84 @@
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { SPECIAL_QUERY_RE } from 'packages/vite/src/node/constants';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { stripBase } from 'packages/vite/src/node/utils';
+import { fileToUrl } from 'packages/vite/src/node/plugins/asset';
+import { CSS_LANGS_RE } from 'packages/vite/src/node/constants';
+
+
+const export commonjsProxyRE = /\?commonjs-proxy/
+
+const isCSSRequest = (request: string): boolean =>
+  CSS_LANGS_RE.test(request)
+
+export function cssAnalysisPlugin(config: ResolvedConfig): Plugin {
+  let server: ViteDevServer
+
+  return {
+    name: 'vite:css-analysis',
+
+    configureServer(_server) {
+      server = _server
+    },
+
+    async transform(_, id, options) {
+      if (
+        !isCSSRequest(id) ||
+        commonjsProxyRE.test(id) ||
+        SPECIAL_QUERY_RE.test(id)
+      ) {
+        return
+      }
+
+      const ssr = options?.ssr === true
+      const { moduleGraph } = server
+      const thisModule = moduleGraph.getModuleById(id)
+
+      // Handle CSS @import dependency HMR and other added modules via this.addWatchFile.
+      // JS-related HMR is handled in the import-analysis plugin.
+      if (thisModule) {
+        // CSS modules cannot self-accept since it exports values
+        const isSelfAccepting =
+          !cssModulesCache.get(config)?.get(id) &&
+          !inlineRE.test(id) &&
+          !htmlProxyRE.test(id)
+        // attached by pluginContainer.addWatchFile
+        const pluginImports = (this as unknown as TransformPluginContext)
+          ._addedImports
+        if (pluginImports) {
+          // record deps in the module graph so edits to @import css can trigger
+          // main import to hot update
+          const depModules = new Set<string | ModuleNode>()
+          const devBase = config.base
+          for (const file of pluginImports) {
+            depModules.add(
+              isCSSRequest(file)
+                ? moduleGraph.createFileOnlyEntry(file)
+                : await moduleGraph.ensureEntryFromUrl(
+                    stripBase(
+                      await fileToUrl(file, config, this),
+                      (config.server?.origin ?? '') + devBase,
+                    ),
+                    ssr,
+                  ),
+            )
+          }
+          moduleGraph.updateModuleInfo(
+            thisModule,
+            depModules,
+            null,
+            // The root CSS proxy module is self-accepting and should not
+            // have an explicit accept list
+            new Set(),
+            null,
+            isSelfAccepting,
+            ssr,
+          )
+        } else {
+          thisModule.isSelfAccepting = isSelfAccepting
+        }
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/cssPlugin.ts b/packages/vite/src/node/plugins/css/cssPlugin.ts
new file mode 100644
index 000000000..520fd5f6f
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/cssPlugin.ts
@@ -0,0 +1,177 @@
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import { SPECIAL_QUERY_RE } from 'packages/vite/src/node/constants';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { urlRE } from 'packages/vite/src/node/utils';
+import { CSS_LANGS_RE } from 'packages/vite/src/node/constants';
+
+
+const export commonjsProxyRE = /\?commonjs-proxy/
+
+const isCSSRequest = (request: string): boolean =>
+  CSS_LANGS_RE.test(request)
+
+const export cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`)
+
+const isModuleCSSRequest = (request: string): boolean =>
+  cssModuleRE.test(request)
+
+const export cssModulesCache = new WeakMap<
+  ResolvedConfig,
+  Map<string, Record<string, string>>
+>()
+
+export const removedPureCssFilesCache = new WeakMap<
+  ResolvedConfig,
+  Map<string, RenderedChunk>
+>()
+
+/**
+ * Plugin applied before user plugins
+ */
+export function cssPlugin(config: ResolvedConfig): Plugin {
+  const isBuild = config.command === 'build'
+  let moduleCache: Map<string, Record<string, string>>
+
+  const resolveUrl = config.createResolver({
+    preferRelative: true,
+    tryIndex: false,
+    extensions: [],
+  })
+
+  let preprocessorWorkerController: PreprocessorWorkerController | undefined
+
+  // warm up cache for resolved postcss config
+  if (config.css?.transformer !== 'lightningcss') {
+    resolvePostcssConfig(config)
+  }
+
+  return {
+    name: 'vite:css',
+
+    buildStart() {
+      // Ensure a new cache for every build (i.e. rebuilding in watch mode)
+      moduleCache = new Map<string, Record<string, string>>()
+      cssModulesCache.set(config, moduleCache)
+
+      removedPureCssFilesCache.set(config, new Map<string, RenderedChunk>())
+
+      preprocessorWorkerController = createPreprocessorWorkerController(
+        normalizeMaxWorkers(config.css.preprocessorMaxWorkers),
+      )
+      preprocessorWorkerControllerCache.set(
+        config,
+        preprocessorWorkerController,
+      )
+    },
+
+    buildEnd() {
+      preprocessorWorkerController?.close()
+    },
+
+    async load(id) {
+      if (!isCSSRequest(id)) return
+
+      if (urlRE.test(id)) {
+        if (isModuleCSSRequest(id)) {
+          throw new Error(
+            `?url is not supported with CSS modules. (tried to import ${JSON.stringify(
+              id,
+            )})`,
+          )
+        }
+
+        // *.css?url
+        // in dev, it's handled by assets plugin.
+        if (isBuild) {
+          id = injectQuery(removeUrlQuery(id), 'transform-only')
+          return (
+            `import ${JSON.stringify(id)};` +
+            `export default "__VITE_CSS_URL__${Buffer.from(id).toString(
+              'hex',
+            )}__"`
+          )
+        }
+      }
+    },
+
+    async transform(raw, id) {
+      if (
+        !isCSSRequest(id) ||
+        commonjsProxyRE.test(id) ||
+        SPECIAL_QUERY_RE.test(id)
+      ) {
+        return
+      }
+      const urlReplacer: CssUrlReplacer = async (url, importer) => {
+        const decodedUrl = decodeURI(url)
+        if (checkPublicFile(decodedUrl, config)) {
+          if (encodePublicUrlsInCSS(config)) {
+            return publicFileToBuiltUrl(decodedUrl, config)
+          } else {
+            return joinUrlSegments(config.base, decodedUrl)
+          }
+        }
+        const [id, fragment] = decodedUrl.split('#')
+        let resolved = await resolveUrl(id, importer)
+        if (resolved) {
+          if (fragment) resolved += '#' + fragment
+          return fileToUrl(resolved, config, this)
+        }
+        if (config.command === 'build') {
+          const isExternal = config.build.rollupOptions.external
+            ? resolveUserExternal(
+                config.build.rollupOptions.external,
+                decodedUrl, // use URL as id since id could not be resolved
+                id,
+                false,
+              )
+            : false
+
+          if (!isExternal) {
+            // #9800 If we cannot resolve the css url, leave a warning.
+            config.logger.warnOnce(
+              `\n${decodedUrl} referenced in ${id} didn't resolve at build time, it will remain unchanged to be resolved at runtime`,
+            )
+          }
+        }
+        return url
+      }
+
+      const {
+        code: css,
+        modules,
+        deps,
+        map,
+      } = await compileCSS(
+        id,
+        raw,
+        config,
+        preprocessorWorkerController!,
+        urlReplacer,
+      )
+      if (modules) {
+        moduleCache.set(id, modules)
+      }
+
+      if (deps) {
+        for (const file of deps) {
+          this.addWatchFile(file)
+        }
+      }
+
+      return {
+        code: css,
+        map,
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/cssPostPlugin.ts b/packages/vite/src/node/plugins/css/cssPostPlugin.ts
new file mode 100644
index 000000000..9b6ae36c6
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/cssPostPlugin.ts
@@ -0,0 +1,602 @@
+import path from 'node:path'
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import { SPECIAL_QUERY_RE } from 'packages/vite/src/node/constants';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { getHash } from 'packages/vite/src/node/utils';
+import { createSerialPromiseQueue } from 'packages/vite/src/node/utils';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { addToHTMLProxyTransformResult } from 'packages/vite/src/node/plugins/html';
+import { CSS_LANGS_RE } from 'packages/vite/src/node/constants';
+
+
+const export cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`)
+
+const export commonjsProxyRE = /\?commonjs-proxy/
+
+const export styleAttrRE = /[?&]style-attr\b/
+
+const export transformOnlyRE = /[?&]transform-only\b/
+
+const export cssBundleName = 'style.css'
+
+const isCSSRequest = (request: string): boolean =>
+  CSS_LANGS_RE.test(request)
+
+const export directRequestRE = /[?&]direct\b/
+
+const isDirectCSSRequest = (request: string): boolean =>
+  CSS_LANGS_RE.test(request) && directRequestRE.test(request)
+
+const export cssUrlAssetRE = /__VITE_CSS_URL__([\da-f]+)__/g
+
+/**
+ * Plugin applied after user plugins
+ */
+export function cssPostPlugin(config: ResolvedConfig): Plugin {
+  // styles initialization in buildStart causes a styling loss in watch
+  const styles: Map<string, string> = new Map<string, string>()
+  // queue to emit css serially to guarantee the files are emitted in a deterministic order
+  let codeSplitEmitQueue = createSerialPromiseQueue<string>()
+  const urlEmitQueue = createSerialPromiseQueue<unknown>()
+  let pureCssChunks: Set<RenderedChunk>
+
+  // when there are multiple rollup outputs and extracting CSS, only emit once,
+  // since output formats have no effect on the generated CSS.
+  let hasEmitted = false
+  let chunkCSSMap: Map<string, string>
+
+  const rollupOptionsOutput = config.build.rollupOptions.output
+  const assetFileNames = (
+    Array.isArray(rollupOptionsOutput)
+      ? rollupOptionsOutput[0]
+      : rollupOptionsOutput
+  )?.assetFileNames
+  const getCssAssetDirname = (cssAssetName: string) => {
+    const cssAssetNameDir = path.dirname(cssAssetName)
+    if (!assetFileNames) {
+      return path.join(config.build.assetsDir, cssAssetNameDir)
+    } else if (typeof assetFileNames === 'string') {
+      return path.join(path.dirname(assetFileNames), cssAssetNameDir)
+    } else {
+      return path.dirname(
+        assetFileNames({
+          name: cssAssetName,
+          type: 'asset',
+          source: '/* vite internal call, ignore */',
+        }),
+      )
+    }
+  }
+
+  return {
+    name: 'vite:css-post',
+
+    renderStart() {
+      // Ensure new caches for every build (i.e. rebuilding in watch mode)
+      pureCssChunks = new Set<RenderedChunk>()
+      hasEmitted = false
+      chunkCSSMap = new Map()
+      codeSplitEmitQueue = createSerialPromiseQueue()
+    },
+
+    async transform(css, id, options) {
+      if (
+        !isCSSRequest(id) ||
+        commonjsProxyRE.test(id) ||
+        SPECIAL_QUERY_RE.test(id)
+      ) {
+        return
+      }
+
+      css = stripBomTag(css)
+
+      // cache css compile result to map
+      // and then use the cache replace inline-style-flag
+      // when `generateBundle` in vite:build-html plugin and devHtmlHook
+      const inlineCSS = inlineCSSRE.test(id)
+      const isHTMLProxy = htmlProxyRE.test(id)
+      if (inlineCSS && isHTMLProxy) {
+        if (styleAttrRE.test(id)) {
+          css = css.replace(/"/g, '&quot;')
+        }
+        const index = htmlProxyIndexRE.exec(id)?.[1]
+        if (index == null) {
+          throw new Error(`HTML proxy index in "${id}" not found`)
+        }
+        addToHTMLProxyTransformResult(
+          `${getHash(cleanUrl(id))}_${Number.parseInt(index)}`,
+          css,
+        )
+        return `export default ''`
+      }
+
+      const inlined = inlineRE.test(id)
+      const modules = cssModulesCache.get(config)!.get(id)
+
+      // #6984, #7552
+      // `foo.module.css` => modulesCode
+      // `foo.module.css?inline` => cssContent
+      const modulesCode =
+        modules &&
+        !inlined &&
+        dataToEsm(modules, { namedExports: true, preferConst: true })
+
+      if (config.command === 'serve') {
+        const getContentWithSourcemap = async (content: string) => {
+          if (config.css?.devSourcemap) {
+            const sourcemap = this.getCombinedSourcemap()
+            if (sourcemap.mappings) {
+              await injectSourcesContent(sourcemap, cleanUrl(id), config.logger)
+            }
+            return getCodeWithSourcemap('css', content, sourcemap)
+          }
+          return content
+        }
+
+        if (isDirectCSSRequest(id)) {
+          return null
+        }
+        // server only
+        if (options?.ssr) {
+          return modulesCode || `export default ${JSON.stringify(css)}`
+        }
+        if (inlined) {
+          return `export default ${JSON.stringify(css)}`
+        }
+
+        const cssContent = await getContentWithSourcemap(css)
+        const code = [
+          `import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(
+            path.posix.join(config.base, CLIENT_PUBLIC_PATH),
+          )}`,
+          `const __vite__id = ${JSON.stringify(id)}`,
+          `const __vite__css = ${JSON.stringify(cssContent)}`,
+          `__vite__updateStyle(__vite__id, __vite__css)`,
+          // css modules exports change on edit so it can't self accept
+          `${modulesCode || 'import.meta.hot.accept()'}`,
+          `import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`,
+        ].join('\n')
+        return { code, map: { mappings: '' } }
+      }
+
+      // build CSS handling ----------------------------------------------------
+
+      // record css
+      if (!inlined) {
+        styles.set(id, css)
+      }
+
+      let code: string
+      if (modulesCode) {
+        code = modulesCode
+      } else if (inlined) {
+        let content = css
+        if (config.build.cssMinify) {
+          content = await minifyCSS(content, config, true)
+        }
+        code = `export default ${JSON.stringify(content)}`
+      } else {
+        // empty module when it's not a CSS module nor `?inline`
+        code = ''
+      }
+
+      return {
+        code,
+        map: { mappings: '' },
+        // avoid the css module from being tree-shaken so that we can retrieve
+        // it in renderChunk()
+        moduleSideEffects: modulesCode || inlined ? false : 'no-treeshake',
+      }
+    },
+
+    async renderChunk(code, chunk, opts) {
+      let chunkCSS = ''
+      // the chunk is empty if it's a dynamic entry chunk that only contains a CSS import
+      const isJsChunkEmpty = code === '' && !chunk.isEntry
+      let isPureCssChunk = true
+      const ids = Object.keys(chunk.modules)
+      for (const id of ids) {
+        if (styles.has(id)) {
+          // ?transform-only is used for ?url and shouldn't be included in normal CSS chunks
+          if (!transformOnlyRE.test(id)) {
+            chunkCSS += styles.get(id)
+            // a css module contains JS, so it makes this not a pure css chunk
+            if (cssModuleRE.test(id)) {
+              isPureCssChunk = false
+            }
+          }
+        } else if (!isJsChunkEmpty) {
+          // if the module does not have a style, then it's not a pure css chunk.
+          // this is true because in the `transform` hook above, only modules
+          // that are css gets added to the `styles` map.
+          isPureCssChunk = false
+        }
+      }
+
+      const publicAssetUrlMap = publicAssetUrlCache.get(config)!
+
+      // resolve asset URL placeholders to their built file URLs
+      const resolveAssetUrlsInCss = (
+        chunkCSS: string,
+        cssAssetName: string,
+      ) => {
+        const encodedPublicUrls = encodePublicUrlsInCSS(config)
+
+        const relative = config.base === './' || config.base === ''
+        const cssAssetDirname =
+          encodedPublicUrls || relative
+            ? slash(getCssAssetDirname(cssAssetName))
+            : undefined
+
+        const toRelative = (filename: string) => {
+          // relative base + extracted CSS
+          const relativePath = path.posix.relative(cssAssetDirname!, filename)
+          return relativePath[0] === '.' ? relativePath : './' + relativePath
+        }
+
+        // replace asset url references with resolved url.
+        chunkCSS = chunkCSS.replace(assetUrlRE, (_, fileHash, postfix = '') => {
+          const filename = this.getFileName(fileHash) + postfix
+          chunk.viteMetadata!.importedAssets.add(cleanUrl(filename))
+          return encodeURIPath(
+            toOutputFilePathInCss(
+              filename,
+              'asset',
+              cssAssetName,
+              'css',
+              config,
+              toRelative,
+            ),
+          )
+        })
+        // resolve public URL from CSS paths
+        if (encodedPublicUrls) {
+          const relativePathToPublicFromCSS = path.posix.relative(
+            cssAssetDirname!,
+            '',
+          )
+          chunkCSS = chunkCSS.replace(publicAssetUrlRE, (_, hash) => {
+            const publicUrl = publicAssetUrlMap.get(hash)!.slice(1)
+            return encodeURIPath(
+              toOutputFilePathInCss(
+                publicUrl,
+                'public',
+                cssAssetName,
+                'css',
+                config,
+                () => `${relativePathToPublicFromCSS}/${publicUrl}`,
+              ),
+            )
+          })
+        }
+        return chunkCSS
+      }
+
+      function ensureFileExt(name: string, ext: string) {
+        return normalizePath(
+          path.format({ ...path.parse(name), base: undefined, ext }),
+        )
+      }
+
+      let s: MagicString | undefined
+      const urlEmitTasks: Array<{
+        cssAssetName: string
+        originalFilename: string
+        content: string
+        start: number
+        end: number
+      }> = []
+
+      if (code.includes('__VITE_CSS_URL__')) {
+        let match: RegExpExecArray | null
+        cssUrlAssetRE.lastIndex = 0
+        while ((match = cssUrlAssetRE.exec(code))) {
+          const [full, idHex] = match
+          const id = Buffer.from(idHex, 'hex').toString()
+          const originalFilename = cleanUrl(id)
+          const cssAssetName = ensureFileExt(
+            path.basename(originalFilename),
+            '.css',
+          )
+          if (!styles.has(id)) {
+            throw new Error(
+              `css content for ${JSON.stringify(id)} was not found`,
+            )
+          }
+
+          let cssContent = styles.get(id)!
+
+          cssContent = resolveAssetUrlsInCss(cssContent, cssAssetName)
+
+          urlEmitTasks.push({
+            cssAssetName,
+            originalFilename,
+            content: cssContent,
+            start: match.index,
+            end: match.index + full.length,
+          })
+        }
+      }
+
+      // should await even if this chunk does not include __VITE_CSS_URL__
+      // so that code after this line runs in the same order
+      await urlEmitQueue.run(async () =>
+        Promise.all(
+          urlEmitTasks.map(async (info) => {
+            info.content = await finalizeCss(info.content, true, config)
+          }),
+        ),
+      )
+      if (urlEmitTasks.length > 0) {
+        const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(
+          opts.format,
+          config.isWorker,
+        )
+        s ||= new MagicString(code)
+
+        for (const {
+          cssAssetName,
+          originalFilename,
+          content,
+          start,
+          end,
+        } of urlEmitTasks) {
+          const referenceId = this.emitFile({
+            name: cssAssetName,
+            type: 'asset',
+            source: content,
+          })
+          generatedAssets
+            .get(config)!
+            .set(referenceId, { originalName: originalFilename })
+
+          const filename = this.getFileName(referenceId)
+          chunk.viteMetadata!.importedAssets.add(cleanUrl(filename))
+          const replacement = toOutputFilePathInJS(
+            filename,
+            'asset',
+            chunk.fileName,
+            'js',
+            config,
+            toRelativeRuntime,
+          )
+          const replacementString =
+            typeof replacement === 'string'
+              ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1)
+              : `"+${replacement.runtime}+"`
+          s.update(start, end, replacementString)
+        }
+      }
+
+      if (chunkCSS) {
+        if (isPureCssChunk && (opts.format === 'es' || opts.format === 'cjs')) {
+          // this is a shared CSS-only chunk that is empty.
+          pureCssChunks.add(chunk)
+        }
+
+        if (config.build.cssCodeSplit) {
+          if (opts.format === 'es' || opts.format === 'cjs') {
+            const isEntry = chunk.isEntry && isPureCssChunk
+            const cssFullAssetName = ensureFileExt(chunk.name, '.css')
+            // if facadeModuleId doesn't exist or doesn't have a CSS extension,
+            // that means a JS entry file imports a CSS file.
+            // in this case, only use the filename for the CSS chunk name like JS chunks.
+            const cssAssetName =
+              chunk.isEntry &&
+              (!chunk.facadeModuleId || !isCSSRequest(chunk.facadeModuleId))
+                ? path.basename(cssFullAssetName)
+                : cssFullAssetName
+            const originalFilename = getChunkOriginalFileName(
+              chunk,
+              config.root,
+              opts.format,
+            )
+
+            chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssAssetName)
+
+            // wait for previous tasks as well
+            chunkCSS = await codeSplitEmitQueue.run(async () => {
+              return finalizeCss(chunkCSS, true, config)
+            })
+
+            // emit corresponding css file
+            const referenceId = this.emitFile({
+              name: cssAssetName,
+              type: 'asset',
+              source: chunkCSS,
+            })
+            generatedAssets
+              .get(config)!
+              .set(referenceId, { originalName: originalFilename, isEntry })
+            chunk.viteMetadata!.importedCss.add(this.getFileName(referenceId))
+          } else if (!config.build.ssr) {
+            // legacy build and inline css
+
+            // Entry chunk CSS will be collected into `chunk.viteMetadata.importedCss`
+            // and injected later by the `'vite:build-html'` plugin into the `index.html`
+            // so it will be duplicated. (https://github.com/vitejs/vite/issues/2062#issuecomment-782388010)
+            // But because entry chunk can be imported by dynamic import,
+            // we shouldn't remove the inlined CSS. (#10285)
+
+            chunkCSS = await finalizeCss(chunkCSS, true, config)
+            let cssString = JSON.stringify(chunkCSS)
+            cssString =
+              renderAssetUrlInJS(
+                this,
+                config,
+                chunk,
+                opts,
+                cssString,
+              )?.toString() || cssString
+            const style = `__vite_style__`
+            const injectCode =
+              `var ${style} = document.createElement('style');` +
+              `${style}.textContent = ${cssString};` +
+              `document.head.appendChild(${style});`
+            let injectionPoint
+            const wrapIdx = code.indexOf('System.register')
+            if (wrapIdx >= 0) {
+              const executeFnStart = code.indexOf('execute:', wrapIdx)
+              injectionPoint = code.indexOf('{', executeFnStart) + 1
+            } else {
+              const insertMark = "'use strict';"
+              injectionPoint = code.indexOf(insertMark) + insertMark.length
+            }
+            s ||= new MagicString(code)
+            s.appendRight(injectionPoint, injectCode)
+          }
+        } else {
+          // resolve public URL from CSS paths, we need to use absolute paths
+          chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssBundleName)
+          // finalizeCss is called for the aggregated chunk in generateBundle
+
+          chunkCSSMap.set(chunk.fileName, chunkCSS)
+        }
+      }
+
+      if (s) {
+        if (config.build.sourcemap) {
+          return {
+            code: s.toString(),
+            map: s.generateMap({ hires: 'boundary' }),
+          }
+        } else {
+          return { code: s.toString() }
+        }
+      }
+      return null
+    },
+
+    augmentChunkHash(chunk) {
+      if (chunk.viteMetadata?.importedCss.size) {
+        let hash = ''
+        for (const id of chunk.viteMetadata.importedCss) {
+          hash += id
+        }
+        return hash
+      }
+    },
+
+    async generateBundle(opts, bundle) {
+      // @ts-expect-error asset emits are skipped in legacy bundle
+      if (opts.__vite_skip_asset_emit__) {
+        return
+      }
+
+      function extractCss() {
+        let css = ''
+        const collected = new Set<OutputChunk>()
+        // will be populated in order they are used by entry points
+        const dynamicImports = new Set<string>()
+
+        function collect(chunk: OutputChunk | OutputAsset) {
+          if (!chunk || chunk.type !== 'chunk' || collected.has(chunk)) return
+          collected.add(chunk)
+
+          // First collect all styles from the synchronous imports (lowest priority)
+          chunk.imports.forEach((importName) => collect(bundle[importName]))
+          // Save dynamic imports in deterministic order to add the styles later (to have the highest priority)
+          chunk.dynamicImports.forEach((importName) =>
+            dynamicImports.add(importName),
+          )
+          // Then collect the styles of the current chunk (might overwrite some styles from previous imports)
+          css += chunkCSSMap.get(chunk.preliminaryFileName) ?? ''
+        }
+
+        // The bundle is guaranteed to be deterministic, if not then we have a bug in rollup.
+        // So we use it to ensure a deterministic order of styles
+        for (const chunk of Object.values(bundle)) {
+          if (chunk.type === 'chunk' && chunk.isEntry) {
+            collect(chunk)
+          }
+        }
+        // Now collect the dynamic chunks, this is done last to have the styles overwrite the previous ones
+        for (const chunkName of dynamicImports) {
+          collect(bundle[chunkName])
+        }
+
+        return css
+      }
+      let extractedCss = !hasEmitted && extractCss()
+      if (extractedCss) {
+        hasEmitted = true
+        extractedCss = await finalizeCss(extractedCss, true, config)
+        this.emitFile({
+          name: cssBundleName,
+          type: 'asset',
+          source: extractedCss,
+        })
+      }
+
+      // remove empty css chunks and their imports
+      if (pureCssChunks.size) {
+        // map each pure css chunk (rendered chunk) to it's corresponding bundle
+        // chunk. we check that by `preliminaryFileName` as they have different
+        // `filename`s (rendered chunk has the !~{XXX}~ placeholder)
+        const prelimaryNameToChunkMap = Object.fromEntries(
+          Object.values(bundle)
+            .filter((chunk): chunk is OutputChunk => chunk.type === 'chunk')
+            .map((chunk) => [chunk.preliminaryFileName, chunk.fileName]),
+        )
+
+        // When running in watch mode the generateBundle is called once per output format
+        // in this case the `bundle` is not populated with the other output files
+        // but they are still in `pureCssChunks`.
+        // So we need to filter the names and only use those who are defined
+        const pureCssChunkNames = [...pureCssChunks]
+          .map((pureCssChunk) => prelimaryNameToChunkMap[pureCssChunk.fileName])
+          .filter(Boolean)
+
+        const replaceEmptyChunk = getEmptyChunkReplacer(
+          pureCssChunkNames,
+          opts.format,
+        )
+
+        for (const file in bundle) {
+          const chunk = bundle[file]
+          if (chunk.type === 'chunk') {
+            let chunkImportsPureCssChunk = false
+            // remove pure css chunk from other chunk's imports,
+            // and also register the emitted CSS files under the importer
+            // chunks instead.
+            chunk.imports = chunk.imports.filter((file) => {
+              if (pureCssChunkNames.includes(file)) {
+                const { importedCss, importedAssets } = (
+                  bundle[file] as OutputChunk
+                ).viteMetadata!
+                importedCss.forEach((file) =>
+                  chunk.viteMetadata!.importedCss.add(file),
+                )
+                importedAssets.forEach((file) =>
+                  chunk.viteMetadata!.importedAssets.add(file),
+                )
+                chunkImportsPureCssChunk = true
+                return false
+              }
+              return true
+            })
+            if (chunkImportsPureCssChunk) {
+              chunk.code = replaceEmptyChunk(chunk.code)
+            }
+          }
+        }
+
+        const removedPureCssFiles = removedPureCssFilesCache.get(config)!
+        pureCssChunkNames.forEach((fileName) => {
+          removedPureCssFiles.set(fileName, bundle[fileName] as RenderedChunk)
+          delete bundle[fileName]
+          delete bundle[`${fileName}.map`]
+        })
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/lessProcessor.ts b/packages/vite/src/node/plugins/css/lessProcessor.ts
new file mode 100644
index 000000000..93eed495a
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/lessProcessor.ts
@@ -0,0 +1,368 @@
+import { ResolveFn } from 'packages/vite/src/node/index';
+import type { Alias } from 'dep-types/alias'
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import type Less from 'less'
+import { WorkerWithFallback } from 'artichokie'
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { asyncReplace } from 'packages/vite/src/node/utils';
+
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+export interface StylePreprocessorResults {
+  code: string
+  map?: ExistingRawSourceMap | undefined
+  additionalMap?: ExistingRawSourceMap | undefined
+  error?: RollupError
+  deps: string[]
+}
+
+export type StylePreprocessor = {
+  process: (
+    source: string,
+    root: string,
+    options: StylePreprocessorOptions,
+    resolvers: CSSAtImportResolvers,
+  ) => StylePreprocessorResults | Promise<StylePreprocessorResults>
+  close: () => void
+}
+
+// https://drafts.csswg.org/css-syntax-3/#identifier-code-point
+export const cssUrlRE =
+  /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
+
+export const cssDataUriRE =
+  /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
+
+export const importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/
+
+export type CssUrlReplacer = (
+  url: string,
+  importer?: string,
+) => string | Promise<string>
+
+export function rewriteCssUrls(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, cssUrlRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doUrlReplace(rawUrl.trim(), matched, replacer)
+  })
+}
+
+export function rewriteCssDataUris(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, cssDataUriRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doUrlReplace(rawUrl.trim(), matched, replacer, 'data-uri')
+  })
+}
+
+export function rewriteImportCss(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, importCssRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doImportCSSReplace(rawUrl, matched, replacer)
+  })
+}
+
+/**
+ * relative url() inside \@imported sass and less files must be rebased to use
+ * root file as base.
+ */
+export async function rebaseUrls(
+  file: string,
+  rootFile: string,
+  alias: Alias[],
+  variablePrefix: string,
+  resolver: ResolveFn,
+): Promise<{ file: string; contents?: string }> {
+  file = path.resolve(file) // ensure os-specific flashes
+  // in the same dir, no need to rebase
+  const fileDir = path.dirname(file)
+  const rootDir = path.dirname(rootFile)
+  if (fileDir === rootDir) {
+    return { file }
+  }
+
+  const content = await fsp.readFile(file, 'utf-8')
+  // no url()
+  const hasUrls = cssUrlRE.test(content)
+  // data-uri() calls
+  const hasDataUris = cssDataUriRE.test(content)
+  // no @import xxx.css
+  const hasImportCss = importCssRE.test(content)
+
+  if (!hasUrls && !hasDataUris && !hasImportCss) {
+    return { file }
+  }
+
+  let rebased
+  const rebaseFn = async (url: string) => {
+    if (url[0] === '/') return url
+    // ignore url's starting with variable
+    if (url.startsWith(variablePrefix)) return url
+    // match alias, no need to rewrite
+    for (const { find } of alias) {
+      const matches =
+        typeof find === 'string' ? url.startsWith(find) : find.test(url)
+      if (matches) {
+        return url
+      }
+    }
+    const absolute = (await resolver(url, file)) || path.resolve(fileDir, url)
+    const relative = path.relative(rootDir, absolute)
+    return normalizePath(relative)
+  }
+
+  // fix css imports in less such as `@import "foo.css"`
+  if (hasImportCss) {
+    rebased = await rewriteImportCss(content, rebaseFn)
+  }
+
+  if (hasUrls) {
+    rebased = await rewriteCssUrls(rebased || content, rebaseFn)
+  }
+
+  if (hasDataUris) {
+    rebased = await rewriteCssDataUris(rebased || content, rebaseFn)
+  }
+
+  return {
+    file,
+    contents: rebased,
+  }
+}
+
+// #region Less
+// .less
+export const makeLessWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  maxWorkers: number | undefined,
+) => {
+  const viteLessResolve = async (
+    filename: string,
+    dir: string,
+    rootFile: string,
+  ) => {
+    const resolved = await resolvers.less(filename, path.join(dir, '*'))
+    if (!resolved) return undefined
+
+    const result = await rebaseUrls(
+      resolved,
+      rootFile,
+      alias,
+      '@',
+      resolvers.less,
+    )
+    if (result) {
+      return {
+        resolved,
+        contents: 'contents' in result ? result.contents : undefined,
+      }
+    }
+    return result
+  }
+
+  const worker = new WorkerWithFallback(
+    () => {
+      // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+      const fsp = require('node:fs/promises')
+      // eslint-disable-next-line no-restricted-globals
+      const path = require('node:path')
+
+      let ViteLessManager: any
+      const createViteLessPlugin = (
+        less: typeof Less,
+        rootFile: string,
+      ): Less.Plugin => {
+        const { FileManager } = less
+        ViteLessManager ??= class ViteManager extends FileManager {
+          rootFile
+          constructor(rootFile: string) {
+            super()
+            this.rootFile = rootFile
+          }
+          override supports(filename: string) {
+            return !/^(?:https?:)?\/\//.test(filename)
+          }
+          override supportsSync() {
+            return false
+          }
+          override async loadFile(
+            filename: string,
+            dir: string,
+            opts: any,
+            env: any,
+          ): Promise<Less.FileLoadResult> {
+            const result = await viteLessResolve(filename, dir, this.rootFile)
+            if (result) {
+              return {
+                filename: path.resolve(result.resolved),
+                contents:
+                  result.contents ??
+                  (await fsp.readFile(result.resolved, 'utf-8')),
+              }
+            } else {
+              return super.loadFile(filename, dir, opts, env)
+            }
+          }
+        }
+
+        return {
+          install(_, pluginManager) {
+            pluginManager.addFileManager(new ViteLessManager(rootFile))
+          },
+          minVersion: [3, 0, 0],
+        }
+      }
+
+      return async (
+        lessPath: string,
+        content: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: StylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const nodeLess: typeof Less = require(lessPath)
+        const viteResolverPlugin = createViteLessPlugin(
+          nodeLess,
+          options.filename,
+        )
+        const result = await nodeLess.render(content, {
+          ...options,
+          plugins: [viteResolverPlugin, ...(options.plugins || [])],
+          ...(options.enableSourcemap
+            ? {
+                sourceMap: {
+                  outputSourceFiles: true,
+                  sourceMapFileInline: false,
+                },
+              }
+            : {}),
+        })
+        return result
+      }
+    },
+    {
+      parentFunctions: { viteLessResolve },
+      shouldUseFake(_lessPath, _content, options) {
+        // plugins are a function and is not serializable
+        // in that case, fallback to running in main thread
+        return options.plugins?.length > 0
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
+
+export const lessProcessor = (maxWorkers: number | undefined): StylePreprocessor => {
+  const workerMap = new Map<unknown, ReturnType<typeof makeLessWorker>>()
+
+  return {
+    close() {
+      for (const worker of workerMap.values()) {
+        worker.stop()
+      }
+    },
+    async process(source, root, options, resolvers) {
+      const lessPath = loadPreprocessorPath(PreprocessLang.less, root)
+
+      if (!workerMap.has(options.alias)) {
+        workerMap.set(
+          options.alias,
+          makeLessWorker(resolvers, options.alias, maxWorkers),
+        )
+      }
+      const worker = workerMap.get(options.alias)!
+
+      const { content, map: additionalMap } = await getSource(
+        source,
+        options.filename,
+        options.additionalData,
+        options.enableSourcemap,
+      )
+
+      let result: Less.RenderOutput | undefined
+      const optionsWithoutAdditionalData = {
+        ...options,
+        additionalData: undefined,
+      }
+      try {
+        result = await worker.run(
+          lessPath,
+          content,
+          optionsWithoutAdditionalData,
+        )
+      } catch (e) {
+        const error = e as Less.RenderError
+        // normalize error info
+        const normalizedError: RollupError = new Error(
+          `[less] ${error.message || error.type}`,
+        ) as RollupError
+        normalizedError.loc = {
+          file: error.filename || options.filename,
+          line: error.line,
+          column: error.column,
+        }
+        return { code: '', error: normalizedError, deps: [] }
+      }
+
+      const map: ExistingRawSourceMap = result.map && JSON.parse(result.map)
+      if (map) {
+        delete map.sourcesContent
+      }
+
+      return {
+        code: result.css.toString(),
+        map,
+        additionalMap,
+        deps: result.imports,
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/makeLessWorker.ts b/packages/vite/src/node/plugins/css/makeLessWorker.ts
new file mode 100644
index 000000000..b288ea776
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/makeLessWorker.ts
@@ -0,0 +1,283 @@
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import type Less from 'less'
+import type { Alias } from 'dep-types/alias'
+import { WorkerWithFallback } from 'artichokie'
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { ResolveFn } from 'packages/vite/src/node/index';
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { asyncReplace } from 'packages/vite/src/node/utils';
+
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+// https://drafts.csswg.org/css-syntax-3/#identifier-code-point
+export const cssUrlRE =
+  /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
+
+export const cssDataUriRE =
+  /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
+
+export const importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/
+
+export type CssUrlReplacer = (
+  url: string,
+  importer?: string,
+) => string | Promise<string>
+
+export function rewriteCssUrls(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, cssUrlRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doUrlReplace(rawUrl.trim(), matched, replacer)
+  })
+}
+
+export function rewriteCssDataUris(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, cssDataUriRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doUrlReplace(rawUrl.trim(), matched, replacer, 'data-uri')
+  })
+}
+
+export function rewriteImportCss(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, importCssRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doImportCSSReplace(rawUrl, matched, replacer)
+  })
+}
+
+/**
+ * relative url() inside \@imported sass and less files must be rebased to use
+ * root file as base.
+ */
+export async function rebaseUrls(
+  file: string,
+  rootFile: string,
+  alias: Alias[],
+  variablePrefix: string,
+  resolver: ResolveFn,
+): Promise<{ file: string; contents?: string }> {
+  file = path.resolve(file) // ensure os-specific flashes
+  // in the same dir, no need to rebase
+  const fileDir = path.dirname(file)
+  const rootDir = path.dirname(rootFile)
+  if (fileDir === rootDir) {
+    return { file }
+  }
+
+  const content = await fsp.readFile(file, 'utf-8')
+  // no url()
+  const hasUrls = cssUrlRE.test(content)
+  // data-uri() calls
+  const hasDataUris = cssDataUriRE.test(content)
+  // no @import xxx.css
+  const hasImportCss = importCssRE.test(content)
+
+  if (!hasUrls && !hasDataUris && !hasImportCss) {
+    return { file }
+  }
+
+  let rebased
+  const rebaseFn = async (url: string) => {
+    if (url[0] === '/') return url
+    // ignore url's starting with variable
+    if (url.startsWith(variablePrefix)) return url
+    // match alias, no need to rewrite
+    for (const { find } of alias) {
+      const matches =
+        typeof find === 'string' ? url.startsWith(find) : find.test(url)
+      if (matches) {
+        return url
+      }
+    }
+    const absolute = (await resolver(url, file)) || path.resolve(fileDir, url)
+    const relative = path.relative(rootDir, absolute)
+    return normalizePath(relative)
+  }
+
+  // fix css imports in less such as `@import "foo.css"`
+  if (hasImportCss) {
+    rebased = await rewriteImportCss(content, rebaseFn)
+  }
+
+  if (hasUrls) {
+    rebased = await rewriteCssUrls(rebased || content, rebaseFn)
+  }
+
+  if (hasDataUris) {
+    rebased = await rewriteCssDataUris(rebased || content, rebaseFn)
+  }
+
+  return {
+    file,
+    contents: rebased,
+  }
+}
+
+// #region Less
+// .less
+export const makeLessWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  maxWorkers: number | undefined,
+) => {
+  const viteLessResolve = async (
+    filename: string,
+    dir: string,
+    rootFile: string,
+  ) => {
+    const resolved = await resolvers.less(filename, path.join(dir, '*'))
+    if (!resolved) return undefined
+
+    const result = await rebaseUrls(
+      resolved,
+      rootFile,
+      alias,
+      '@',
+      resolvers.less,
+    )
+    if (result) {
+      return {
+        resolved,
+        contents: 'contents' in result ? result.contents : undefined,
+      }
+    }
+    return result
+  }
+
+  const worker = new WorkerWithFallback(
+    () => {
+      // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+      const fsp = require('node:fs/promises')
+      // eslint-disable-next-line no-restricted-globals
+      const path = require('node:path')
+
+      let ViteLessManager: any
+      const createViteLessPlugin = (
+        less: typeof Less,
+        rootFile: string,
+      ): Less.Plugin => {
+        const { FileManager } = less
+        ViteLessManager ??= class ViteManager extends FileManager {
+          rootFile
+          constructor(rootFile: string) {
+            super()
+            this.rootFile = rootFile
+          }
+          override supports(filename: string) {
+            return !/^(?:https?:)?\/\//.test(filename)
+          }
+          override supportsSync() {
+            return false
+          }
+          override async loadFile(
+            filename: string,
+            dir: string,
+            opts: any,
+            env: any,
+          ): Promise<Less.FileLoadResult> {
+            const result = await viteLessResolve(filename, dir, this.rootFile)
+            if (result) {
+              return {
+                filename: path.resolve(result.resolved),
+                contents:
+                  result.contents ??
+                  (await fsp.readFile(result.resolved, 'utf-8')),
+              }
+            } else {
+              return super.loadFile(filename, dir, opts, env)
+            }
+          }
+        }
+
+        return {
+          install(_, pluginManager) {
+            pluginManager.addFileManager(new ViteLessManager(rootFile))
+          },
+          minVersion: [3, 0, 0],
+        }
+      }
+
+      return async (
+        lessPath: string,
+        content: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: StylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const nodeLess: typeof Less = require(lessPath)
+        const viteResolverPlugin = createViteLessPlugin(
+          nodeLess,
+          options.filename,
+        )
+        const result = await nodeLess.render(content, {
+          ...options,
+          plugins: [viteResolverPlugin, ...(options.plugins || [])],
+          ...(options.enableSourcemap
+            ? {
+                sourceMap: {
+                  outputSourceFiles: true,
+                  sourceMapFileInline: false,
+                },
+              }
+            : {}),
+        })
+        return result
+      }
+    },
+    {
+      parentFunctions: { viteLessResolve },
+      shouldUseFake(_lessPath, _content, options) {
+        // plugins are a function and is not serializable
+        // in that case, fallback to running in main thread
+        return options.plugins?.length > 0
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/makeModernCompilerScssWorker.ts b/packages/vite/src/node/plugins/css/makeModernCompilerScssWorker.ts
new file mode 100644
index 000000000..7078df845
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/makeModernCompilerScssWorker.ts
@@ -0,0 +1,243 @@
+import { fileURLToPath, pathToFileURL } from 'node:url'
+import type { Alias } from 'dep-types/alias'
+import { ResolveFn } from 'packages/vite/src/node/index';
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import type Sass from 'sass'
+import { WorkerWithFallback } from 'artichokie'
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+export type SassStylePreprocessorOptions = StylePreprocessorOptions &
+  Omit<Sass.LegacyOptions<'async'>, 'data' | 'file' | 'outFile'> & {
+    api?: 'legacy' | 'modern' | 'modern-compiler'
+  }
+
+// in unix, scss might append `location.href` in environments that shim `location`
+// see https://github.com/sass/dart-sass/issues/710
+export function cleanScssBugUrl(url: string) {
+  if (
+    // check bug via `window` and `location` global
+    typeof window !== 'undefined' &&
+    typeof location !== 'undefined' &&
+    typeof location?.href === 'string'
+  ) {
+    const prefix = location.href.replace(/\/$/, '')
+    return url.replace(prefix, '')
+  } else {
+    return url
+  }
+}
+
+export const makeModernScssWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  maxWorkers: number | undefined,
+) => {
+  const internalCanonicalize = async (
+    url: string,
+    importer: string,
+  ): Promise<string | null> => {
+    importer = cleanScssBugUrl(importer)
+    const resolved = await resolvers.sass(url, importer)
+    return resolved ?? null
+  }
+
+  const internalLoad = async (file: string, rootFile: string) => {
+    const result = await rebaseUrls(file, rootFile, alias, '$', resolvers.sass)
+    if (result.contents) {
+      return result.contents
+    }
+    return await fsp.readFile(result.file, 'utf-8')
+  }
+
+  const worker = new WorkerWithFallback(
+    () =>
+      async (
+        sassPath: string,
+        data: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: SassStylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const sass: typeof Sass = require(sassPath)
+        // eslint-disable-next-line no-restricted-globals
+        const path: typeof import('node:path') = require('node:path')
+
+        const { fileURLToPath, pathToFileURL }: typeof import('node:url') =
+          // eslint-disable-next-line no-restricted-globals
+          require('node:url')
+
+        const sassOptions = { ...options } as Sass.StringOptions<'async'>
+        sassOptions.url = pathToFileURL(options.filename)
+        sassOptions.sourceMap = options.enableSourcemap
+
+        const internalImporter: Sass.Importer<'async'> = {
+          async canonicalize(url, context) {
+            const importer = context.containingUrl
+              ? fileURLToPath(context.containingUrl)
+              : options.filename
+            const resolved = await internalCanonicalize(url, importer)
+            return resolved ? pathToFileURL(resolved) : null
+          },
+          async load(canonicalUrl) {
+            const ext = path.extname(canonicalUrl.pathname)
+            let syntax: Sass.Syntax = 'scss'
+            if (ext === '.sass') {
+              syntax = 'indented'
+            } else if (ext === '.css') {
+              syntax = 'css'
+            }
+            const contents = await internalLoad(
+              fileURLToPath(canonicalUrl),
+              options.filename,
+            )
+            return { contents, syntax }
+          },
+        }
+        sassOptions.importers = [
+          ...(sassOptions.importers ?? []),
+          internalImporter,
+        ]
+
+        const result = await sass.compileStringAsync(data, sassOptions)
+        return {
+          css: result.css,
+          map: result.sourceMap ? JSON.stringify(result.sourceMap) : undefined,
+          stats: {
+            includedFiles: result.loadedUrls
+              .filter((url) => url.protocol === 'file:')
+              .map((url) => fileURLToPath(url)),
+          },
+        } satisfies ScssWorkerResult
+      },
+    {
+      parentFunctions: {
+        internalCanonicalize,
+        internalLoad,
+      },
+      shouldUseFake(_sassPath, _data, options) {
+        // functions and importer is a function and is not serializable
+        // in that case, fallback to running in main thread
+        return !!(
+          (options.functions && Object.keys(options.functions).length > 0) ||
+          (options.importers &&
+            (!Array.isArray(options.importers) || options.importers.length > 0))
+        )
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
+
+// this is mostly a copy&paste of makeModernScssWorker
+// however sharing code between two is hard because
+// makeModernScssWorker above needs function inlined for worker.
+export const makeModernCompilerScssWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  _maxWorkers: number | undefined,
+) => {
+  let compiler: Sass.AsyncCompiler | undefined
+
+  const worker: Awaited<ReturnType<typeof makeModernScssWorker>> = {
+    async run(sassPath, data, options) {
+      // need pathToFileURL for windows since import("D:...") fails
+      // https://github.com/nodejs/node/issues/31710
+      const sass: typeof Sass = (await import(pathToFileURL(sassPath).href))
+        .default
+      compiler ??= await sass.initAsyncCompiler()
+
+      const sassOptions = { ...options } as Sass.StringOptions<'async'>
+      sassOptions.url = pathToFileURL(options.filename)
+      sassOptions.sourceMap = options.enableSourcemap
+
+      const internalImporter: Sass.Importer<'async'> = {
+        async canonicalize(url, context) {
+          const importer = context.containingUrl
+            ? fileURLToPath(context.containingUrl)
+            : options.filename
+          const resolved = await resolvers.sass(url, cleanScssBugUrl(importer))
+          return resolved ? pathToFileURL(resolved) : null
+        },
+        async load(canonicalUrl) {
+          const ext = path.extname(canonicalUrl.pathname)
+          let syntax: Sass.Syntax = 'scss'
+          if (ext === '.sass') {
+            syntax = 'indented'
+          } else if (ext === '.css') {
+            syntax = 'css'
+          }
+          const result = await rebaseUrls(
+            fileURLToPath(canonicalUrl),
+            options.filename,
+            alias,
+            '$',
+            resolvers.sass,
+          )
+          const contents =
+            result.contents ?? (await fsp.readFile(result.file, 'utf-8'))
+          return { contents, syntax }
+        },
+      }
+      sassOptions.importers = [
+        ...(sassOptions.importers ?? []),
+        internalImporter,
+      ]
+
+      const result = await compiler.compileStringAsync(data, sassOptions)
+      return {
+        css: result.css,
+        map: result.sourceMap ? JSON.stringify(result.sourceMap) : undefined,
+        stats: {
+          includedFiles: result.loadedUrls
+            .filter((url) => url.protocol === 'file:')
+            .map((url) => fileURLToPath(url)),
+        },
+      } satisfies ScssWorkerResult
+    },
+    async stop() {
+      compiler?.dispose()
+      compiler = undefined
+    },
+  }
+
+  return worker
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/makeModernScssWorker.ts b/packages/vite/src/node/plugins/css/makeModernScssWorker.ts
new file mode 100644
index 000000000..834ef15ba
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/makeModernScssWorker.ts
@@ -0,0 +1,168 @@
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import { fileURLToPath, pathToFileURL } from 'node:url'
+import type Sass from 'sass'
+import type { Alias } from 'dep-types/alias'
+import { WorkerWithFallback } from 'artichokie'
+import { ResolveFn } from 'packages/vite/src/node/index';
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+export type SassStylePreprocessorOptions = StylePreprocessorOptions &
+  Omit<Sass.LegacyOptions<'async'>, 'data' | 'file' | 'outFile'> & {
+    api?: 'legacy' | 'modern' | 'modern-compiler'
+  }
+
+// in unix, scss might append `location.href` in environments that shim `location`
+// see https://github.com/sass/dart-sass/issues/710
+export function cleanScssBugUrl(url: string) {
+  if (
+    // check bug via `window` and `location` global
+    typeof window !== 'undefined' &&
+    typeof location !== 'undefined' &&
+    typeof location?.href === 'string'
+  ) {
+    const prefix = location.href.replace(/\/$/, '')
+    return url.replace(prefix, '')
+  } else {
+    return url
+  }
+}
+
+export const makeModernScssWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  maxWorkers: number | undefined,
+) => {
+  const internalCanonicalize = async (
+    url: string,
+    importer: string,
+  ): Promise<string | null> => {
+    importer = cleanScssBugUrl(importer)
+    const resolved = await resolvers.sass(url, importer)
+    return resolved ?? null
+  }
+
+  const internalLoad = async (file: string, rootFile: string) => {
+    const result = await rebaseUrls(file, rootFile, alias, '$', resolvers.sass)
+    if (result.contents) {
+      return result.contents
+    }
+    return await fsp.readFile(result.file, 'utf-8')
+  }
+
+  const worker = new WorkerWithFallback(
+    () =>
+      async (
+        sassPath: string,
+        data: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: SassStylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const sass: typeof Sass = require(sassPath)
+        // eslint-disable-next-line no-restricted-globals
+        const path: typeof import('node:path') = require('node:path')
+
+        const { fileURLToPath, pathToFileURL }: typeof import('node:url') =
+          // eslint-disable-next-line no-restricted-globals
+          require('node:url')
+
+        const sassOptions = { ...options } as Sass.StringOptions<'async'>
+        sassOptions.url = pathToFileURL(options.filename)
+        sassOptions.sourceMap = options.enableSourcemap
+
+        const internalImporter: Sass.Importer<'async'> = {
+          async canonicalize(url, context) {
+            const importer = context.containingUrl
+              ? fileURLToPath(context.containingUrl)
+              : options.filename
+            const resolved = await internalCanonicalize(url, importer)
+            return resolved ? pathToFileURL(resolved) : null
+          },
+          async load(canonicalUrl) {
+            const ext = path.extname(canonicalUrl.pathname)
+            let syntax: Sass.Syntax = 'scss'
+            if (ext === '.sass') {
+              syntax = 'indented'
+            } else if (ext === '.css') {
+              syntax = 'css'
+            }
+            const contents = await internalLoad(
+              fileURLToPath(canonicalUrl),
+              options.filename,
+            )
+            return { contents, syntax }
+          },
+        }
+        sassOptions.importers = [
+          ...(sassOptions.importers ?? []),
+          internalImporter,
+        ]
+
+        const result = await sass.compileStringAsync(data, sassOptions)
+        return {
+          css: result.css,
+          map: result.sourceMap ? JSON.stringify(result.sourceMap) : undefined,
+          stats: {
+            includedFiles: result.loadedUrls
+              .filter((url) => url.protocol === 'file:')
+              .map((url) => fileURLToPath(url)),
+          },
+        } satisfies ScssWorkerResult
+      },
+    {
+      parentFunctions: {
+        internalCanonicalize,
+        internalLoad,
+      },
+      shouldUseFake(_sassPath, _data, options) {
+        // functions and importer is a function and is not serializable
+        // in that case, fallback to running in main thread
+        return !!(
+          (options.functions && Object.keys(options.functions).length > 0) ||
+          (options.importers &&
+            (!Array.isArray(options.importers) || options.importers.length > 0))
+        )
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/makeScssWorker.ts b/packages/vite/src/node/plugins/css/makeScssWorker.ts
new file mode 100644
index 000000000..087a0a82c
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/makeScssWorker.ts
@@ -0,0 +1,192 @@
+import path from 'node:path'
+import type Sass from 'sass'
+import type { Alias } from 'dep-types/alias'
+import { WorkerWithFallback } from 'artichokie'
+import { ResolveFn } from 'packages/vite/src/node/index';
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import fs from 'node:fs'
+
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+export type SassStylePreprocessorOptions = StylePreprocessorOptions &
+  Omit<Sass.LegacyOptions<'async'>, 'data' | 'file' | 'outFile'> & {
+    api?: 'legacy' | 'modern' | 'modern-compiler'
+  }
+
+// in unix, scss might append `location.href` in environments that shim `location`
+// see https://github.com/sass/dart-sass/issues/710
+export function cleanScssBugUrl(url: string) {
+  if (
+    // check bug via `window` and `location` global
+    typeof window !== 'undefined' &&
+    typeof location !== 'undefined' &&
+    typeof location?.href === 'string'
+  ) {
+    const prefix = location.href.replace(/\/$/, '')
+    return url.replace(prefix, '')
+  } else {
+    return url
+  }
+}
+
+export function fixScssBugImportValue(
+  data: Sass.LegacyImporterResult,
+): Sass.LegacyImporterResult {
+  // the scss bug doesn't load files properly so we have to load it ourselves
+  // to prevent internal error when it loads itself
+  if (
+    // check bug via `window` and `location` global
+    typeof window !== 'undefined' &&
+    typeof location !== 'undefined' &&
+    data &&
+    'file' in data &&
+    (!('contents' in data) || data.contents == null)
+  ) {
+    // @ts-expect-error we need to preserve file property for HMR
+    data.contents = fs.readFileSync(data.file, 'utf-8')
+  }
+  return data
+}
+
+// #region Sass
+// .scss/.sass processor
+export const makeScssWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  maxWorkers: number | undefined,
+) => {
+  const internalImporter = async (
+    url: string,
+    importer: string,
+    filename: string,
+  ) => {
+    importer = cleanScssBugUrl(importer)
+    const resolved = await resolvers.sass(url, importer)
+    if (resolved) {
+      try {
+        const data = await rebaseUrls(
+          resolved,
+          filename,
+          alias,
+          '$',
+          resolvers.sass,
+        )
+        return fixScssBugImportValue(data)
+      } catch (data) {
+        return data
+      }
+    } else {
+      return null
+    }
+  }
+
+  const worker = new WorkerWithFallback(
+    () =>
+      async (
+        sassPath: string,
+        data: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: SassStylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const sass: typeof Sass = require(sassPath)
+        // eslint-disable-next-line no-restricted-globals
+        const path: typeof import('node:path') = require('node:path')
+
+        // NOTE: `sass` always runs it's own importer first, and only falls back to
+        // the `importer` option when it can't resolve a path
+        const _internalImporter: Sass.LegacyAsyncImporter = (
+          url,
+          importer,
+          done,
+        ) => {
+          internalImporter(url, importer, options.filename).then((data) =>
+            done?.(data),
+          )
+        }
+        const importer = [_internalImporter]
+        if (options.importer) {
+          Array.isArray(options.importer)
+            ? importer.unshift(...options.importer)
+            : importer.unshift(options.importer)
+        }
+
+        const finalOptions: Sass.LegacyOptions<'async'> = {
+          ...options,
+          data,
+          file: options.filename,
+          outFile: options.filename,
+          importer,
+          ...(options.enableSourcemap
+            ? {
+                sourceMap: true,
+                omitSourceMapUrl: true,
+                sourceMapRoot: path.dirname(options.filename),
+              }
+            : {}),
+        }
+        return new Promise<ScssWorkerResult>((resolve, reject) => {
+          sass.render(finalOptions, (err, res) => {
+            if (err) {
+              reject(err)
+            } else {
+              resolve({
+                css: res!.css.toString(),
+                map: res!.map?.toString(),
+                stats: res!.stats,
+              })
+            }
+          })
+        })
+      },
+    {
+      parentFunctions: { internalImporter },
+      shouldUseFake(_sassPath, _data, options) {
+        // functions and importer is a function and is not serializable
+        // in that case, fallback to running in main thread
+        return !!(
+          (options.functions && Object.keys(options.functions).length > 0) ||
+          (options.importer &&
+            (!Array.isArray(options.importer) || options.importer.length > 0))
+        )
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/makeStylWorker.ts b/packages/vite/src/node/plugins/css/makeStylWorker.ts
new file mode 100644
index 000000000..4fbdf448d
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/makeStylWorker.ts
@@ -0,0 +1,91 @@
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import type Stylus from 'stylus'
+import { WorkerWithFallback } from 'artichokie'
+import type { Alias } from 'dep-types/alias'
+
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+export type StylusStylePreprocessorOptions = StylePreprocessorOptions & {
+  define?: Record<string, any>
+}
+
+// #region Stylus
+// .styl
+export const makeStylWorker = (maxWorkers: number | undefined) => {
+  const worker = new WorkerWithFallback(
+    () => {
+      return async (
+        stylusPath: string,
+        content: string,
+        root: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: StylusStylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const nodeStylus: typeof Stylus = require(stylusPath)
+
+        const ref = nodeStylus(content, options)
+        if (options.define) {
+          for (const key in options.define) {
+            ref.define(key, options.define[key])
+          }
+        }
+        if (options.enableSourcemap) {
+          ref.set('sourcemap', {
+            comment: false,
+            inline: false,
+            basePath: root,
+          })
+        }
+
+        return {
+          code: ref.render(),
+          // @ts-expect-error sourcemap exists
+          map: ref.sourcemap as ExistingRawSourceMap | undefined,
+          deps: ref.deps(),
+        }
+      }
+    },
+    {
+      shouldUseFake(_stylusPath, _content, _root, options) {
+        // define can include functions and those are not serializable
+        // in that case, fallback to running in main thread
+        return !!(
+          options.define &&
+          Object.values(options.define).some((d) => typeof d === 'function')
+        )
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/minifyCSS.ts b/packages/vite/src/node/plugins/css/minifyCSS.ts
new file mode 100644
index 000000000..37b49a888
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/minifyCSS.ts
@@ -0,0 +1,67 @@
+import colors from 'picocolors'
+import { formatMessages, transform } from 'esbuild'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+
+
+const export decoder = new TextDecoder()
+
+const export cssBundleName = 'style.css'
+
+export async function minifyCSS(
+  css: string,
+  config: ResolvedConfig,
+  inlined: boolean,
+) {
+  // We want inlined CSS to not end with a linebreak, while ensuring that
+  // regular CSS assets do end with a linebreak.
+  // See https://github.com/vitejs/vite/pull/13893#issuecomment-1678628198
+
+  if (config.build.cssMinify === 'lightningcss') {
+    const { code, warnings } = (await importLightningCSS()).transform({
+      ...config.css?.lightningcss,
+      targets: convertTargets(config.build.cssTarget),
+      cssModules: undefined,
+      filename: cssBundleName,
+      code: Buffer.from(css),
+      minify: true,
+    })
+    if (warnings.length) {
+      config.logger.warn(
+        colors.yellow(
+          `warnings when minifying css:\n${warnings
+            .map((w) => w.message)
+            .join('\n')}`,
+        ),
+      )
+    }
+
+    // NodeJS res.code = Buffer
+    // Deno res.code = Uint8Array
+    // For correct decode compiled css need to use TextDecoder
+    // LightningCSS output does not return a linebreak at the end
+    return decoder.decode(code) + (inlined ? '' : '\n')
+  }
+  try {
+    const { code, warnings } = await transform(css, {
+      loader: 'css',
+      target: config.build.cssTarget || undefined,
+      ...resolveMinifyCssEsbuildOptions(config.esbuild || {}),
+    })
+    if (warnings.length) {
+      const msgs = await formatMessages(warnings, { kind: 'warning' })
+      config.logger.warn(
+        colors.yellow(`warnings when minifying css:\n${msgs.join('\n')}`),
+      )
+    }
+    // esbuild output does return a linebreak at the end
+    return inlined ? code.trimEnd() : code
+  } catch (e) {
+    if (e.errors) {
+      e.message = '[esbuild css minify] ' + e.message
+      const msgs = await formatMessages(e.errors, { kind: 'error' })
+      e.frame = '\n' + msgs.join('\n')
+      e.loc = e.errors[0].location
+    }
+    throw e
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/rebaseUrls.ts b/packages/vite/src/node/plugins/css/rebaseUrls.ts
new file mode 100644
index 000000000..179ab3dcb
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/rebaseUrls.ts
@@ -0,0 +1,119 @@
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import type { Alias } from 'dep-types/alias'
+import { ResolveFn } from 'packages/vite/src/node/index';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { asyncReplace } from 'packages/vite/src/node/utils';
+
+
+// https://drafts.csswg.org/css-syntax-3/#identifier-code-point
+export const cssUrlRE =
+  /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
+
+export const cssDataUriRE =
+  /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/
+
+export const importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/
+
+export type CssUrlReplacer = (
+  url: string,
+  importer?: string,
+) => string | Promise<string>
+
+export function rewriteCssUrls(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, cssUrlRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doUrlReplace(rawUrl.trim(), matched, replacer)
+  })
+}
+
+export function rewriteCssDataUris(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, cssDataUriRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doUrlReplace(rawUrl.trim(), matched, replacer, 'data-uri')
+  })
+}
+
+export function rewriteImportCss(
+  css: string,
+  replacer: CssUrlReplacer,
+): Promise<string> {
+  return asyncReplace(css, importCssRE, async (match) => {
+    const [matched, rawUrl] = match
+    return await doImportCSSReplace(rawUrl, matched, replacer)
+  })
+}
+
+/**
+ * relative url() inside \@imported sass and less files must be rebased to use
+ * root file as base.
+ */
+export async function rebaseUrls(
+  file: string,
+  rootFile: string,
+  alias: Alias[],
+  variablePrefix: string,
+  resolver: ResolveFn,
+): Promise<{ file: string; contents?: string }> {
+  file = path.resolve(file) // ensure os-specific flashes
+  // in the same dir, no need to rebase
+  const fileDir = path.dirname(file)
+  const rootDir = path.dirname(rootFile)
+  if (fileDir === rootDir) {
+    return { file }
+  }
+
+  const content = await fsp.readFile(file, 'utf-8')
+  // no url()
+  const hasUrls = cssUrlRE.test(content)
+  // data-uri() calls
+  const hasDataUris = cssDataUriRE.test(content)
+  // no @import xxx.css
+  const hasImportCss = importCssRE.test(content)
+
+  if (!hasUrls && !hasDataUris && !hasImportCss) {
+    return { file }
+  }
+
+  let rebased
+  const rebaseFn = async (url: string) => {
+    if (url[0] === '/') return url
+    // ignore url's starting with variable
+    if (url.startsWith(variablePrefix)) return url
+    // match alias, no need to rewrite
+    for (const { find } of alias) {
+      const matches =
+        typeof find === 'string' ? url.startsWith(find) : find.test(url)
+      if (matches) {
+        return url
+      }
+    }
+    const absolute = (await resolver(url, file)) || path.resolve(fileDir, url)
+    const relative = path.relative(rootDir, absolute)
+    return normalizePath(relative)
+  }
+
+  // fix css imports in less such as `@import "foo.css"`
+  if (hasImportCss) {
+    rebased = await rewriteImportCss(content, rebaseFn)
+  }
+
+  if (hasUrls) {
+    rebased = await rewriteCssUrls(rebased || content, rebaseFn)
+  }
+
+  if (hasDataUris) {
+    rebased = await rewriteCssDataUris(rebased || content, rebaseFn)
+  }
+
+  return {
+    file,
+    contents: rebased,
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/scssProcessor.ts b/packages/vite/src/node/plugins/css/scssProcessor.ts
new file mode 100644
index 000000000..b9cbbc28d
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/scssProcessor.ts
@@ -0,0 +1,457 @@
+import { ResolveFn } from 'packages/vite/src/node/index';
+import type Sass from 'sass'
+import type { Alias } from 'dep-types/alias'
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import path from 'node:path'
+import { WorkerWithFallback } from 'artichokie'
+import fs from 'node:fs'
+import fsp from 'node:fs/promises'
+import { fileURLToPath, pathToFileURL } from 'node:url'
+
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+export type SassStylePreprocessorOptions = StylePreprocessorOptions &
+  Omit<Sass.LegacyOptions<'async'>, 'data' | 'file' | 'outFile'> & {
+    api?: 'legacy' | 'modern' | 'modern-compiler'
+  }
+
+export interface StylePreprocessorResults {
+  code: string
+  map?: ExistingRawSourceMap | undefined
+  additionalMap?: ExistingRawSourceMap | undefined
+  error?: RollupError
+  deps: string[]
+}
+
+export type SassStylePreprocessor = {
+  process: (
+    source: string,
+    root: string,
+    options: SassStylePreprocessorOptions,
+    resolvers: CSSAtImportResolvers,
+  ) => StylePreprocessorResults | Promise<StylePreprocessorResults>
+  close: () => void
+}
+
+// in unix, scss might append `location.href` in environments that shim `location`
+// see https://github.com/sass/dart-sass/issues/710
+export function cleanScssBugUrl(url: string) {
+  if (
+    // check bug via `window` and `location` global
+    typeof window !== 'undefined' &&
+    typeof location !== 'undefined' &&
+    typeof location?.href === 'string'
+  ) {
+    const prefix = location.href.replace(/\/$/, '')
+    return url.replace(prefix, '')
+  } else {
+    return url
+  }
+}
+
+export function fixScssBugImportValue(
+  data: Sass.LegacyImporterResult,
+): Sass.LegacyImporterResult {
+  // the scss bug doesn't load files properly so we have to load it ourselves
+  // to prevent internal error when it loads itself
+  if (
+    // check bug via `window` and `location` global
+    typeof window !== 'undefined' &&
+    typeof location !== 'undefined' &&
+    data &&
+    'file' in data &&
+    (!('contents' in data) || data.contents == null)
+  ) {
+    // @ts-expect-error we need to preserve file property for HMR
+    data.contents = fs.readFileSync(data.file, 'utf-8')
+  }
+  return data
+}
+
+// #region Sass
+// .scss/.sass processor
+export const makeScssWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  maxWorkers: number | undefined,
+) => {
+  const internalImporter = async (
+    url: string,
+    importer: string,
+    filename: string,
+  ) => {
+    importer = cleanScssBugUrl(importer)
+    const resolved = await resolvers.sass(url, importer)
+    if (resolved) {
+      try {
+        const data = await rebaseUrls(
+          resolved,
+          filename,
+          alias,
+          '$',
+          resolvers.sass,
+        )
+        return fixScssBugImportValue(data)
+      } catch (data) {
+        return data
+      }
+    } else {
+      return null
+    }
+  }
+
+  const worker = new WorkerWithFallback(
+    () =>
+      async (
+        sassPath: string,
+        data: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: SassStylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const sass: typeof Sass = require(sassPath)
+        // eslint-disable-next-line no-restricted-globals
+        const path: typeof import('node:path') = require('node:path')
+
+        // NOTE: `sass` always runs it's own importer first, and only falls back to
+        // the `importer` option when it can't resolve a path
+        const _internalImporter: Sass.LegacyAsyncImporter = (
+          url,
+          importer,
+          done,
+        ) => {
+          internalImporter(url, importer, options.filename).then((data) =>
+            done?.(data),
+          )
+        }
+        const importer = [_internalImporter]
+        if (options.importer) {
+          Array.isArray(options.importer)
+            ? importer.unshift(...options.importer)
+            : importer.unshift(options.importer)
+        }
+
+        const finalOptions: Sass.LegacyOptions<'async'> = {
+          ...options,
+          data,
+          file: options.filename,
+          outFile: options.filename,
+          importer,
+          ...(options.enableSourcemap
+            ? {
+                sourceMap: true,
+                omitSourceMapUrl: true,
+                sourceMapRoot: path.dirname(options.filename),
+              }
+            : {}),
+        }
+        return new Promise<ScssWorkerResult>((resolve, reject) => {
+          sass.render(finalOptions, (err, res) => {
+            if (err) {
+              reject(err)
+            } else {
+              resolve({
+                css: res!.css.toString(),
+                map: res!.map?.toString(),
+                stats: res!.stats,
+              })
+            }
+          })
+        })
+      },
+    {
+      parentFunctions: { internalImporter },
+      shouldUseFake(_sassPath, _data, options) {
+        // functions and importer is a function and is not serializable
+        // in that case, fallback to running in main thread
+        return !!(
+          (options.functions && Object.keys(options.functions).length > 0) ||
+          (options.importer &&
+            (!Array.isArray(options.importer) || options.importer.length > 0))
+        )
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
+
+export const makeModernScssWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  maxWorkers: number | undefined,
+) => {
+  const internalCanonicalize = async (
+    url: string,
+    importer: string,
+  ): Promise<string | null> => {
+    importer = cleanScssBugUrl(importer)
+    const resolved = await resolvers.sass(url, importer)
+    return resolved ?? null
+  }
+
+  const internalLoad = async (file: string, rootFile: string) => {
+    const result = await rebaseUrls(file, rootFile, alias, '$', resolvers.sass)
+    if (result.contents) {
+      return result.contents
+    }
+    return await fsp.readFile(result.file, 'utf-8')
+  }
+
+  const worker = new WorkerWithFallback(
+    () =>
+      async (
+        sassPath: string,
+        data: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: SassStylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const sass: typeof Sass = require(sassPath)
+        // eslint-disable-next-line no-restricted-globals
+        const path: typeof import('node:path') = require('node:path')
+
+        const { fileURLToPath, pathToFileURL }: typeof import('node:url') =
+          // eslint-disable-next-line no-restricted-globals
+          require('node:url')
+
+        const sassOptions = { ...options } as Sass.StringOptions<'async'>
+        sassOptions.url = pathToFileURL(options.filename)
+        sassOptions.sourceMap = options.enableSourcemap
+
+        const internalImporter: Sass.Importer<'async'> = {
+          async canonicalize(url, context) {
+            const importer = context.containingUrl
+              ? fileURLToPath(context.containingUrl)
+              : options.filename
+            const resolved = await internalCanonicalize(url, importer)
+            return resolved ? pathToFileURL(resolved) : null
+          },
+          async load(canonicalUrl) {
+            const ext = path.extname(canonicalUrl.pathname)
+            let syntax: Sass.Syntax = 'scss'
+            if (ext === '.sass') {
+              syntax = 'indented'
+            } else if (ext === '.css') {
+              syntax = 'css'
+            }
+            const contents = await internalLoad(
+              fileURLToPath(canonicalUrl),
+              options.filename,
+            )
+            return { contents, syntax }
+          },
+        }
+        sassOptions.importers = [
+          ...(sassOptions.importers ?? []),
+          internalImporter,
+        ]
+
+        const result = await sass.compileStringAsync(data, sassOptions)
+        return {
+          css: result.css,
+          map: result.sourceMap ? JSON.stringify(result.sourceMap) : undefined,
+          stats: {
+            includedFiles: result.loadedUrls
+              .filter((url) => url.protocol === 'file:')
+              .map((url) => fileURLToPath(url)),
+          },
+        } satisfies ScssWorkerResult
+      },
+    {
+      parentFunctions: {
+        internalCanonicalize,
+        internalLoad,
+      },
+      shouldUseFake(_sassPath, _data, options) {
+        // functions and importer is a function and is not serializable
+        // in that case, fallback to running in main thread
+        return !!(
+          (options.functions && Object.keys(options.functions).length > 0) ||
+          (options.importers &&
+            (!Array.isArray(options.importers) || options.importers.length > 0))
+        )
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
+
+// this is mostly a copy&paste of makeModernScssWorker
+// however sharing code between two is hard because
+// makeModernScssWorker above needs function inlined for worker.
+export const makeModernCompilerScssWorker = (
+  resolvers: CSSAtImportResolvers,
+  alias: Alias[],
+  _maxWorkers: number | undefined,
+) => {
+  let compiler: Sass.AsyncCompiler | undefined
+
+  const worker: Awaited<ReturnType<typeof makeModernScssWorker>> = {
+    async run(sassPath, data, options) {
+      // need pathToFileURL for windows since import("D:...") fails
+      // https://github.com/nodejs/node/issues/31710
+      const sass: typeof Sass = (await import(pathToFileURL(sassPath).href))
+        .default
+      compiler ??= await sass.initAsyncCompiler()
+
+      const sassOptions = { ...options } as Sass.StringOptions<'async'>
+      sassOptions.url = pathToFileURL(options.filename)
+      sassOptions.sourceMap = options.enableSourcemap
+
+      const internalImporter: Sass.Importer<'async'> = {
+        async canonicalize(url, context) {
+          const importer = context.containingUrl
+            ? fileURLToPath(context.containingUrl)
+            : options.filename
+          const resolved = await resolvers.sass(url, cleanScssBugUrl(importer))
+          return resolved ? pathToFileURL(resolved) : null
+        },
+        async load(canonicalUrl) {
+          const ext = path.extname(canonicalUrl.pathname)
+          let syntax: Sass.Syntax = 'scss'
+          if (ext === '.sass') {
+            syntax = 'indented'
+          } else if (ext === '.css') {
+            syntax = 'css'
+          }
+          const result = await rebaseUrls(
+            fileURLToPath(canonicalUrl),
+            options.filename,
+            alias,
+            '$',
+            resolvers.sass,
+          )
+          const contents =
+            result.contents ?? (await fsp.readFile(result.file, 'utf-8'))
+          return { contents, syntax }
+        },
+      }
+      sassOptions.importers = [
+        ...(sassOptions.importers ?? []),
+        internalImporter,
+      ]
+
+      const result = await compiler.compileStringAsync(data, sassOptions)
+      return {
+        css: result.css,
+        map: result.sourceMap ? JSON.stringify(result.sourceMap) : undefined,
+        stats: {
+          includedFiles: result.loadedUrls
+            .filter((url) => url.protocol === 'file:')
+            .map((url) => fileURLToPath(url)),
+        },
+      } satisfies ScssWorkerResult
+    },
+    async stop() {
+      compiler?.dispose()
+      compiler = undefined
+    },
+  }
+
+  return worker
+}
+
+export const scssProcessor = (
+  maxWorkers: number | undefined,
+): SassStylePreprocessor => {
+  const workerMap = new Map<unknown, ReturnType<typeof makeScssWorker>>()
+
+  return {
+    close() {
+      for (const worker of workerMap.values()) {
+        worker.stop()
+      }
+    },
+    async process(source, root, options, resolvers) {
+      const sassPackage = loadSassPackage(root)
+      // TODO: change default in v6
+      // options.api ?? sassPackage.name === "sass-embedded" ? "modern-compiler" : "modern";
+      const api = options.api ?? 'legacy'
+
+      if (!workerMap.has(options.alias)) {
+        workerMap.set(
+          options.alias,
+          api === 'modern-compiler'
+            ? makeModernCompilerScssWorker(resolvers, options.alias, maxWorkers)
+            : api === 'modern'
+              ? makeModernScssWorker(resolvers, options.alias, maxWorkers)
+              : makeScssWorker(resolvers, options.alias, maxWorkers),
+        )
+      }
+      const worker = workerMap.get(options.alias)!
+
+      const { content: data, map: additionalMap } = await getSource(
+        source,
+        options.filename,
+        options.additionalData,
+        options.enableSourcemap,
+      )
+
+      const optionsWithoutAdditionalData = {
+        ...options,
+        additionalData: undefined,
+      }
+      try {
+        const result = await worker.run(
+          sassPackage.path,
+          data,
+          optionsWithoutAdditionalData,
+        )
+        const deps = result.stats.includedFiles.map((f) => cleanScssBugUrl(f))
+        const map: ExistingRawSourceMap | undefined = result.map
+          ? JSON.parse(result.map.toString())
+          : undefined
+
+        return {
+          code: result.css.toString(),
+          map,
+          additionalMap,
+          deps,
+        }
+      } catch (e) {
+        // normalize SASS error
+        e.message = `[sass] ${e.message}`
+        e.id = e.file
+        e.frame = e.formatted
+        return { code: '', error: e, deps: [] }
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/css/stylProcessor.ts b/packages/vite/src/node/plugins/css/stylProcessor.ts
new file mode 100644
index 000000000..946e7890e
--- /dev/null
+++ b/packages/vite/src/node/plugins/css/stylProcessor.ts
@@ -0,0 +1,177 @@
+import { ResolveFn } from 'packages/vite/src/node/index';
+import type { Alias } from 'dep-types/alias'
+import type {
+  ExistingRawSourceMap,
+  ModuleFormat,
+  OutputAsset,
+  OutputChunk,
+  RenderedChunk,
+  RollupError,
+  SourceMapInput,
+} from 'rollup'
+import type Stylus from 'stylus'
+import { WorkerWithFallback } from 'artichokie'
+
+
+export interface CSSAtImportResolvers {
+  css: ResolveFn
+  sass: ResolveFn
+  less: ResolveFn
+}
+
+export type PreprocessorAdditionalDataResult =
+  | string
+  | { content: string; map?: ExistingRawSourceMap }
+
+export type PreprocessorAdditionalData =
+  | string
+  | ((
+      source: string,
+      filename: string,
+    ) =>
+      | PreprocessorAdditionalDataResult
+      | Promise<PreprocessorAdditionalDataResult>)
+
+export type StylePreprocessorOptions = {
+  [key: string]: any
+  additionalData?: PreprocessorAdditionalData
+  maxWorkers?: number | true
+  filename: string
+  alias: Alias[]
+  enableSourcemap: boolean
+}
+
+export type StylusStylePreprocessorOptions = StylePreprocessorOptions & {
+  define?: Record<string, any>
+}
+
+export interface StylePreprocessorResults {
+  code: string
+  map?: ExistingRawSourceMap | undefined
+  additionalMap?: ExistingRawSourceMap | undefined
+  error?: RollupError
+  deps: string[]
+}
+
+export type StylusStylePreprocessor = {
+  process: (
+    source: string,
+    root: string,
+    options: StylusStylePreprocessorOptions,
+    resolvers: CSSAtImportResolvers,
+  ) => StylePreprocessorResults | Promise<StylePreprocessorResults>
+  close: () => void
+}
+
+// #region Stylus
+// .styl
+export const makeStylWorker = (maxWorkers: number | undefined) => {
+  const worker = new WorkerWithFallback(
+    () => {
+      return async (
+        stylusPath: string,
+        content: string,
+        root: string,
+        // additionalData can a function that is not cloneable but it won't be used
+        options: StylusStylePreprocessorOptions & { additionalData: undefined },
+      ) => {
+        // eslint-disable-next-line no-restricted-globals -- this function runs inside a cjs worker
+        const nodeStylus: typeof Stylus = require(stylusPath)
+
+        const ref = nodeStylus(content, options)
+        if (options.define) {
+          for (const key in options.define) {
+            ref.define(key, options.define[key])
+          }
+        }
+        if (options.enableSourcemap) {
+          ref.set('sourcemap', {
+            comment: false,
+            inline: false,
+            basePath: root,
+          })
+        }
+
+        return {
+          code: ref.render(),
+          // @ts-expect-error sourcemap exists
+          map: ref.sourcemap as ExistingRawSourceMap | undefined,
+          deps: ref.deps(),
+        }
+      }
+    },
+    {
+      shouldUseFake(_stylusPath, _content, _root, options) {
+        // define can include functions and those are not serializable
+        // in that case, fallback to running in main thread
+        return !!(
+          options.define &&
+          Object.values(options.define).some((d) => typeof d === 'function')
+        )
+      },
+      max: maxWorkers,
+    },
+  )
+  return worker
+}
+
+export const stylProcessor = (
+  maxWorkers: number | undefined,
+): StylusStylePreprocessor => {
+  const workerMap = new Map<unknown, ReturnType<typeof makeStylWorker>>()
+
+  return {
+    close() {
+      for (const worker of workerMap.values()) {
+        worker.stop()
+      }
+    },
+    async process(source, root, options, resolvers) {
+      const stylusPath = loadPreprocessorPath(PreprocessLang.stylus, root)
+
+      if (!workerMap.has(options.alias)) {
+        workerMap.set(options.alias, makeStylWorker(maxWorkers))
+      }
+      const worker = workerMap.get(options.alias)!
+
+      // Get source with preprocessor options.additionalData. Make sure a new line separator
+      // is added to avoid any render error, as added stylus content may not have semi-colon separators
+      const { content, map: additionalMap } = await getSource(
+        source,
+        options.filename,
+        options.additionalData,
+        options.enableSourcemap,
+        '\n',
+      )
+      // Get preprocessor options.imports dependencies as stylus
+      // does not return them with its builtin `.deps()` method
+      const importsDeps = (options.imports ?? []).map((dep: string) =>
+        path.resolve(dep),
+      )
+      const optionsWithoutAdditionalData = {
+        ...options,
+        additionalData: undefined,
+      }
+      try {
+        const { code, map, deps } = await worker.run(
+          stylusPath,
+          content,
+          root,
+          optionsWithoutAdditionalData,
+        )
+        return {
+          code,
+          map: formatStylusSourceMap(map, root),
+          additionalMap,
+          // Concat imports deps with computed deps
+          deps: [...deps, ...importsDeps],
+        }
+      } catch (e) {
+        const wrapped = new Error(`[stylus] ${e.message}`)
+        wrapped.name = e.name
+        wrapped.stack = e.stack
+        return { code: '', error: wrapped, deps: [] }
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/define.ts b/packages/vite/src/node/plugins/define.ts
index 585bc0154..ef6bfd644 100644
--- a/packages/vite/src/node/plugins/define.ts
+++ b/packages/vite/src/node/plugins/define.ts
@@ -1,9 +1,11 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
 import { transform } from 'esbuild'
 import { TraceMap, decodedMap, encodedMap } from '@jridgewell/trace-mapping'
-import type { ResolvedConfig } from '../config'
 import type { Plugin } from '../plugin'
 import { escapeRegex } from '../utils'
-import { isCSSRequest } from './css'
 import { isHTMLRequest } from './html'
 
 const nonJsRe = /\.json(?:$|\?)/
diff --git a/packages/vite/src/node/plugins/dynamicImportVars.ts b/packages/vite/src/node/plugins/dynamicImportVars.ts
index 8c55632a7..bed219778 100644
--- a/packages/vite/src/node/plugins/dynamicImportVars.ts
+++ b/packages/vite/src/node/plugins/dynamicImportVars.ts
@@ -1,3 +1,4 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import { posix } from 'node:path'
 import MagicString from 'magic-string'
 import { init, parse as parseImports } from 'es-module-lexer'
@@ -5,7 +6,6 @@ import type { ImportSpecifier } from 'es-module-lexer'
 import { parseAst } from 'rollup/parseAst'
 import { dynamicImportToGlob } from '@rollup/plugin-dynamic-import-vars'
 import type { Plugin } from '../plugin'
-import type { ResolvedConfig } from '../config'
 import { CLIENT_ENTRY } from '../constants'
 import {
   createFilter,
diff --git a/packages/vite/src/node/plugins/esbuild.ts b/packages/vite/src/node/plugins/esbuild.ts
index fda6ca02a..b041a5e1f 100644
--- a/packages/vite/src/node/plugins/esbuild.ts
+++ b/packages/vite/src/node/plugins/esbuild.ts
@@ -1,3 +1,7 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import path from 'node:path'
 import colors from 'picocolors'
 import type {
@@ -18,8 +22,6 @@ import {
   ensureWatchedFile,
   generateCodeFrame,
 } from '../utils'
-import type { ViteDevServer } from '../server'
-import type { ResolvedConfig } from '../config'
 import type { Plugin } from '../plugin'
 import { cleanUrl } from '../../shared/utils'
 
diff --git a/packages/vite/src/node/plugins/html.ts b/packages/vite/src/node/plugins/html.ts
index b7109debc..53b83e3f0 100644
--- a/packages/vite/src/node/plugins/html.ts
+++ b/packages/vite/src/node/plugins/html.ts
@@ -1,3 +1,10 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import path from 'node:path'
 import type {
   OutputAsset,
@@ -11,7 +18,6 @@ import colors from 'picocolors'
 import type { DefaultTreeAdapterMap, ParserError, Token } from 'parse5'
 import { stripLiteral } from 'strip-literal'
 import type { Plugin } from '../plugin'
-import type { ViteDevServer } from '../server'
 import {
   encodeURIPath,
   generateCodeFrame,
@@ -25,7 +31,6 @@ import {
   unique,
   urlCanParse,
 } from '../utils'
-import type { ResolvedConfig } from '../config'
 import { checkPublicFile } from '../publicDir'
 import { toOutputFilePathInHtml } from '../build'
 import { resolveEnvPrefix } from '../env'
@@ -37,7 +42,6 @@ import {
   publicAssetUrlRE,
   urlToBuiltUrl,
 } from './asset'
-import { isCSSRequest } from './css'
 import { modulePreloadPolyfillId } from './modulePreloadPolyfill'
 
 interface ScriptAssetsUrl {
diff --git a/packages/vite/src/node/plugins/importAnalysis.ts b/packages/vite/src/node/plugins/importAnalysis.ts
index 8027bae9a..f9b95778a 100644
--- a/packages/vite/src/node/plugins/importAnalysis.ts
+++ b/packages/vite/src/node/plugins/importAnalysis.ts
@@ -1,3 +1,30 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isDirectCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { debugHmr } from 'packages/vite/src/node/server/hmr/isNodeWithinCircularImports';
+import { lexAcceptedHmrDeps } from 'packages/vite/src/node/server/hmr/lexAcceptedHmrDeps';
+import { extractImportedBindings } from 'packages/vite/src/node/plugins/importAnalysis/extractImportedBindings';
+import { extractImportedBindings } from 'packages/vite/src/node/plugins/importAnalysis';
+import { clientDir } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { canSkipImportAnalysis } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { optimizedDepChunkRE } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { optimizedDepDynamicRE } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { urlIsStringRE } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { templateLiteralRE } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { isExplicitImportRequired } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { extractImportedBindings } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { importAnalysisPlugin } from 'packages/vite/src/node/plugins/importAnalysis';
+import { interopHelper } from 'packages/vite/src/node/plugins/importAnalysis/interopNamedImports';
+import { interopNamedImports } from 'packages/vite/src/node/plugins/importAnalysis/interopNamedImports';
+import { interopNamedImports } from 'packages/vite/src/node/plugins/importAnalysis';
+import { interopHelper } from 'packages/vite/src/node/plugins/importAnalysis/transformCjsImport';
+import { ImportNameSpecifier } from 'packages/vite/src/node/plugins/importAnalysis/transformCjsImport';
+import { transformCjsImport } from 'packages/vite/src/node/plugins/importAnalysis/transformCjsImport';
+import { transformCjsImport } from 'packages/vite/src/node/plugins/importAnalysis';
+import { browserExternalId } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { browserExternalId } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
 import path from 'node:path'
 import { performance } from 'node:perf_hooks'
 import colors from 'picocolors'
@@ -21,9 +48,7 @@ import {
   SPECIAL_QUERY_RE,
 } from '../constants'
 import {
-  debugHmr,
   handlePrunedModules,
-  lexAcceptedHmrDeps,
   lexAcceptedHmrExports,
   normalizeHmrUrl,
 } from '../server/hmr'
@@ -53,7 +78,6 @@ import {
 import { getFsUtils } from '../fsUtils'
 import { checkPublicFile } from '../publicDir'
 import { getDepOptimizationConfig } from '../config'
-import type { ResolvedConfig } from '../config'
 import type { Plugin } from '../plugin'
 import { shouldExternalizeForSSR } from '../ssr/ssrExternal'
 import { getDepsOptimizer, optimizedDepNeedsInterop } from '../optimizer'
@@ -65,760 +89,21 @@ import {
 } from '../../shared/utils'
 import type { TransformPluginContext } from '../server/pluginContainer'
 import { throwOutdatedRequest } from './optimizedDeps'
-import { isCSSRequest, isDirectCSSRequest } from './css'
-import { browserExternalId } from './resolve'
 import { serializeDefine } from './define'
 import { WORKER_FILE_ID } from './worker'
 import { getAliasPatternMatcher } from './preAlias'
 
 const debug = createDebugger('vite:import-analysis')
-
-const clientDir = normalizePath(CLIENT_DIR)
-
-const skipRE = /\.(?:map|json)(?:$|\?)/
-export const canSkipImportAnalysis = (id: string): boolean =>
-  skipRE.test(id) || isDirectCSSRequest(id)
-
-const optimizedDepChunkRE = /\/chunk-[A-Z\d]{8}\.js/
-const optimizedDepDynamicRE = /-[A-Z\d]{8}\.js/
+export 
 
 export const hasViteIgnoreRE = /\/\*\s*@vite-ignore\s*\*\//
 
-const urlIsStringRE = /^(?:'.*'|".*"|`.*`)$/
-
-const templateLiteralRE = /^\s*`(.*)`\s*$/
-
 interface UrlPosition {
   url: string
   start: number
   end: number
 }
 
-export function isExplicitImportRequired(url: string): boolean {
-  return !isJSRequest(url) && !isCSSRequest(url)
-}
-
-function extractImportedBindings(
-  id: string,
-  source: string,
-  importSpec: ImportSpecifier,
-  importedBindings: Map<string, Set<string>>,
-) {
-  let bindings = importedBindings.get(id)
-  if (!bindings) {
-    bindings = new Set<string>()
-    importedBindings.set(id, bindings)
-  }
-
-  const isDynamic = importSpec.d > -1
-  const isMeta = importSpec.d === -2
-  if (isDynamic || isMeta) {
-    // this basically means the module will be impacted by any change in its dep
-    bindings.add('*')
-    return
-  }
-
-  const exp = source.slice(importSpec.ss, importSpec.se)
-  ESM_STATIC_IMPORT_RE.lastIndex = 0
-  const match = ESM_STATIC_IMPORT_RE.exec(exp)
-  if (!match) {
-    return
-  }
-
-  const staticImport: StaticImport = {
-    type: 'static',
-    code: match[0],
-    start: match.index,
-    end: match.index + match[0].length,
-    imports: match.groups!.imports,
-    specifier: match.groups!.specifier,
-  }
-  const parsed = parseStaticImport(staticImport)
-  if (!parsed) {
-    return
-  }
-  if (parsed.namespacedImport) {
-    bindings.add('*')
-  }
-  if (parsed.defaultImport) {
-    bindings.add('default')
-  }
-  if (parsed.namedImports) {
-    for (const name of Object.keys(parsed.namedImports)) {
-      bindings.add(name)
-    }
-  }
-}
-
-/**
- * Server-only plugin that lexes, resolves, rewrites and analyzes url imports.
- *
- * - Imports are resolved to ensure they exist on disk
- *
- * - Lexes HMR accept calls and updates import relationships in the module graph
- *
- * - Bare module imports are resolved (by @rollup-plugin/node-resolve) to
- * absolute file paths, e.g.
- *
- *     ```js
- *     import 'foo'
- *     ```
- *     is rewritten to
- *     ```js
- *     import '/@fs//project/node_modules/foo/dist/foo.js'
- *     ```
- *
- * - CSS imports are appended with `.js` since both the js module and the actual
- * css (referenced via `<link>`) may go through the transform pipeline:
- *
- *     ```js
- *     import './style.css'
- *     ```
- *     is rewritten to
- *     ```js
- *     import './style.css.js'
- *     ```
- */
-export function importAnalysisPlugin(config: ResolvedConfig): Plugin {
-  const { root, base } = config
-  const fsUtils = getFsUtils(config)
-  const clientPublicPath = path.posix.join(base, CLIENT_PUBLIC_PATH)
-  const enablePartialAccept = config.experimental?.hmrPartialAccept
-  const matchAlias = getAliasPatternMatcher(config.resolve.alias)
-  let server: ViteDevServer
-
-  let _env: string | undefined
-  let _ssrEnv: string | undefined
-  function getEnv(ssr: boolean) {
-    if (!_ssrEnv || !_env) {
-      const importMetaEnvKeys: Record<string, any> = {}
-      const userDefineEnv: Record<string, any> = {}
-      for (const key in config.env) {
-        importMetaEnvKeys[key] = JSON.stringify(config.env[key])
-      }
-      for (const key in config.define) {
-        // non-import.meta.env.* is handled in `clientInjection` plugin
-        if (key.startsWith('import.meta.env.')) {
-          userDefineEnv[key.slice(16)] = config.define[key]
-        }
-      }
-      const env = `import.meta.env = ${serializeDefine({
-        ...importMetaEnvKeys,
-        SSR: '__vite_ssr__',
-        ...userDefineEnv,
-      })};`
-      _ssrEnv = env.replace('__vite_ssr__', 'true')
-      _env = env.replace('__vite_ssr__', 'false')
-    }
-    return ssr ? _ssrEnv : _env
-  }
-
-  return {
-    name: 'vite:import-analysis',
-
-    configureServer(_server) {
-      server = _server
-    },
-
-    async transform(source, importer, options) {
-      // In a real app `server` is always defined, but it is undefined when
-      // running src/node/server/__tests__/pluginContainer.spec.ts
-      if (!server) {
-        return null
-      }
-
-      const ssr = options?.ssr === true
-
-      if (canSkipImportAnalysis(importer)) {
-        debug?.(colors.dim(`[skipped] ${prettifyUrl(importer, root)}`))
-        return null
-      }
-
-      const msAtStart = debug ? performance.now() : 0
-      await init
-      let imports!: readonly ImportSpecifier[]
-      let exports!: readonly ExportSpecifier[]
-      source = stripBomTag(source)
-      try {
-        ;[imports, exports] = parseImports(source)
-      } catch (_e: unknown) {
-        const e = _e as EsModuleLexerParseError
-        const { message, showCodeFrame } = createParseErrorInfo(
-          importer,
-          source,
-        )
-        this.error(message, showCodeFrame ? e.idx : undefined)
-      }
-
-      const depsOptimizer = getDepsOptimizer(config, ssr)
-
-      const { moduleGraph } = server
-      // since we are already in the transform phase of the importer, it must
-      // have been loaded so its entry is guaranteed in the module graph.
-      const importerModule = moduleGraph.getModuleById(importer)!
-      if (!importerModule) {
-        // This request is no longer valid. It could happen for optimized deps
-        // requests. A full reload is going to request this id again.
-        // Throwing an outdated error so we properly finish the request with a
-        // 504 sent to the browser.
-        throwOutdatedRequest(importer)
-      }
-
-      if (
-        !imports.length &&
-        !(this as unknown as TransformPluginContext)._addedImports
-      ) {
-        importerModule.isSelfAccepting = false
-        debug?.(
-          `${timeFrom(msAtStart)} ${colors.dim(
-            `[no imports] ${prettifyUrl(importer, root)}`,
-          )}`,
-        )
-        return source
-      }
-
-      let hasHMR = false
-      let isSelfAccepting = false
-      let hasEnv = false
-      let needQueryInjectHelper = false
-      let s: MagicString | undefined
-      const str = () => s || (s = new MagicString(source))
-      let isPartiallySelfAccepting = false
-      const importedBindings = enablePartialAccept
-        ? new Map<string, Set<string>>()
-        : null
-      const toAbsoluteUrl = (url: string) =>
-        path.posix.resolve(path.posix.dirname(importerModule.url), url)
-
-      const normalizeUrl = async (
-        url: string,
-        pos: number,
-        forceSkipImportAnalysis: boolean = false,
-      ): Promise<[string, string]> => {
-        url = stripBase(url, base)
-
-        let importerFile = importer
-
-        const optimizeDeps = getDepOptimizationConfig(config, ssr)
-        if (moduleListContains(optimizeDeps?.exclude, url)) {
-          if (depsOptimizer) {
-            await depsOptimizer.scanProcessing
-
-            // if the dependency encountered in the optimized file was excluded from the optimization
-            // the dependency needs to be resolved starting from the original source location of the optimized file
-            // because starting from node_modules/.vite will not find the dependency if it was not hoisted
-            // (that is, if it is under node_modules directory in the package source of the optimized file)
-            for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
-              if (!optimizedModule.src) continue // Ignore chunks
-              if (optimizedModule.file === importerModule.file) {
-                importerFile = optimizedModule.src
-              }
-            }
-          }
-        }
-
-        const resolved = await this.resolve(url, importerFile)
-
-        if (!resolved || resolved.meta?.['vite:alias']?.noResolved) {
-          // in ssr, we should let node handle the missing modules
-          if (ssr) {
-            return [url, url]
-          }
-          // fix#9534, prevent the importerModuleNode being stopped from propagating updates
-          importerModule.isSelfAccepting = false
-          moduleGraph._hasResolveFailedErrorModules.add(importerModule)
-          return this.error(
-            `Failed to resolve import "${url}" from "${normalizePath(
-              path.relative(process.cwd(), importerFile),
-            )}". Does the file exist?`,
-            pos,
-          )
-        }
-
-        if (isExternalUrl(resolved.id)) {
-          return [resolved.id, resolved.id]
-        }
-
-        const isRelative = url[0] === '.'
-        const isSelfImport = !isRelative && cleanUrl(url) === cleanUrl(importer)
-
-        // normalize all imports into resolved URLs
-        // e.g. `import 'foo'` -> `import '/@fs/.../node_modules/foo/index.js'`
-        if (resolved.id.startsWith(withTrailingSlash(root))) {
-          // in root: infer short absolute path from root
-          url = resolved.id.slice(root.length)
-        } else if (
-          depsOptimizer?.isOptimizedDepFile(resolved.id) ||
-          // vite-plugin-react isn't following the leading \0 virtual module convention.
-          // This is a temporary hack to avoid expensive fs checks for React apps.
-          // We'll remove this as soon we're able to fix the react plugins.
-          (resolved.id !== '/@react-refresh' &&
-            path.isAbsolute(resolved.id) &&
-            fsUtils.existsSync(cleanUrl(resolved.id)))
-        ) {
-          // an optimized deps may not yet exists in the filesystem, or
-          // a regular file exists but is out of root: rewrite to absolute /@fs/ paths
-          url = path.posix.join(FS_PREFIX, resolved.id)
-        } else {
-          url = resolved.id
-        }
-
-        // if the resolved id is not a valid browser import specifier,
-        // prefix it to make it valid. We will strip this before feeding it
-        // back into the transform pipeline
-        if (url[0] !== '.' && url[0] !== '/') {
-          url = wrapId(resolved.id)
-        }
-
-        // make the URL browser-valid if not SSR
-        if (!ssr) {
-          // mark non-js/css imports with `?import`
-          if (isExplicitImportRequired(url)) {
-            url = injectQuery(url, 'import')
-          } else if (
-            (isRelative || isSelfImport) &&
-            !DEP_VERSION_RE.test(url)
-          ) {
-            // If the url isn't a request for a pre-bundled common chunk,
-            // for relative js/css imports, or self-module virtual imports
-            // (e.g. vue blocks), inherit importer's version query
-            // do not do this for unknown type imports, otherwise the appended
-            // query can break 3rd party plugin's extension checks.
-            const versionMatch = DEP_VERSION_RE.exec(importer)
-            if (versionMatch) {
-              url = injectQuery(url, versionMatch[1])
-            }
-          }
-
-          // check if the dep has been hmr updated. If yes, we need to attach
-          // its last updated timestamp to force the browser to fetch the most
-          // up-to-date version of this module.
-          try {
-            // delay setting `isSelfAccepting` until the file is actually used (#7870)
-            // We use an internal function to avoid resolving the url again
-            const depModule = await moduleGraph._ensureEntryFromUrl(
-              unwrapId(url),
-              ssr,
-              canSkipImportAnalysis(url) || forceSkipImportAnalysis,
-              resolved,
-            )
-            if (depModule.lastHMRTimestamp > 0) {
-              url = injectQuery(url, `t=${depModule.lastHMRTimestamp}`)
-            }
-          } catch (e: any) {
-            // it's possible that the dep fails to resolve (non-existent import)
-            // attach location to the missing import
-            e.pos = pos
-            throw e
-          }
-
-          // prepend base
-          url = joinUrlSegments(base, url)
-        }
-
-        return [url, resolved.id]
-      }
-
-      const orderedImportedUrls = new Array<string | undefined>(imports.length)
-      const orderedAcceptedUrls = new Array<Set<UrlPosition> | undefined>(
-        imports.length,
-      )
-      const orderedAcceptedExports = new Array<Set<string> | undefined>(
-        imports.length,
-      )
-
-      await Promise.all(
-        imports.map(async (importSpecifier, index) => {
-          const {
-            s: start,
-            e: end,
-            ss: expStart,
-            se: expEnd,
-            d: dynamicIndex,
-            a: attributeIndex,
-          } = importSpecifier
-
-          // #2083 User may use escape path,
-          // so use imports[index].n to get the unescaped string
-          let specifier = importSpecifier.n
-
-          const rawUrl = source.slice(start, end)
-
-          // check import.meta usage
-          if (rawUrl === 'import.meta') {
-            const prop = source.slice(end, end + 4)
-            if (prop === '.hot') {
-              hasHMR = true
-              const endHot = end + 4 + (source[end + 4] === '?' ? 1 : 0)
-              if (source.slice(endHot, endHot + 7) === '.accept') {
-                // further analyze accepted modules
-                if (source.slice(endHot, endHot + 14) === '.acceptExports') {
-                  const importAcceptedExports = (orderedAcceptedExports[index] =
-                    new Set<string>())
-                  lexAcceptedHmrExports(
-                    source,
-                    source.indexOf('(', endHot + 14) + 1,
-                    importAcceptedExports,
-                  )
-                  isPartiallySelfAccepting = true
-                } else {
-                  const importAcceptedUrls = (orderedAcceptedUrls[index] =
-                    new Set<UrlPosition>())
-                  if (
-                    lexAcceptedHmrDeps(
-                      source,
-                      source.indexOf('(', endHot + 7) + 1,
-                      importAcceptedUrls,
-                    )
-                  ) {
-                    isSelfAccepting = true
-                  }
-                }
-              }
-            } else if (prop === '.env') {
-              hasEnv = true
-            }
-            return
-          } else if (templateLiteralRE.test(rawUrl)) {
-            // If the import has backticks but isn't transformed as a glob import
-            // (as there's nothing to glob), check if it's simply a plain string.
-            // If so, we can replace the specifier as a plain string to prevent
-            // an incorrect "cannot be analyzed" warning.
-            if (!(rawUrl.includes('${') && rawUrl.includes('}'))) {
-              specifier = rawUrl.replace(templateLiteralRE, '$1')
-            }
-          }
-
-          const isDynamicImport = dynamicIndex > -1
-
-          // strip import attributes as we can process them ourselves
-          if (!isDynamicImport && attributeIndex > -1) {
-            str().remove(end + 1, expEnd)
-          }
-
-          // static import or valid string in dynamic import
-          // If resolvable, let's resolve it
-          if (specifier !== undefined) {
-            // skip external / data uri
-            if (isExternalUrl(specifier) || isDataUrl(specifier)) {
-              return
-            }
-            // skip ssr external
-            if (ssr && !matchAlias(specifier)) {
-              if (shouldExternalizeForSSR(specifier, importer, config)) {
-                return
-              }
-              if (isBuiltin(specifier)) {
-                return
-              }
-            }
-            // skip client
-            if (specifier === clientPublicPath) {
-              return
-            }
-
-            // warn imports to non-asset /public files
-            if (
-              specifier[0] === '/' &&
-              !(
-                config.assetsInclude(cleanUrl(specifier)) ||
-                urlRE.test(specifier)
-              ) &&
-              checkPublicFile(specifier, config)
-            ) {
-              throw new Error(
-                `Cannot import non-asset file ${specifier} which is inside /public. ` +
-                  `JS/CSS files inside /public are copied as-is on build and ` +
-                  `can only be referenced via <script src> or <link href> in html. ` +
-                  `If you want to get the URL of that file, use ${injectQuery(
-                    specifier,
-                    'url',
-                  )} instead.`,
-              )
-            }
-
-            // normalize
-            const [url, resolvedId] = await normalizeUrl(specifier, start)
-
-            // record as safe modules
-            // safeModulesPath should not include the base prefix.
-            // See https://github.com/vitejs/vite/issues/9438#issuecomment-1465270409
-            server?.moduleGraph.safeModulesPath.add(
-              fsPathFromUrl(stripBase(url, base)),
-            )
-
-            if (url !== specifier) {
-              let rewriteDone = false
-              if (
-                depsOptimizer?.isOptimizedDepFile(resolvedId) &&
-                !optimizedDepChunkRE.test(resolvedId)
-              ) {
-                // for optimized cjs deps, support named imports by rewriting named imports to const assignments.
-                // internal optimized chunks don't need es interop and are excluded
-
-                // The browserHash in resolvedId could be stale in which case there will be a full
-                // page reload. We could return a 404 in that case but it is safe to return the request
-                const file = cleanUrl(resolvedId) // Remove ?v={hash}
-
-                const needsInterop = await optimizedDepNeedsInterop(
-                  depsOptimizer.metadata,
-                  file,
-                  config,
-                  ssr,
-                )
-
-                if (needsInterop === undefined) {
-                  // Non-entry dynamic imports from dependencies will reach here as there isn't
-                  // optimize info for them, but they don't need es interop. If the request isn't
-                  // a dynamic import, then it is an internal Vite error
-                  if (!optimizedDepDynamicRE.test(file)) {
-                    config.logger.error(
-                      colors.red(
-                        `Vite Error, ${url} optimized info should be defined`,
-                      ),
-                    )
-                  }
-                } else if (needsInterop) {
-                  debug?.(`${url} needs interop`)
-                  interopNamedImports(
-                    str(),
-                    importSpecifier,
-                    url,
-                    index,
-                    importer,
-                    config,
-                  )
-                  rewriteDone = true
-                }
-              }
-              // If source code imports builtin modules via named imports, the stub proxy export
-              // would fail as it's `export default` only. Apply interop for builtin modules to
-              // correctly throw the error message.
-              else if (
-                url.includes(browserExternalId) &&
-                source.slice(expStart, start).includes('{')
-              ) {
-                interopNamedImports(
-                  str(),
-                  importSpecifier,
-                  url,
-                  index,
-                  importer,
-                  config,
-                )
-                rewriteDone = true
-              }
-              if (!rewriteDone) {
-                const rewrittenUrl = JSON.stringify(url)
-                const s = isDynamicImport ? start : start - 1
-                const e = isDynamicImport ? end : end + 1
-                str().overwrite(s, e, rewrittenUrl, {
-                  contentOnly: true,
-                })
-              }
-            }
-
-            // record for HMR import chain analysis
-            // make sure to unwrap and normalize away base
-            const hmrUrl = unwrapId(stripBase(url, base))
-            const isLocalImport = !isExternalUrl(hmrUrl) && !isDataUrl(hmrUrl)
-            if (isLocalImport) {
-              orderedImportedUrls[index] = hmrUrl
-            }
-
-            if (enablePartialAccept && importedBindings) {
-              extractImportedBindings(
-                resolvedId,
-                source,
-                importSpecifier,
-                importedBindings,
-              )
-            }
-
-            if (
-              !isDynamicImport &&
-              isLocalImport &&
-              config.server.preTransformRequests
-            ) {
-              // pre-transform known direct imports
-              // These requests will also be registered in transformRequest to be awaited
-              // by the deps optimizer
-              const url = removeImportQuery(hmrUrl)
-              server.warmupRequest(url, { ssr })
-            }
-          } else if (!importer.startsWith(withTrailingSlash(clientDir))) {
-            if (!isInNodeModules(importer)) {
-              // check @vite-ignore which suppresses dynamic import warning
-              const hasViteIgnore = hasViteIgnoreRE.test(
-                // complete expression inside parens
-                source.slice(dynamicIndex + 1, end),
-              )
-              if (!hasViteIgnore) {
-                this.warn(
-                  `\n` +
-                    colors.cyan(importerModule.file) +
-                    `\n` +
-                    colors.reset(generateCodeFrame(source, start, end)) +
-                    colors.yellow(
-                      `\nThe above dynamic import cannot be analyzed by Vite.\n` +
-                        `See ${colors.blue(
-                          `https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`,
-                        )} ` +
-                        `for supported dynamic import formats. ` +
-                        `If this is intended to be left as-is, you can use the ` +
-                        `/* @vite-ignore */ comment inside the import() call to suppress this warning.\n`,
-                    ),
-                )
-              }
-            }
-
-            if (!ssr) {
-              if (
-                !urlIsStringRE.test(rawUrl) ||
-                isExplicitImportRequired(rawUrl.slice(1, -1))
-              ) {
-                needQueryInjectHelper = true
-                str().overwrite(
-                  start,
-                  end,
-                  `__vite__injectQuery(${rawUrl}, 'import')`,
-                  { contentOnly: true },
-                )
-              }
-            }
-          }
-        }),
-      )
-
-      const _orderedImportedUrls = orderedImportedUrls.filter(isDefined)
-      const importedUrls = new Set(_orderedImportedUrls)
-      // `importedUrls` will be mixed with watched files for the module graph,
-      // `staticImportedUrls` will only contain the static top-level imports and
-      // dynamic imports
-      const staticImportedUrls = new Set(
-        _orderedImportedUrls.map((url) => removeTimestampQuery(url)),
-      )
-      const acceptedUrls = mergeAcceptedUrls(orderedAcceptedUrls)
-      const acceptedExports = mergeAcceptedUrls(orderedAcceptedExports)
-
-      // While we always expect to work with ESM, a classic worker is the only
-      // case where it's not ESM and we need to avoid injecting ESM-specific code
-      const isClassicWorker =
-        importer.includes(WORKER_FILE_ID) && importer.includes('type=classic')
-
-      if (hasEnv && !isClassicWorker) {
-        // inject import.meta.env
-        str().prepend(getEnv(ssr))
-      }
-
-      if (hasHMR && !ssr && !isClassicWorker) {
-        debugHmr?.(
-          `${
-            isSelfAccepting
-              ? `[self-accepts]`
-              : isPartiallySelfAccepting
-                ? `[accepts-exports]`
-                : acceptedUrls.size
-                  ? `[accepts-deps]`
-                  : `[detected api usage]`
-          } ${prettifyUrl(importer, root)}`,
-        )
-        // inject hot context
-        str().prepend(
-          `import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";` +
-            `import.meta.hot = __vite__createHotContext(${JSON.stringify(
-              normalizeHmrUrl(importerModule.url),
-            )});`,
-        )
-      }
-
-      if (needQueryInjectHelper) {
-        if (isClassicWorker) {
-          str().append('\n' + __vite__injectQuery.toString())
-        } else {
-          str().prepend(
-            `import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`,
-          )
-        }
-      }
-
-      // normalize and rewrite accepted urls
-      const normalizedAcceptedUrls = new Set<string>()
-      for (const { url, start, end } of acceptedUrls) {
-        const [normalized] = await moduleGraph.resolveUrl(
-          toAbsoluteUrl(url),
-          ssr,
-        )
-        normalizedAcceptedUrls.add(normalized)
-        str().overwrite(start, end, JSON.stringify(normalized), {
-          contentOnly: true,
-        })
-      }
-
-      // update the module graph for HMR analysis.
-      // node CSS imports does its own graph update in the css-analysis plugin so we
-      // only handle js graph updates here.
-      // note that we want to handle .css?raw and .css?url here
-      if (!isCSSRequest(importer) || SPECIAL_QUERY_RE.test(importer)) {
-        // attached by pluginContainer.addWatchFile
-        const pluginImports = (this as unknown as TransformPluginContext)
-          ._addedImports
-        if (pluginImports) {
-          ;(
-            await Promise.all(
-              [...pluginImports].map((id) => normalizeUrl(id, 0, true)),
-            )
-          ).forEach(([url]) => importedUrls.add(url))
-        }
-        // HMR transforms are no-ops in SSR, so an `accept` call will
-        // never be injected. Avoid updating the `isSelfAccepting`
-        // property for our module node in that case.
-        if (ssr && importerModule.isSelfAccepting) {
-          isSelfAccepting = true
-        }
-        // a partially accepted module that accepts all its exports
-        // behaves like a self-accepted module in practice
-        if (
-          !isSelfAccepting &&
-          isPartiallySelfAccepting &&
-          acceptedExports.size >= exports.length &&
-          exports.every((e) => acceptedExports.has(e.n))
-        ) {
-          isSelfAccepting = true
-        }
-        const prunedImports = await moduleGraph.updateModuleInfo(
-          importerModule,
-          importedUrls,
-          importedBindings,
-          normalizedAcceptedUrls,
-          isPartiallySelfAccepting ? acceptedExports : null,
-          isSelfAccepting,
-          ssr,
-          staticImportedUrls,
-        )
-        if (hasHMR && prunedImports) {
-          handlePrunedModules(prunedImports, server)
-        }
-      }
-
-      debug?.(
-        `${timeFrom(msAtStart)} ${colors.dim(
-          `[${importedUrls.size} imports rewritten] ${prettifyUrl(
-            importer,
-            root,
-          )}`,
-        )}`,
-      )
-
-      if (s) {
-        return transformStableResult(s, importer, config)
-      } else {
-        return source
-      }
-    },
-  }
-}
-
 function mergeAcceptedUrls<T>(orderedUrls: Array<Set<T> | undefined>) {
   const acceptedUrls = new Set<T>()
   for (const urls of orderedUrls) {
@@ -859,184 +144,12 @@ export function createParseErrorInfo(
     showCodeFrame: !probablyBinary,
   }
 }
-// prettier-ignore
-const interopHelper = (m: any) => m?.__esModule ? m : { ...(typeof m === 'object' && !Array.isArray(m) || typeof m === 'function' ? m : {}), default: m }
-
-export function interopNamedImports(
-  str: MagicString,
-  importSpecifier: ImportSpecifier,
-  rewrittenUrl: string,
-  importIndex: number,
-  importer: string,
-  config: ResolvedConfig,
-): void {
-  const source = str.original
-  const {
-    s: start,
-    e: end,
-    ss: expStart,
-    se: expEnd,
-    d: dynamicIndex,
-  } = importSpecifier
-  const exp = source.slice(expStart, expEnd)
-  if (dynamicIndex > -1) {
-    // rewrite `import('package')` to expose the default directly
-    str.overwrite(
-      expStart,
-      expEnd,
-      `import('${rewrittenUrl}').then(m => (${interopHelper.toString()})(m.default))` +
-        getLineBreaks(exp),
-      { contentOnly: true },
-    )
-  } else {
-    const rawUrl = source.slice(start, end)
-    const rewritten = transformCjsImport(
-      exp,
-      rewrittenUrl,
-      rawUrl,
-      importIndex,
-      importer,
-      config,
-    )
-    if (rewritten) {
-      str.overwrite(expStart, expEnd, rewritten + getLineBreaks(exp), {
-        contentOnly: true,
-      })
-    } else {
-      // #1439 export * from '...'
-      str.overwrite(
-        start,
-        end,
-        rewrittenUrl + getLineBreaks(source.slice(start, end)),
-        {
-          contentOnly: true,
-        },
-      )
-    }
-  }
-}
 
 // get line breaks to preserve line count for not breaking source maps
 function getLineBreaks(str: string) {
   return str.includes('\n') ? '\n'.repeat(str.split('\n').length - 1) : ''
 }
 
-type ImportNameSpecifier = { importedName: string; localName: string }
-
-/**
- * Detect import statements to a known optimized CJS dependency and provide
- * ES named imports interop. We do this by rewriting named imports to a variable
- * assignment to the corresponding property on the `module.exports` of the cjs
- * module. Note this doesn't support dynamic re-assignments from within the cjs
- * module.
- *
- * Note that es-module-lexer treats `export * from '...'` as an import as well,
- * so, we may encounter ExportAllDeclaration here, in which case `undefined`
- * will be returned.
- *
- * Credits \@csr632 via #837
- */
-export function transformCjsImport(
-  importExp: string,
-  url: string,
-  rawUrl: string,
-  importIndex: number,
-  importer: string,
-  config: ResolvedConfig,
-): string | undefined {
-  const node = parseAst(importExp).body[0]
-
-  // `export * from '...'` may cause unexpected problem, so give it a warning
-  if (
-    config.command === 'serve' &&
-    node.type === 'ExportAllDeclaration' &&
-    !node.exported
-  ) {
-    config.logger.warn(
-      colors.yellow(
-        `\nUnable to interop \`${importExp}\` in ${importer}, this may lose module exports. Please export "${rawUrl}" as ESM or use named exports instead, e.g. \`export { A, B } from "${rawUrl}"\``,
-      ),
-    )
-  } else if (
-    node.type === 'ImportDeclaration' ||
-    node.type === 'ExportNamedDeclaration'
-  ) {
-    if (!node.specifiers.length) {
-      return `import "${url}"`
-    }
-
-    const importNames: ImportNameSpecifier[] = []
-    const exportNames: string[] = []
-    let defaultExports: string = ''
-    for (const spec of node.specifiers) {
-      if (
-        spec.type === 'ImportSpecifier' &&
-        spec.imported.type === 'Identifier'
-      ) {
-        const importedName = spec.imported.name
-        const localName = spec.local.name
-        importNames.push({ importedName, localName })
-      } else if (spec.type === 'ImportDefaultSpecifier') {
-        importNames.push({
-          importedName: 'default',
-          localName: spec.local.name,
-        })
-      } else if (spec.type === 'ImportNamespaceSpecifier') {
-        importNames.push({ importedName: '*', localName: spec.local.name })
-      } else if (
-        spec.type === 'ExportSpecifier' &&
-        spec.exported.type === 'Identifier'
-      ) {
-        // for ExportSpecifier, local name is same as imported name
-        // prefix the variable name to avoid clashing with other local variables
-        const importedName = spec.local.name
-        // we want to specify exported name as variable and re-export it
-        const exportedName = spec.exported.name
-        if (exportedName === 'default') {
-          defaultExports = makeLegalIdentifier(
-            `__vite__cjsExportDefault_${importIndex}`,
-          )
-          importNames.push({ importedName, localName: defaultExports })
-        } else {
-          const localName = makeLegalIdentifier(
-            `__vite__cjsExport_${exportedName}`,
-          )
-          importNames.push({ importedName, localName })
-          exportNames.push(`${localName} as ${exportedName}`)
-        }
-      }
-    }
-
-    // If there is multiple import for same id in one file,
-    // importIndex will prevent the cjsModuleName to be duplicate
-    const cjsModuleName = makeLegalIdentifier(
-      `__vite__cjsImport${importIndex}_${rawUrl}`,
-    )
-    const lines: string[] = [`import ${cjsModuleName} from "${url}"`]
-    importNames.forEach(({ importedName, localName }) => {
-      if (importedName === '*') {
-        lines.push(
-          `const ${localName} = (${interopHelper.toString()})(${cjsModuleName})`,
-        )
-      } else if (importedName === 'default') {
-        lines.push(
-          `const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`,
-        )
-      } else {
-        lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`)
-      }
-    })
-    if (defaultExports) {
-      lines.push(`export default ${defaultExports}`)
-    }
-    if (exportNames.length) {
-      lines.push(`export { ${exportNames.join(', ')} }`)
-    }
-
-    return lines.join('; ')
-  }
-}
-
 // Copied from `client/client.ts`. Only needed so we can inline inject this function for classic workers.
 function __vite__injectQuery(url: string, queryToInject: string): string {
   // skip urls that won't be handled by vite
diff --git a/packages/vite/src/node/plugins/importAnalysis/extractImportedBindings.ts b/packages/vite/src/node/plugins/importAnalysis/extractImportedBindings.ts
new file mode 100644
index 000000000..732c376be
--- /dev/null
+++ b/packages/vite/src/node/plugins/importAnalysis/extractImportedBindings.ts
@@ -0,0 +1,60 @@
+import type {
+  ParseError as EsModuleLexerParseError,
+  ExportSpecifier,
+  ImportSpecifier,
+} from 'es-module-lexer'
+import type { StaticImport } from 'mlly'
+import { ESM_STATIC_IMPORT_RE, parseStaticImport } from 'mlly'
+
+
+export function extractImportedBindings(
+  id: string,
+  source: string,
+  importSpec: ImportSpecifier,
+  importedBindings: Map<string, Set<string>>,
+) {
+  let bindings = importedBindings.get(id)
+  if (!bindings) {
+    bindings = new Set<string>()
+    importedBindings.set(id, bindings)
+  }
+
+  const isDynamic = importSpec.d > -1
+  const isMeta = importSpec.d === -2
+  if (isDynamic || isMeta) {
+    // this basically means the module will be impacted by any change in its dep
+    bindings.add('*')
+    return
+  }
+
+  const exp = source.slice(importSpec.ss, importSpec.se)
+  ESM_STATIC_IMPORT_RE.lastIndex = 0
+  const match = ESM_STATIC_IMPORT_RE.exec(exp)
+  if (!match) {
+    return
+  }
+
+  const staticImport: StaticImport = {
+    type: 'static',
+    code: match[0],
+    start: match.index,
+    end: match.index + match[0].length,
+    imports: match.groups!.imports,
+    specifier: match.groups!.specifier,
+  }
+  const parsed = parseStaticImport(staticImport)
+  if (!parsed) {
+    return
+  }
+  if (parsed.namespacedImport) {
+    bindings.add('*')
+  }
+  if (parsed.defaultImport) {
+    bindings.add('default')
+  }
+  if (parsed.namedImports) {
+    for (const name of Object.keys(parsed.namedImports)) {
+      bindings.add(name)
+    }
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin.ts b/packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin.ts
new file mode 100644
index 000000000..b28a25f71
--- /dev/null
+++ b/packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin.ts
@@ -0,0 +1,787 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import { init, parse as parseImports } from 'es-module-lexer'
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { SPECIAL_QUERY_RE } from 'packages/vite/src/node/constants';
+import { CLIENT_PUBLIC_PATH } from 'packages/vite/src/node/constants';
+import { lexAcceptedHmrExports } from 'packages/vite/src/node/server/hmr';
+import { lexAcceptedHmrDeps } from 'packages/vite/src/node/server/hmr';
+import { normalizeHmrUrl } from 'packages/vite/src/node/server/hmr';
+import { handlePrunedModules } from 'packages/vite/src/node/server/hmr';
+import { prettifyUrl } from 'packages/vite/src/node/utils';
+import { timeFrom } from 'packages/vite/src/node/utils';
+import { isExternalUrl } from 'packages/vite/src/node/utils';
+import { isDataUrl } from 'packages/vite/src/node/utils';
+import { isBuiltin } from 'packages/vite/src/node/utils';
+import { urlRE } from 'packages/vite/src/node/utils';
+import { injectQuery } from 'packages/vite/src/node/utils';
+import { stripBase } from 'packages/vite/src/node/utils';
+import { fsPathFromUrl } from 'packages/vite/src/node/utils';
+import { isInNodeModules } from 'packages/vite/src/node/utils';
+import { generateCodeFrame } from 'packages/vite/src/node/utils';
+import { transformStableResult } from 'packages/vite/src/node/utils';
+import { getFsUtils } from 'packages/vite/src/node/fsUtils';
+import { checkPublicFile } from 'packages/vite/src/node/publicDir';
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { shouldExternalizeForSSR } from 'packages/vite/src/node/ssr/ssrExternal';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { withTrailingSlash } from 'packages/vite/src/shared/utils';
+import { TransformPluginContext } from 'packages/vite/src/node/server/pluginContainer';
+import { throwOutdatedRequest } from 'packages/vite/src/node/plugins/optimizedDeps';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css';
+import { browserExternalId } from 'packages/vite/src/node/plugins/resolve';
+import { serializeDefine } from 'packages/vite/src/node/plugins/define';
+import { getAliasPatternMatcher } from 'packages/vite/src/node/plugins/preAlias';
+import { CLIENT_DIR } from 'packages/vite/src/node/constants';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { isDirectCSSRequest } from 'packages/vite/src/node/plugins/css';
+import { isJSRequest } from 'packages/vite/src/node/utils';
+import type {
+  ParseError as EsModuleLexerParseError,
+  ExportSpecifier,
+  ImportSpecifier,
+} from 'es-module-lexer'
+import type { StaticImport } from 'mlly'
+import { ESM_STATIC_IMPORT_RE, parseStaticImport } from 'mlly'
+
+
+const export clientDir = normalizePath(CLIENT_DIR)
+
+const export skipRE = /\.(?:map|json)(?:$|\?)/
+
+const canSkipImportAnalysis = (id: string): boolean =>
+  skipRE.test(id) || isDirectCSSRequest(id)
+
+const export optimizedDepChunkRE = /\/chunk-[A-Z\d]{8}\.js/
+
+const export optimizedDepDynamicRE = /-[A-Z\d]{8}\.js/
+
+const export urlIsStringRE = /^(?:'.*'|".*"|`.*`)$/
+
+const export templateLiteralRE = /^\s*`(.*)`\s*$/
+
+export function isExplicitImportRequired(url: string): boolean {
+  return !isJSRequest(url) && !isCSSRequest(url)
+}
+
+export function extractImportedBindings(
+  id: string,
+  source: string,
+  importSpec: ImportSpecifier,
+  importedBindings: Map<string, Set<string>>,
+) {
+  let bindings = importedBindings.get(id)
+  if (!bindings) {
+    bindings = new Set<string>()
+    importedBindings.set(id, bindings)
+  }
+
+  const isDynamic = importSpec.d > -1
+  const isMeta = importSpec.d === -2
+  if (isDynamic || isMeta) {
+    // this basically means the module will be impacted by any change in its dep
+    bindings.add('*')
+    return
+  }
+
+  const exp = source.slice(importSpec.ss, importSpec.se)
+  ESM_STATIC_IMPORT_RE.lastIndex = 0
+  const match = ESM_STATIC_IMPORT_RE.exec(exp)
+  if (!match) {
+    return
+  }
+
+  const staticImport: StaticImport = {
+    type: 'static',
+    code: match[0],
+    start: match.index,
+    end: match.index + match[0].length,
+    imports: match.groups!.imports,
+    specifier: match.groups!.specifier,
+  }
+  const parsed = parseStaticImport(staticImport)
+  if (!parsed) {
+    return
+  }
+  if (parsed.namespacedImport) {
+    bindings.add('*')
+  }
+  if (parsed.defaultImport) {
+    bindings.add('default')
+  }
+  if (parsed.namedImports) {
+    for (const name of Object.keys(parsed.namedImports)) {
+      bindings.add(name)
+    }
+  }
+}
+
+/**
+ * Server-only plugin that lexes, resolves, rewrites and analyzes url imports.
+ *
+ * - Imports are resolved to ensure they exist on disk
+ *
+ * - Lexes HMR accept calls and updates import relationships in the module graph
+ *
+ * - Bare module imports are resolved (by @rollup-plugin/node-resolve) to
+ * absolute file paths, e.g.
+ *
+ *     ```js
+ *     import 'foo'
+ *     ```
+ *     is rewritten to
+ *     ```js
+ *     import '/@fs//project/node_modules/foo/dist/foo.js'
+ *     ```
+ *
+ * - CSS imports are appended with `.js` since both the js module and the actual
+ * css (referenced via `<link>`) may go through the transform pipeline:
+ *
+ *     ```js
+ *     import './style.css'
+ *     ```
+ *     is rewritten to
+ *     ```js
+ *     import './style.css.js'
+ *     ```
+ */
+export function importAnalysisPlugin(config: ResolvedConfig): Plugin {
+  const { root, base } = config
+  const fsUtils = getFsUtils(config)
+  const clientPublicPath = path.posix.join(base, CLIENT_PUBLIC_PATH)
+  const enablePartialAccept = config.experimental?.hmrPartialAccept
+  const matchAlias = getAliasPatternMatcher(config.resolve.alias)
+  let server: ViteDevServer
+
+  let _env: string | undefined
+  let _ssrEnv: string | undefined
+  function getEnv(ssr: boolean) {
+    if (!_ssrEnv || !_env) {
+      const importMetaEnvKeys: Record<string, any> = {}
+      const userDefineEnv: Record<string, any> = {}
+      for (const key in config.env) {
+        importMetaEnvKeys[key] = JSON.stringify(config.env[key])
+      }
+      for (const key in config.define) {
+        // non-import.meta.env.* is handled in `clientInjection` plugin
+        if (key.startsWith('import.meta.env.')) {
+          userDefineEnv[key.slice(16)] = config.define[key]
+        }
+      }
+      const env = `import.meta.env = ${serializeDefine({
+        ...importMetaEnvKeys,
+        SSR: '__vite_ssr__',
+        ...userDefineEnv,
+      })};`
+      _ssrEnv = env.replace('__vite_ssr__', 'true')
+      _env = env.replace('__vite_ssr__', 'false')
+    }
+    return ssr ? _ssrEnv : _env
+  }
+
+  return {
+    name: 'vite:import-analysis',
+
+    configureServer(_server) {
+      server = _server
+    },
+
+    async transform(source, importer, options) {
+      // In a real app `server` is always defined, but it is undefined when
+      // running src/node/server/__tests__/pluginContainer.spec.ts
+      if (!server) {
+        return null
+      }
+
+      const ssr = options?.ssr === true
+
+      if (canSkipImportAnalysis(importer)) {
+        debug?.(colors.dim(`[skipped] ${prettifyUrl(importer, root)}`))
+        return null
+      }
+
+      const msAtStart = debug ? performance.now() : 0
+      await init
+      let imports!: readonly ImportSpecifier[]
+      let exports!: readonly ExportSpecifier[]
+      source = stripBomTag(source)
+      try {
+        ;[imports, exports] = parseImports(source)
+      } catch (_e: unknown) {
+        const e = _e as EsModuleLexerParseError
+        const { message, showCodeFrame } = createParseErrorInfo(
+          importer,
+          source,
+        )
+        this.error(message, showCodeFrame ? e.idx : undefined)
+      }
+
+      const depsOptimizer = getDepsOptimizer(config, ssr)
+
+      const { moduleGraph } = server
+      // since we are already in the transform phase of the importer, it must
+      // have been loaded so its entry is guaranteed in the module graph.
+      const importerModule = moduleGraph.getModuleById(importer)!
+      if (!importerModule) {
+        // This request is no longer valid. It could happen for optimized deps
+        // requests. A full reload is going to request this id again.
+        // Throwing an outdated error so we properly finish the request with a
+        // 504 sent to the browser.
+        throwOutdatedRequest(importer)
+      }
+
+      if (
+        !imports.length &&
+        !(this as unknown as TransformPluginContext)._addedImports
+      ) {
+        importerModule.isSelfAccepting = false
+        debug?.(
+          `${timeFrom(msAtStart)} ${colors.dim(
+            `[no imports] ${prettifyUrl(importer, root)}`,
+          )}`,
+        )
+        return source
+      }
+
+      let hasHMR = false
+      let isSelfAccepting = false
+      let hasEnv = false
+      let needQueryInjectHelper = false
+      let s: MagicString | undefined
+      const str = () => s || (s = new MagicString(source))
+      let isPartiallySelfAccepting = false
+      const importedBindings = enablePartialAccept
+        ? new Map<string, Set<string>>()
+        : null
+      const toAbsoluteUrl = (url: string) =>
+        path.posix.resolve(path.posix.dirname(importerModule.url), url)
+
+      const normalizeUrl = async (
+        url: string,
+        pos: number,
+        forceSkipImportAnalysis: boolean = false,
+      ): Promise<[string, string]> => {
+        url = stripBase(url, base)
+
+        let importerFile = importer
+
+        const optimizeDeps = getDepOptimizationConfig(config, ssr)
+        if (moduleListContains(optimizeDeps?.exclude, url)) {
+          if (depsOptimizer) {
+            await depsOptimizer.scanProcessing
+
+            // if the dependency encountered in the optimized file was excluded from the optimization
+            // the dependency needs to be resolved starting from the original source location of the optimized file
+            // because starting from node_modules/.vite will not find the dependency if it was not hoisted
+            // (that is, if it is under node_modules directory in the package source of the optimized file)
+            for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
+              if (!optimizedModule.src) continue // Ignore chunks
+              if (optimizedModule.file === importerModule.file) {
+                importerFile = optimizedModule.src
+              }
+            }
+          }
+        }
+
+        const resolved = await this.resolve(url, importerFile)
+
+        if (!resolved || resolved.meta?.['vite:alias']?.noResolved) {
+          // in ssr, we should let node handle the missing modules
+          if (ssr) {
+            return [url, url]
+          }
+          // fix#9534, prevent the importerModuleNode being stopped from propagating updates
+          importerModule.isSelfAccepting = false
+          moduleGraph._hasResolveFailedErrorModules.add(importerModule)
+          return this.error(
+            `Failed to resolve import "${url}" from "${normalizePath(
+              path.relative(process.cwd(), importerFile),
+            )}". Does the file exist?`,
+            pos,
+          )
+        }
+
+        if (isExternalUrl(resolved.id)) {
+          return [resolved.id, resolved.id]
+        }
+
+        const isRelative = url[0] === '.'
+        const isSelfImport = !isRelative && cleanUrl(url) === cleanUrl(importer)
+
+        // normalize all imports into resolved URLs
+        // e.g. `import 'foo'` -> `import '/@fs/.../node_modules/foo/index.js'`
+        if (resolved.id.startsWith(withTrailingSlash(root))) {
+          // in root: infer short absolute path from root
+          url = resolved.id.slice(root.length)
+        } else if (
+          depsOptimizer?.isOptimizedDepFile(resolved.id) ||
+          // vite-plugin-react isn't following the leading \0 virtual module convention.
+          // This is a temporary hack to avoid expensive fs checks for React apps.
+          // We'll remove this as soon we're able to fix the react plugins.
+          (resolved.id !== '/@react-refresh' &&
+            path.isAbsolute(resolved.id) &&
+            fsUtils.existsSync(cleanUrl(resolved.id)))
+        ) {
+          // an optimized deps may not yet exists in the filesystem, or
+          // a regular file exists but is out of root: rewrite to absolute /@fs/ paths
+          url = path.posix.join(FS_PREFIX, resolved.id)
+        } else {
+          url = resolved.id
+        }
+
+        // if the resolved id is not a valid browser import specifier,
+        // prefix it to make it valid. We will strip this before feeding it
+        // back into the transform pipeline
+        if (url[0] !== '.' && url[0] !== '/') {
+          url = wrapId(resolved.id)
+        }
+
+        // make the URL browser-valid if not SSR
+        if (!ssr) {
+          // mark non-js/css imports with `?import`
+          if (isExplicitImportRequired(url)) {
+            url = injectQuery(url, 'import')
+          } else if (
+            (isRelative || isSelfImport) &&
+            !DEP_VERSION_RE.test(url)
+          ) {
+            // If the url isn't a request for a pre-bundled common chunk,
+            // for relative js/css imports, or self-module virtual imports
+            // (e.g. vue blocks), inherit importer's version query
+            // do not do this for unknown type imports, otherwise the appended
+            // query can break 3rd party plugin's extension checks.
+            const versionMatch = DEP_VERSION_RE.exec(importer)
+            if (versionMatch) {
+              url = injectQuery(url, versionMatch[1])
+            }
+          }
+
+          // check if the dep has been hmr updated. If yes, we need to attach
+          // its last updated timestamp to force the browser to fetch the most
+          // up-to-date version of this module.
+          try {
+            // delay setting `isSelfAccepting` until the file is actually used (#7870)
+            // We use an internal function to avoid resolving the url again
+            const depModule = await moduleGraph._ensureEntryFromUrl(
+              unwrapId(url),
+              ssr,
+              canSkipImportAnalysis(url) || forceSkipImportAnalysis,
+              resolved,
+            )
+            if (depModule.lastHMRTimestamp > 0) {
+              url = injectQuery(url, `t=${depModule.lastHMRTimestamp}`)
+            }
+          } catch (e: any) {
+            // it's possible that the dep fails to resolve (non-existent import)
+            // attach location to the missing import
+            e.pos = pos
+            throw e
+          }
+
+          // prepend base
+          url = joinUrlSegments(base, url)
+        }
+
+        return [url, resolved.id]
+      }
+
+      const orderedImportedUrls = new Array<string | undefined>(imports.length)
+      const orderedAcceptedUrls = new Array<Set<UrlPosition> | undefined>(
+        imports.length,
+      )
+      const orderedAcceptedExports = new Array<Set<string> | undefined>(
+        imports.length,
+      )
+
+      await Promise.all(
+        imports.map(async (importSpecifier, index) => {
+          const {
+            s: start,
+            e: end,
+            ss: expStart,
+            se: expEnd,
+            d: dynamicIndex,
+            a: attributeIndex,
+          } = importSpecifier
+
+          // #2083 User may use escape path,
+          // so use imports[index].n to get the unescaped string
+          let specifier = importSpecifier.n
+
+          const rawUrl = source.slice(start, end)
+
+          // check import.meta usage
+          if (rawUrl === 'import.meta') {
+            const prop = source.slice(end, end + 4)
+            if (prop === '.hot') {
+              hasHMR = true
+              const endHot = end + 4 + (source[end + 4] === '?' ? 1 : 0)
+              if (source.slice(endHot, endHot + 7) === '.accept') {
+                // further analyze accepted modules
+                if (source.slice(endHot, endHot + 14) === '.acceptExports') {
+                  const importAcceptedExports = (orderedAcceptedExports[index] =
+                    new Set<string>())
+                  lexAcceptedHmrExports(
+                    source,
+                    source.indexOf('(', endHot + 14) + 1,
+                    importAcceptedExports,
+                  )
+                  isPartiallySelfAccepting = true
+                } else {
+                  const importAcceptedUrls = (orderedAcceptedUrls[index] =
+                    new Set<UrlPosition>())
+                  if (
+                    lexAcceptedHmrDeps(
+                      source,
+                      source.indexOf('(', endHot + 7) + 1,
+                      importAcceptedUrls,
+                    )
+                  ) {
+                    isSelfAccepting = true
+                  }
+                }
+              }
+            } else if (prop === '.env') {
+              hasEnv = true
+            }
+            return
+          } else if (templateLiteralRE.test(rawUrl)) {
+            // If the import has backticks but isn't transformed as a glob import
+            // (as there's nothing to glob), check if it's simply a plain string.
+            // If so, we can replace the specifier as a plain string to prevent
+            // an incorrect "cannot be analyzed" warning.
+            if (!(rawUrl.includes('${') && rawUrl.includes('}'))) {
+              specifier = rawUrl.replace(templateLiteralRE, '$1')
+            }
+          }
+
+          const isDynamicImport = dynamicIndex > -1
+
+          // strip import attributes as we can process them ourselves
+          if (!isDynamicImport && attributeIndex > -1) {
+            str().remove(end + 1, expEnd)
+          }
+
+          // static import or valid string in dynamic import
+          // If resolvable, let's resolve it
+          if (specifier !== undefined) {
+            // skip external / data uri
+            if (isExternalUrl(specifier) || isDataUrl(specifier)) {
+              return
+            }
+            // skip ssr external
+            if (ssr && !matchAlias(specifier)) {
+              if (shouldExternalizeForSSR(specifier, importer, config)) {
+                return
+              }
+              if (isBuiltin(specifier)) {
+                return
+              }
+            }
+            // skip client
+            if (specifier === clientPublicPath) {
+              return
+            }
+
+            // warn imports to non-asset /public files
+            if (
+              specifier[0] === '/' &&
+              !(
+                config.assetsInclude(cleanUrl(specifier)) ||
+                urlRE.test(specifier)
+              ) &&
+              checkPublicFile(specifier, config)
+            ) {
+              throw new Error(
+                `Cannot import non-asset file ${specifier} which is inside /public. ` +
+                  `JS/CSS files inside /public are copied as-is on build and ` +
+                  `can only be referenced via <script src> or <link href> in html. ` +
+                  `If you want to get the URL of that file, use ${injectQuery(
+                    specifier,
+                    'url',
+                  )} instead.`,
+              )
+            }
+
+            // normalize
+            const [url, resolvedId] = await normalizeUrl(specifier, start)
+
+            // record as safe modules
+            // safeModulesPath should not include the base prefix.
+            // See https://github.com/vitejs/vite/issues/9438#issuecomment-1465270409
+            server?.moduleGraph.safeModulesPath.add(
+              fsPathFromUrl(stripBase(url, base)),
+            )
+
+            if (url !== specifier) {
+              let rewriteDone = false
+              if (
+                depsOptimizer?.isOptimizedDepFile(resolvedId) &&
+                !optimizedDepChunkRE.test(resolvedId)
+              ) {
+                // for optimized cjs deps, support named imports by rewriting named imports to const assignments.
+                // internal optimized chunks don't need es interop and are excluded
+
+                // The browserHash in resolvedId could be stale in which case there will be a full
+                // page reload. We could return a 404 in that case but it is safe to return the request
+                const file = cleanUrl(resolvedId) // Remove ?v={hash}
+
+                const needsInterop = await optimizedDepNeedsInterop(
+                  depsOptimizer.metadata,
+                  file,
+                  config,
+                  ssr,
+                )
+
+                if (needsInterop === undefined) {
+                  // Non-entry dynamic imports from dependencies will reach here as there isn't
+                  // optimize info for them, but they don't need es interop. If the request isn't
+                  // a dynamic import, then it is an internal Vite error
+                  if (!optimizedDepDynamicRE.test(file)) {
+                    config.logger.error(
+                      colors.red(
+                        `Vite Error, ${url} optimized info should be defined`,
+                      ),
+                    )
+                  }
+                } else if (needsInterop) {
+                  debug?.(`${url} needs interop`)
+                  interopNamedImports(
+                    str(),
+                    importSpecifier,
+                    url,
+                    index,
+                    importer,
+                    config,
+                  )
+                  rewriteDone = true
+                }
+              }
+              // If source code imports builtin modules via named imports, the stub proxy export
+              // would fail as it's `export default` only. Apply interop for builtin modules to
+              // correctly throw the error message.
+              else if (
+                url.includes(browserExternalId) &&
+                source.slice(expStart, start).includes('{')
+              ) {
+                interopNamedImports(
+                  str(),
+                  importSpecifier,
+                  url,
+                  index,
+                  importer,
+                  config,
+                )
+                rewriteDone = true
+              }
+              if (!rewriteDone) {
+                const rewrittenUrl = JSON.stringify(url)
+                const s = isDynamicImport ? start : start - 1
+                const e = isDynamicImport ? end : end + 1
+                str().overwrite(s, e, rewrittenUrl, {
+                  contentOnly: true,
+                })
+              }
+            }
+
+            // record for HMR import chain analysis
+            // make sure to unwrap and normalize away base
+            const hmrUrl = unwrapId(stripBase(url, base))
+            const isLocalImport = !isExternalUrl(hmrUrl) && !isDataUrl(hmrUrl)
+            if (isLocalImport) {
+              orderedImportedUrls[index] = hmrUrl
+            }
+
+            if (enablePartialAccept && importedBindings) {
+              extractImportedBindings(
+                resolvedId,
+                source,
+                importSpecifier,
+                importedBindings,
+              )
+            }
+
+            if (
+              !isDynamicImport &&
+              isLocalImport &&
+              config.server.preTransformRequests
+            ) {
+              // pre-transform known direct imports
+              // These requests will also be registered in transformRequest to be awaited
+              // by the deps optimizer
+              const url = removeImportQuery(hmrUrl)
+              server.warmupRequest(url, { ssr })
+            }
+          } else if (!importer.startsWith(withTrailingSlash(clientDir))) {
+            if (!isInNodeModules(importer)) {
+              // check @vite-ignore which suppresses dynamic import warning
+              const hasViteIgnore = hasViteIgnoreRE.test(
+                // complete expression inside parens
+                source.slice(dynamicIndex + 1, end),
+              )
+              if (!hasViteIgnore) {
+                this.warn(
+                  `\n` +
+                    colors.cyan(importerModule.file) +
+                    `\n` +
+                    colors.reset(generateCodeFrame(source, start, end)) +
+                    colors.yellow(
+                      `\nThe above dynamic import cannot be analyzed by Vite.\n` +
+                        `See ${colors.blue(
+                          `https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`,
+                        )} ` +
+                        `for supported dynamic import formats. ` +
+                        `If this is intended to be left as-is, you can use the ` +
+                        `/* @vite-ignore */ comment inside the import() call to suppress this warning.\n`,
+                    ),
+                )
+              }
+            }
+
+            if (!ssr) {
+              if (
+                !urlIsStringRE.test(rawUrl) ||
+                isExplicitImportRequired(rawUrl.slice(1, -1))
+              ) {
+                needQueryInjectHelper = true
+                str().overwrite(
+                  start,
+                  end,
+                  `__vite__injectQuery(${rawUrl}, 'import')`,
+                  { contentOnly: true },
+                )
+              }
+            }
+          }
+        }),
+      )
+
+      const _orderedImportedUrls = orderedImportedUrls.filter(isDefined)
+      const importedUrls = new Set(_orderedImportedUrls)
+      // `importedUrls` will be mixed with watched files for the module graph,
+      // `staticImportedUrls` will only contain the static top-level imports and
+      // dynamic imports
+      const staticImportedUrls = new Set(
+        _orderedImportedUrls.map((url) => removeTimestampQuery(url)),
+      )
+      const acceptedUrls = mergeAcceptedUrls(orderedAcceptedUrls)
+      const acceptedExports = mergeAcceptedUrls(orderedAcceptedExports)
+
+      // While we always expect to work with ESM, a classic worker is the only
+      // case where it's not ESM and we need to avoid injecting ESM-specific code
+      const isClassicWorker =
+        importer.includes(WORKER_FILE_ID) && importer.includes('type=classic')
+
+      if (hasEnv && !isClassicWorker) {
+        // inject import.meta.env
+        str().prepend(getEnv(ssr))
+      }
+
+      if (hasHMR && !ssr && !isClassicWorker) {
+        debugHmr?.(
+          `${
+            isSelfAccepting
+              ? `[self-accepts]`
+              : isPartiallySelfAccepting
+                ? `[accepts-exports]`
+                : acceptedUrls.size
+                  ? `[accepts-deps]`
+                  : `[detected api usage]`
+          } ${prettifyUrl(importer, root)}`,
+        )
+        // inject hot context
+        str().prepend(
+          `import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";` +
+            `import.meta.hot = __vite__createHotContext(${JSON.stringify(
+              normalizeHmrUrl(importerModule.url),
+            )});`,
+        )
+      }
+
+      if (needQueryInjectHelper) {
+        if (isClassicWorker) {
+          str().append('\n' + __vite__injectQuery.toString())
+        } else {
+          str().prepend(
+            `import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`,
+          )
+        }
+      }
+
+      // normalize and rewrite accepted urls
+      const normalizedAcceptedUrls = new Set<string>()
+      for (const { url, start, end } of acceptedUrls) {
+        const [normalized] = await moduleGraph.resolveUrl(
+          toAbsoluteUrl(url),
+          ssr,
+        )
+        normalizedAcceptedUrls.add(normalized)
+        str().overwrite(start, end, JSON.stringify(normalized), {
+          contentOnly: true,
+        })
+      }
+
+      // update the module graph for HMR analysis.
+      // node CSS imports does its own graph update in the css-analysis plugin so we
+      // only handle js graph updates here.
+      // note that we want to handle .css?raw and .css?url here
+      if (!isCSSRequest(importer) || SPECIAL_QUERY_RE.test(importer)) {
+        // attached by pluginContainer.addWatchFile
+        const pluginImports = (this as unknown as TransformPluginContext)
+          ._addedImports
+        if (pluginImports) {
+          ;(
+            await Promise.all(
+              [...pluginImports].map((id) => normalizeUrl(id, 0, true)),
+            )
+          ).forEach(([url]) => importedUrls.add(url))
+        }
+        // HMR transforms are no-ops in SSR, so an `accept` call will
+        // never be injected. Avoid updating the `isSelfAccepting`
+        // property for our module node in that case.
+        if (ssr && importerModule.isSelfAccepting) {
+          isSelfAccepting = true
+        }
+        // a partially accepted module that accepts all its exports
+        // behaves like a self-accepted module in practice
+        if (
+          !isSelfAccepting &&
+          isPartiallySelfAccepting &&
+          acceptedExports.size >= exports.length &&
+          exports.every((e) => acceptedExports.has(e.n))
+        ) {
+          isSelfAccepting = true
+        }
+        const prunedImports = await moduleGraph.updateModuleInfo(
+          importerModule,
+          importedUrls,
+          importedBindings,
+          normalizedAcceptedUrls,
+          isPartiallySelfAccepting ? acceptedExports : null,
+          isSelfAccepting,
+          ssr,
+          staticImportedUrls,
+        )
+        if (hasHMR && prunedImports) {
+          handlePrunedModules(prunedImports, server)
+        }
+      }
+
+      debug?.(
+        `${timeFrom(msAtStart)} ${colors.dim(
+          `[${importedUrls.size} imports rewritten] ${prettifyUrl(
+            importer,
+            root,
+          )}`,
+        )}`,
+      )
+
+      if (s) {
+        return transformStableResult(s, importer, config)
+      } else {
+        return source
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/importAnalysis/interopNamedImports.ts b/packages/vite/src/node/plugins/importAnalysis/interopNamedImports.ts
new file mode 100644
index 000000000..cb348ce5e
--- /dev/null
+++ b/packages/vite/src/node/plugins/importAnalysis/interopNamedImports.ts
@@ -0,0 +1,65 @@
+import MagicString from 'magic-string'
+import type {
+  ParseError as EsModuleLexerParseError,
+  ExportSpecifier,
+  ImportSpecifier,
+} from 'es-module-lexer'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+
+
+// prettier-ignore
+export const interopHelper = (m: any) => m?.__esModule ? m : { ...(typeof m === 'object' && !Array.isArray(m) || typeof m === 'function' ? m : {}), default: m }
+
+export function interopNamedImports(
+  str: MagicString,
+  importSpecifier: ImportSpecifier,
+  rewrittenUrl: string,
+  importIndex: number,
+  importer: string,
+  config: ResolvedConfig,
+): void {
+  const source = str.original
+  const {
+    s: start,
+    e: end,
+    ss: expStart,
+    se: expEnd,
+    d: dynamicIndex,
+  } = importSpecifier
+  const exp = source.slice(expStart, expEnd)
+  if (dynamicIndex > -1) {
+    // rewrite `import('package')` to expose the default directly
+    str.overwrite(
+      expStart,
+      expEnd,
+      `import('${rewrittenUrl}').then(m => (${interopHelper.toString()})(m.default))` +
+        getLineBreaks(exp),
+      { contentOnly: true },
+    )
+  } else {
+    const rawUrl = source.slice(start, end)
+    const rewritten = transformCjsImport(
+      exp,
+      rewrittenUrl,
+      rawUrl,
+      importIndex,
+      importer,
+      config,
+    )
+    if (rewritten) {
+      str.overwrite(expStart, expEnd, rewritten + getLineBreaks(exp), {
+        contentOnly: true,
+      })
+    } else {
+      // #1439 export * from '...'
+      str.overwrite(
+        start,
+        end,
+        rewrittenUrl + getLineBreaks(source.slice(start, end)),
+        {
+          contentOnly: true,
+        },
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/importAnalysis/transformCjsImport.ts b/packages/vite/src/node/plugins/importAnalysis/transformCjsImport.ts
new file mode 100644
index 000000000..1c7b6f352
--- /dev/null
+++ b/packages/vite/src/node/plugins/importAnalysis/transformCjsImport.ts
@@ -0,0 +1,124 @@
+import colors from 'picocolors'
+import { parseAst } from 'rollup/parseAst'
+import { makeLegalIdentifier } from '@rollup/pluginutils'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+
+
+// prettier-ignore
+export const interopHelper = (m: any) => m?.__esModule ? m : { ...(typeof m === 'object' && !Array.isArray(m) || typeof m === 'function' ? m : {}), default: m }
+
+export type ImportNameSpecifier = { importedName: string; localName: string }
+
+/**
+ * Detect import statements to a known optimized CJS dependency and provide
+ * ES named imports interop. We do this by rewriting named imports to a variable
+ * assignment to the corresponding property on the `module.exports` of the cjs
+ * module. Note this doesn't support dynamic re-assignments from within the cjs
+ * module.
+ *
+ * Note that es-module-lexer treats `export * from '...'` as an import as well,
+ * so, we may encounter ExportAllDeclaration here, in which case `undefined`
+ * will be returned.
+ *
+ * Credits \@csr632 via #837
+ */
+export function transformCjsImport(
+  importExp: string,
+  url: string,
+  rawUrl: string,
+  importIndex: number,
+  importer: string,
+  config: ResolvedConfig,
+): string | undefined {
+  const node = parseAst(importExp).body[0]
+
+  // `export * from '...'` may cause unexpected problem, so give it a warning
+  if (
+    config.command === 'serve' &&
+    node.type === 'ExportAllDeclaration' &&
+    !node.exported
+  ) {
+    config.logger.warn(
+      colors.yellow(
+        `\nUnable to interop \`${importExp}\` in ${importer}, this may lose module exports. Please export "${rawUrl}" as ESM or use named exports instead, e.g. \`export { A, B } from "${rawUrl}"\``,
+      ),
+    )
+  } else if (
+    node.type === 'ImportDeclaration' ||
+    node.type === 'ExportNamedDeclaration'
+  ) {
+    if (!node.specifiers.length) {
+      return `import "${url}"`
+    }
+
+    const importNames: ImportNameSpecifier[] = []
+    const exportNames: string[] = []
+    let defaultExports: string = ''
+    for (const spec of node.specifiers) {
+      if (
+        spec.type === 'ImportSpecifier' &&
+        spec.imported.type === 'Identifier'
+      ) {
+        const importedName = spec.imported.name
+        const localName = spec.local.name
+        importNames.push({ importedName, localName })
+      } else if (spec.type === 'ImportDefaultSpecifier') {
+        importNames.push({
+          importedName: 'default',
+          localName: spec.local.name,
+        })
+      } else if (spec.type === 'ImportNamespaceSpecifier') {
+        importNames.push({ importedName: '*', localName: spec.local.name })
+      } else if (
+        spec.type === 'ExportSpecifier' &&
+        spec.exported.type === 'Identifier'
+      ) {
+        // for ExportSpecifier, local name is same as imported name
+        // prefix the variable name to avoid clashing with other local variables
+        const importedName = spec.local.name
+        // we want to specify exported name as variable and re-export it
+        const exportedName = spec.exported.name
+        if (exportedName === 'default') {
+          defaultExports = makeLegalIdentifier(
+            `__vite__cjsExportDefault_${importIndex}`,
+          )
+          importNames.push({ importedName, localName: defaultExports })
+        } else {
+          const localName = makeLegalIdentifier(
+            `__vite__cjsExport_${exportedName}`,
+          )
+          importNames.push({ importedName, localName })
+          exportNames.push(`${localName} as ${exportedName}`)
+        }
+      }
+    }
+
+    // If there is multiple import for same id in one file,
+    // importIndex will prevent the cjsModuleName to be duplicate
+    const cjsModuleName = makeLegalIdentifier(
+      `__vite__cjsImport${importIndex}_${rawUrl}`,
+    )
+    const lines: string[] = [`import ${cjsModuleName} from "${url}"`]
+    importNames.forEach(({ importedName, localName }) => {
+      if (importedName === '*') {
+        lines.push(
+          `const ${localName} = (${interopHelper.toString()})(${cjsModuleName})`,
+        )
+      } else if (importedName === 'default') {
+        lines.push(
+          `const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`,
+        )
+      } else {
+        lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`)
+      }
+    })
+    if (defaultExports) {
+      lines.push(`export default ${defaultExports}`)
+    }
+    if (exportNames.length) {
+      lines.push(`export { ${exportNames.join(', ')} }`)
+    }
+
+    return lines.join('; ')
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/importAnalysisBuild.ts b/packages/vite/src/node/plugins/importAnalysisBuild.ts
index 7dcad1796..96301d2fb 100644
--- a/packages/vite/src/node/plugins/importAnalysisBuild.ts
+++ b/packages/vite/src/node/plugins/importAnalysisBuild.ts
@@ -1,3 +1,5 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { removedPureCssFilesCache } from 'packages/vite/src/node/plugins/css/cssPlugin';
 import path from 'node:path'
 import MagicString from 'magic-string'
 import type {
@@ -15,10 +17,8 @@ import {
   numberToPos,
 } from '../utils'
 import type { Plugin } from '../plugin'
-import type { ResolvedConfig } from '../config'
 import { toOutputFilePathInJS } from '../build'
 import { genSourceMapUrl } from '../server/sourcemap'
-import { removedPureCssFilesCache } from './css'
 import { createParseErrorInfo } from './importAnalysis'
 
 type FileDep = {
diff --git a/packages/vite/src/node/plugins/importMetaGlob.ts b/packages/vite/src/node/plugins/importMetaGlob.ts
index d596d39d1..a7681c04f 100644
--- a/packages/vite/src/node/plugins/importMetaGlob.ts
+++ b/packages/vite/src/node/plugins/importMetaGlob.ts
@@ -1,3 +1,7 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import { isAbsolute, posix } from 'node:path'
 import micromatch from 'micromatch'
 import { stripLiteral } from 'strip-literal'
@@ -17,9 +21,7 @@ import { stringifyQuery } from 'ufo'
 import type { GeneralImportGlobOptions } from 'types/importGlob'
 import { parseAstAsync } from 'rollup/parseAst'
 import type { Plugin } from '../plugin'
-import type { ViteDevServer } from '../server'
 import type { ModuleNode } from '../server/moduleGraph'
-import type { ResolvedConfig } from '../config'
 import { evalValue, normalizePath, transformStableResult } from '../utils'
 import type { Logger } from '../logger'
 import { slash } from '../../shared/utils'
diff --git a/packages/vite/src/node/plugins/index.ts b/packages/vite/src/node/plugins/index.ts
index fc230c686..8cf46cbe9 100644
--- a/packages/vite/src/node/plugins/index.ts
+++ b/packages/vite/src/node/plugins/index.ts
@@ -1,6 +1,12 @@
+import { PluginHookUtils } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { cssPlugin } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { cssPostPlugin } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { cssAnalysisPlugin } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { importAnalysisPlugin } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { resolvePlugin } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
 import aliasPlugin, { type ResolverFunction } from '@rollup/plugin-alias'
 import type { ObjectHook } from 'rollup'
-import type { PluginHookUtils, ResolvedConfig } from '../config'
 import { isDepsOptimizerEnabled } from '../config'
 import type { HookHandler, Plugin, PluginWithRequiredHook } from '../plugin'
 import { getDepsOptimizer } from '../optimizer'
@@ -8,11 +14,8 @@ import { shouldExternalizeForSSR } from '../ssr/ssrExternal'
 import { watchPackageDataPlugin } from '../packages'
 import { getFsUtils } from '../fsUtils'
 import { jsonPlugin } from './json'
-import { resolvePlugin } from './resolve'
 import { optimizedDepsPlugin } from './optimizedDeps'
 import { esbuildPlugin } from './esbuild'
-import { importAnalysisPlugin } from './importAnalysis'
-import { cssAnalysisPlugin, cssPlugin, cssPostPlugin } from './css'
 import { assetPlugin } from './asset'
 import { clientInjectionsPlugin } from './clientInjections'
 import { buildHtmlPlugin, htmlInlineProxyPlugin } from './html'
diff --git a/packages/vite/src/node/plugins/preAlias.ts b/packages/vite/src/node/plugins/preAlias.ts
index eaefdb7e6..39c70a47e 100644
--- a/packages/vite/src/node/plugins/preAlias.ts
+++ b/packages/vite/src/node/plugins/preAlias.ts
@@ -1,3 +1,4 @@
+import { tryOptimizedResolve } from 'packages/vite/src/node/plugins/resolve/tryOptimizedResolve';
 import path from 'node:path'
 import type {
   Alias,
@@ -16,7 +17,6 @@ import {
 import { getFsUtils } from '../fsUtils'
 import { getDepsOptimizer } from '../optimizer'
 import { cleanUrl, withTrailingSlash } from '../../shared/utils'
-import { tryOptimizedResolve } from './resolve'
 
 /**
  * A plugin to avoid an aliased AND optimized dep from being aliased in src
diff --git a/packages/vite/src/node/plugins/reporter.ts b/packages/vite/src/node/plugins/reporter.ts
index 285d9baa7..4ca00c012 100644
--- a/packages/vite/src/node/plugins/reporter.ts
+++ b/packages/vite/src/node/plugins/reporter.ts
@@ -1,9 +1,9 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import path from 'node:path'
 import { gzip } from 'node:zlib'
 import { promisify } from 'node:util'
 import colors from 'picocolors'
 import type { Plugin } from 'rollup'
-import type { ResolvedConfig } from '../config'
 import { isDefined, isInNodeModules, normalizePath } from '../utils'
 import { LogLevels } from '../logger'
 import { withTrailingSlash } from '../../shared/utils'
diff --git a/packages/vite/src/node/plugins/resolve.ts b/packages/vite/src/node/plugins/resolve.ts
index c9facf7cf..ed395143a 100644
--- a/packages/vite/src/node/plugins/resolve.ts
+++ b/packages/vite/src/node/plugins/resolve.ts
@@ -1,3 +1,33 @@
+import { browserExternalId } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { optionalPeerDepId } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { startsWithWordCharRE } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { resolvePlugin } from 'packages/vite/src/node/plugins/resolve';
+import { ERR_RESOLVE_PACKAGE_ENTRY_FAIL } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { isPossibleTsOutput } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { tryCleanFsResolve } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { tryCleanFsResolve } from 'packages/vite/src/node/plugins/resolve';
+import { optionalPeerDepId } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptionsWithOverrideConditions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { tryNodeResolve } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { tryNodeResolve } from 'packages/vite/src/node/plugins/resolve';
+import { tryOptimizedResolve } from 'packages/vite/src/node/plugins/resolve/tryOptimizedResolve';
+import { tryOptimizedResolve } from 'packages/vite/src/node/plugins/resolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { splitFileAndPostfix } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { tryFsResolve } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { resolvePackageEntry } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { resolvePackageEntry } from 'packages/vite/src/node/plugins/resolve';
+import { browserExternalId } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { splitFileAndPostfix } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { tryFsResolve } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { InternalResolveOptionsWithOverrideConditions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { resolveExportsOrImports } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { resolveDeepImport } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { resolveDeepImport } from 'packages/vite/src/node/plugins/resolve';
 import fs from 'node:fs'
 import path from 'node:path'
 import colors from 'picocolors'
@@ -57,419 +87,12 @@ import {
 const normalizedClientEntry = normalizePath(CLIENT_ENTRY)
 const normalizedEnvEntry = normalizePath(ENV_ENTRY)
 
-const ERR_RESOLVE_PACKAGE_ENTRY_FAIL = 'ERR_RESOLVE_PACKAGE_ENTRY_FAIL'
-
-// special id for paths marked with browser: false
-// https://github.com/defunctzombie/package-browser-field-spec#ignore-a-module
-export const browserExternalId = '__vite-browser-external'
-// special id for packages that are optional peer deps
-export const optionalPeerDepId = '__vite-optional-peer-dep'
-
 const subpathImportsPrefix = '#'
 
-const startsWithWordCharRE = /^\w/
-
 const debug = createDebugger('vite:resolve-details', {
   onlyWhenFocused: true,
 })
 
-export interface ResolveOptions {
-  /**
-   * @default ['browser', 'module', 'jsnext:main', 'jsnext']
-   */
-  mainFields?: string[]
-  conditions?: string[]
-  /**
-   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
-   */
-  extensions?: string[]
-  dedupe?: string[]
-  /**
-   * @default false
-   */
-  preserveSymlinks?: boolean
-}
-
-export interface InternalResolveOptions extends Required<ResolveOptions> {
-  root: string
-  isBuild: boolean
-  isProduction: boolean
-  ssrConfig?: SSROptions
-  packageCache?: PackageCache
-  fsUtils?: FsUtils
-  /**
-   * src code mode also attempts the following:
-   * - resolving /xxx as URLs
-   * - resolving bare imports from optimized deps
-   */
-  asSrc?: boolean
-  tryIndex?: boolean
-  tryPrefix?: string
-  preferRelative?: boolean
-  isRequire?: boolean
-  // #3040
-  // when the importer is a ts module,
-  // if the specifier requests a non-existent `.js/jsx/mjs/cjs` file,
-  // should also try import from `.ts/tsx/mts/cts` source file as fallback.
-  isFromTsImporter?: boolean
-  tryEsmOnly?: boolean
-  // True when resolving during the scan phase to discover dependencies
-  scan?: boolean
-  // Appends ?__vite_skip_optimization to the resolved id if shouldn't be optimized
-  ssrOptimizeCheck?: boolean
-  // Resolve using esbuild deps optimization
-  getDepsOptimizer?: (ssr: boolean) => DepsOptimizer | undefined
-  shouldExternalize?: (id: string, importer?: string) => boolean | undefined
-
-  /**
-   * Set by createResolver, we only care about the resolved id. moduleSideEffects
-   * and other fields are discarded so we can avoid computing them.
-   * @internal
-   */
-  idOnly?: boolean
-}
-
-export function resolvePlugin(resolveOptions: InternalResolveOptions): Plugin {
-  const {
-    root,
-    isProduction,
-    asSrc,
-    ssrConfig,
-    preferRelative = false,
-  } = resolveOptions
-
-  const {
-    target: ssrTarget,
-    noExternal: ssrNoExternal,
-    external: ssrExternal,
-  } = ssrConfig ?? {}
-
-  // In unix systems, absolute paths inside root first needs to be checked as an
-  // absolute URL (/root/root/path-to-file) resulting in failed checks before falling
-  // back to checking the path as absolute. If /root/root isn't a valid path, we can
-  // avoid these checks. Absolute paths inside root are common in user code as many
-  // paths are resolved by the user. For example for an alias.
-  const rootInRoot = tryStatSync(path.join(root, root))?.isDirectory() ?? false
-
-  return {
-    name: 'vite:resolve',
-
-    async resolveId(id, importer, resolveOpts) {
-      if (
-        id[0] === '\0' ||
-        id.startsWith('virtual:') ||
-        // When injected directly in html/client code
-        id.startsWith('/virtual:')
-      ) {
-        return
-      }
-
-      const ssr = resolveOpts?.ssr === true
-
-      // We need to delay depsOptimizer until here instead of passing it as an option
-      // the resolvePlugin because the optimizer is created on server listen during dev
-      const depsOptimizer = resolveOptions.getDepsOptimizer?.(ssr)
-
-      if (id.startsWith(browserExternalId)) {
-        return id
-      }
-
-      const targetWeb = !ssr || ssrTarget === 'webworker'
-
-      // this is passed by @rollup/plugin-commonjs
-      const isRequire: boolean =
-        resolveOpts?.custom?.['node-resolve']?.isRequire ?? false
-
-      // end user can configure different conditions for ssr and client.
-      // falls back to client conditions if no ssr conditions supplied
-      const ssrConditions =
-        resolveOptions.ssrConfig?.resolve?.conditions ||
-        resolveOptions.conditions
-
-      const options: InternalResolveOptions = {
-        isRequire,
-        ...resolveOptions,
-        scan: resolveOpts?.scan ?? resolveOptions.scan,
-        conditions: ssr ? ssrConditions : resolveOptions.conditions,
-      }
-
-      const resolvedImports = resolveSubpathImports(
-        id,
-        importer,
-        options,
-        targetWeb,
-      )
-      if (resolvedImports) {
-        id = resolvedImports
-
-        if (resolveOpts.custom?.['vite:import-glob']?.isSubImportsPattern) {
-          return normalizePath(path.join(root, id))
-        }
-      }
-
-      if (importer) {
-        if (
-          isTsRequest(importer) ||
-          resolveOpts.custom?.depScan?.loader?.startsWith('ts')
-        ) {
-          options.isFromTsImporter = true
-        } else {
-          const moduleLang = this.getModuleInfo(importer)?.meta?.vite?.lang
-          options.isFromTsImporter = moduleLang && isTsRequest(`.${moduleLang}`)
-        }
-      }
-
-      let res: string | PartialResolvedId | undefined
-
-      // resolve pre-bundled deps requests, these could be resolved by
-      // tryFileResolve or /fs/ resolution but these files may not yet
-      // exists if we are in the middle of a deps re-processing
-      if (asSrc && depsOptimizer?.isOptimizedDepUrl(id)) {
-        const optimizedPath = id.startsWith(FS_PREFIX)
-          ? fsPathFromId(id)
-          : normalizePath(path.resolve(root, id.slice(1)))
-        return optimizedPath
-      }
-
-      // explicit fs paths that starts with /@fs/*
-      if (asSrc && id.startsWith(FS_PREFIX)) {
-        res = fsPathFromId(id)
-        // We don't need to resolve these paths since they are already resolved
-        // always return here even if res doesn't exist since /@fs/ is explicit
-        // if the file doesn't exist it should be a 404.
-        debug?.(`[@fs] ${colors.cyan(id)} -> ${colors.dim(res)}`)
-        return ensureVersionQuery(res, id, options, depsOptimizer)
-      }
-
-      // URL
-      // /foo -> /fs-root/foo
-      if (
-        asSrc &&
-        id[0] === '/' &&
-        (rootInRoot || !id.startsWith(withTrailingSlash(root)))
-      ) {
-        const fsPath = path.resolve(root, id.slice(1))
-        if ((res = tryFsResolve(fsPath, options))) {
-          debug?.(`[url] ${colors.cyan(id)} -> ${colors.dim(res)}`)
-          return ensureVersionQuery(res, id, options, depsOptimizer)
-        }
-      }
-
-      // relative
-      if (
-        id[0] === '.' ||
-        ((preferRelative || importer?.endsWith('.html')) &&
-          startsWithWordCharRE.test(id))
-      ) {
-        const basedir = importer ? path.dirname(importer) : process.cwd()
-        const fsPath = path.resolve(basedir, id)
-        // handle browser field mapping for relative imports
-
-        const normalizedFsPath = normalizePath(fsPath)
-
-        if (depsOptimizer?.isOptimizedDepFile(normalizedFsPath)) {
-          // Optimized files could not yet exist in disk, resolve to the full path
-          // Inject the current browserHash version if the path doesn't have one
-          if (
-            !resolveOptions.isBuild &&
-            !DEP_VERSION_RE.test(normalizedFsPath)
-          ) {
-            const browserHash = optimizedDepInfoFromFile(
-              depsOptimizer.metadata,
-              normalizedFsPath,
-            )?.browserHash
-            if (browserHash) {
-              return injectQuery(normalizedFsPath, `v=${browserHash}`)
-            }
-          }
-          return normalizedFsPath
-        }
-
-        if (
-          targetWeb &&
-          options.mainFields.includes('browser') &&
-          (res = tryResolveBrowserMapping(fsPath, importer, options, true))
-        ) {
-          return res
-        }
-
-        if ((res = tryFsResolve(fsPath, options))) {
-          res = ensureVersionQuery(res, id, options, depsOptimizer)
-          debug?.(`[relative] ${colors.cyan(id)} -> ${colors.dim(res)}`)
-
-          // If this isn't a script imported from a .html file, include side effects
-          // hints so the non-used code is properly tree-shaken during build time.
-          if (
-            !options.idOnly &&
-            !options.scan &&
-            options.isBuild &&
-            !importer?.endsWith('.html')
-          ) {
-            const resPkg = findNearestPackageData(
-              path.dirname(res),
-              options.packageCache,
-            )
-            if (resPkg) {
-              return {
-                id: res,
-                moduleSideEffects: resPkg.hasSideEffects(res),
-              }
-            }
-          }
-          return res
-        }
-      }
-
-      // drive relative fs paths (only windows)
-      if (isWindows && id[0] === '/') {
-        const basedir = importer ? path.dirname(importer) : process.cwd()
-        const fsPath = path.resolve(basedir, id)
-        if ((res = tryFsResolve(fsPath, options))) {
-          debug?.(`[drive-relative] ${colors.cyan(id)} -> ${colors.dim(res)}`)
-          return ensureVersionQuery(res, id, options, depsOptimizer)
-        }
-      }
-
-      // absolute fs paths
-      if (
-        isNonDriveRelativeAbsolutePath(id) &&
-        (res = tryFsResolve(id, options))
-      ) {
-        debug?.(`[fs] ${colors.cyan(id)} -> ${colors.dim(res)}`)
-        return ensureVersionQuery(res, id, options, depsOptimizer)
-      }
-
-      // external
-      if (isExternalUrl(id)) {
-        return options.idOnly ? id : { id, external: true }
-      }
-
-      // data uri: pass through (this only happens during build and will be
-      // handled by dedicated plugin)
-      if (isDataUrl(id)) {
-        return null
-      }
-
-      // bare package imports, perform node resolve
-      if (bareImportRE.test(id)) {
-        const external = options.shouldExternalize?.(id, importer)
-        if (
-          !external &&
-          asSrc &&
-          depsOptimizer &&
-          !options.scan &&
-          (res = await tryOptimizedResolve(
-            depsOptimizer,
-            id,
-            importer,
-            options.preserveSymlinks,
-            options.packageCache,
-          ))
-        ) {
-          return res
-        }
-
-        if (
-          targetWeb &&
-          options.mainFields.includes('browser') &&
-          (res = tryResolveBrowserMapping(
-            id,
-            importer,
-            options,
-            false,
-            external,
-          ))
-        ) {
-          return res
-        }
-
-        if (
-          (res = tryNodeResolve(
-            id,
-            importer,
-            options,
-            targetWeb,
-            depsOptimizer,
-            ssr,
-            external,
-          ))
-        ) {
-          return res
-        }
-
-        // node built-ins.
-        // externalize if building for SSR, otherwise redirect to empty module
-        if (isBuiltin(id)) {
-          if (ssr) {
-            if (
-              targetWeb &&
-              ssrNoExternal === true &&
-              // if both noExternal and external are true, noExternal will take the higher priority and bundle it.
-              // only if the id is explicitly listed in external, we will externalize it and skip this error.
-              (ssrExternal === true || !ssrExternal?.includes(id))
-            ) {
-              let message = `Cannot bundle Node.js built-in "${id}"`
-              if (importer) {
-                message += ` imported from "${path.relative(
-                  process.cwd(),
-                  importer,
-                )}"`
-              }
-              message += `. Consider disabling ssr.noExternal or remove the built-in dependency.`
-              this.error(message)
-            }
-
-            return options.idOnly
-              ? id
-              : { id, external: true, moduleSideEffects: false }
-          } else {
-            if (!asSrc) {
-              debug?.(
-                `externalized node built-in "${id}" to empty module. ` +
-                  `(imported by: ${colors.white(colors.dim(importer))})`,
-              )
-            } else if (isProduction) {
-              this.warn(
-                `Module "${id}" has been externalized for browser compatibility, imported by "${importer}". ` +
-                  `See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`,
-              )
-            }
-            return isProduction
-              ? browserExternalId
-              : `${browserExternalId}:${id}`
-          }
-        }
-      }
-
-      debug?.(`[fallthrough] ${colors.dim(id)}`)
-    },
-
-    load(id) {
-      if (id.startsWith(browserExternalId)) {
-        if (isProduction) {
-          return `export default {}`
-        } else {
-          id = id.slice(browserExternalId.length + 1)
-          return `\
-export default new Proxy({}, {
-  get(_, key) {
-    throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.  See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
-  }
-})`
-        }
-      }
-      if (id.startsWith(optionalPeerDepId)) {
-        if (isProduction) {
-          return `export default {}`
-        } else {
-          const [, peerDep, parentDep] = id.split(':')
-          return `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`
-        }
-      }
-    },
-  }
-}
-
 function resolveSubpathImports(
   id: string,
   importer: string | undefined,
@@ -531,547 +154,6 @@ function ensureVersionQuery(
   return resolved
 }
 
-function splitFileAndPostfix(path: string) {
-  const file = cleanUrl(path)
-  return { file, postfix: path.slice(file.length) }
-}
-
-export function tryFsResolve(
-  fsPath: string,
-  options: InternalResolveOptions,
-  tryIndex = true,
-  targetWeb = true,
-  skipPackageJson = false,
-): string | undefined {
-  // Dependencies like es5-ext use `#` in their paths. We don't support `#` in user
-  // source code so we only need to perform the check for dependencies.
-  // We don't support `?` in node_modules paths, so we only need to check in this branch.
-  const hashIndex = fsPath.indexOf('#')
-  if (hashIndex >= 0 && isInNodeModules(fsPath)) {
-    const queryIndex = fsPath.indexOf('?')
-    // We only need to check foo#bar?baz and foo#bar, ignore foo?bar#baz
-    if (queryIndex < 0 || queryIndex > hashIndex) {
-      const file = queryIndex > hashIndex ? fsPath.slice(0, queryIndex) : fsPath
-      const res = tryCleanFsResolve(
-        file,
-        options,
-        tryIndex,
-        targetWeb,
-        skipPackageJson,
-      )
-      if (res) return res + fsPath.slice(file.length)
-    }
-  }
-
-  const { file, postfix } = splitFileAndPostfix(fsPath)
-  const res = tryCleanFsResolve(
-    file,
-    options,
-    tryIndex,
-    targetWeb,
-    skipPackageJson,
-  )
-  if (res) return res + postfix
-}
-
-const knownTsOutputRE = /\.(?:js|mjs|cjs|jsx)$/
-const isPossibleTsOutput = (url: string): boolean => knownTsOutputRE.test(url)
-
-function tryCleanFsResolve(
-  file: string,
-  options: InternalResolveOptions,
-  tryIndex = true,
-  targetWeb = true,
-  skipPackageJson = false,
-): string | undefined {
-  const { tryPrefix, extensions, preserveSymlinks } = options
-
-  const fsUtils = options.fsUtils ?? commonFsUtils
-
-  // Optimization to get the real type or file type (directory, file, other)
-  const fileResult = fsUtils.tryResolveRealFileOrType(
-    file,
-    options.preserveSymlinks,
-  )
-
-  if (fileResult?.path) return fileResult.path
-
-  let res: string | undefined
-
-  // If path.dirname is a valid directory, try extensions and ts resolution logic
-  const possibleJsToTs = options.isFromTsImporter && isPossibleTsOutput(file)
-  if (possibleJsToTs || options.extensions.length || tryPrefix) {
-    const dirPath = path.dirname(file)
-    if (fsUtils.isDirectory(dirPath)) {
-      if (possibleJsToTs) {
-        // try resolve .js, .mjs, .cjs or .jsx import to typescript file
-        const fileExt = path.extname(file)
-        const fileName = file.slice(0, -fileExt.length)
-        if (
-          (res = fsUtils.tryResolveRealFile(
-            fileName + fileExt.replace('js', 'ts'),
-            preserveSymlinks,
-          ))
-        )
-          return res
-        // for .js, also try .tsx
-        if (
-          fileExt === '.js' &&
-          (res = fsUtils.tryResolveRealFile(
-            fileName + '.tsx',
-            preserveSymlinks,
-          ))
-        )
-          return res
-      }
-
-      if (
-        (res = fsUtils.tryResolveRealFileWithExtensions(
-          file,
-          extensions,
-          preserveSymlinks,
-        ))
-      )
-        return res
-
-      if (tryPrefix) {
-        const prefixed = `${dirPath}/${options.tryPrefix}${path.basename(file)}`
-
-        if ((res = fsUtils.tryResolveRealFile(prefixed, preserveSymlinks)))
-          return res
-
-        if (
-          (res = fsUtils.tryResolveRealFileWithExtensions(
-            prefixed,
-            extensions,
-            preserveSymlinks,
-          ))
-        )
-          return res
-      }
-    }
-  }
-
-  if (tryIndex && fileResult?.type === 'directory') {
-    // Path points to a directory, check for package.json and entry and /index file
-    const dirPath = file
-
-    if (!skipPackageJson) {
-      let pkgPath = `${dirPath}/package.json`
-      try {
-        if (fsUtils.existsSync(pkgPath)) {
-          if (!options.preserveSymlinks) {
-            pkgPath = safeRealpathSync(pkgPath)
-          }
-          // path points to a node package
-          const pkg = loadPackageData(pkgPath)
-          return resolvePackageEntry(dirPath, pkg, targetWeb, options)
-        }
-      } catch (e) {
-        // This check is best effort, so if an entry is not found, skip error for now
-        if (e.code !== ERR_RESOLVE_PACKAGE_ENTRY_FAIL && e.code !== 'ENOENT')
-          throw e
-      }
-    }
-
-    if (
-      (res = fsUtils.tryResolveRealFileWithExtensions(
-        `${dirPath}/index`,
-        extensions,
-        preserveSymlinks,
-      ))
-    )
-      return res
-
-    if (tryPrefix) {
-      if (
-        (res = fsUtils.tryResolveRealFileWithExtensions(
-          `${dirPath}/${options.tryPrefix}index`,
-          extensions,
-          preserveSymlinks,
-        ))
-      )
-        return res
-    }
-  }
-}
-
-export type InternalResolveOptionsWithOverrideConditions =
-  InternalResolveOptions & {
-    /**
-     * @internal
-     */
-    overrideConditions?: string[]
-  }
-
-export function tryNodeResolve(
-  id: string,
-  importer: string | null | undefined,
-  options: InternalResolveOptionsWithOverrideConditions,
-  targetWeb: boolean,
-  depsOptimizer?: DepsOptimizer,
-  ssr: boolean = false,
-  externalize?: boolean,
-  allowLinkedExternal: boolean = true,
-): PartialResolvedId | undefined {
-  const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options
-
-  // check for deep import, e.g. "my-lib/foo"
-  const deepMatch = deepImportRE.exec(id)
-  // package name doesn't include postfixes
-  // trim them to support importing package with queries (e.g. `import css from 'normalize.css?inline'`)
-  const pkgId = deepMatch ? deepMatch[1] || deepMatch[2] : cleanUrl(id)
-
-  let basedir: string
-  if (dedupe?.includes(pkgId)) {
-    basedir = root
-  } else if (
-    importer &&
-    path.isAbsolute(importer) &&
-    // css processing appends `*` for importer
-    (importer[importer.length - 1] === '*' || fs.existsSync(cleanUrl(importer)))
-  ) {
-    basedir = path.dirname(importer)
-  } else {
-    basedir = root
-  }
-
-  let selfPkg = null
-  if (!isBuiltin(id) && !id.includes('\0') && bareImportRE.test(id)) {
-    // check if it's a self reference dep.
-    const selfPackageData = findNearestPackageData(basedir, packageCache)
-    selfPkg =
-      selfPackageData?.data.exports && selfPackageData?.data.name === pkgId
-        ? selfPackageData
-        : null
-  }
-
-  const pkg =
-    selfPkg ||
-    resolvePackageData(pkgId, basedir, preserveSymlinks, packageCache)
-  if (!pkg) {
-    // if import can't be found, check if it's an optional peer dep.
-    // if so, we can resolve to a special id that errors only when imported.
-    if (
-      basedir !== root && // root has no peer dep
-      !isBuiltin(id) &&
-      !id.includes('\0') &&
-      bareImportRE.test(id)
-    ) {
-      const mainPkg = findNearestMainPackageData(basedir, packageCache)?.data
-      if (mainPkg) {
-        const pkgName = getNpmPackageName(id)
-        if (
-          pkgName != null &&
-          mainPkg.peerDependencies?.[pkgName] &&
-          mainPkg.peerDependenciesMeta?.[pkgName]?.optional
-        ) {
-          return {
-            id: `${optionalPeerDepId}:${id}:${mainPkg.name}`,
-          }
-        }
-      }
-    }
-    return
-  }
-
-  const resolveId = deepMatch ? resolveDeepImport : resolvePackageEntry
-  const unresolvedId = deepMatch ? '.' + id.slice(pkgId.length) : id
-
-  let resolved: string | undefined
-  try {
-    resolved = resolveId(unresolvedId, pkg, targetWeb, options)
-  } catch (err) {
-    if (!options.tryEsmOnly) {
-      throw err
-    }
-  }
-  if (!resolved && options.tryEsmOnly) {
-    resolved = resolveId(unresolvedId, pkg, targetWeb, {
-      ...options,
-      isRequire: false,
-      mainFields: DEFAULT_MAIN_FIELDS,
-      extensions: DEFAULT_EXTENSIONS,
-    })
-  }
-  if (!resolved) {
-    return
-  }
-
-  const processResult = (resolved: PartialResolvedId) => {
-    if (!externalize) {
-      return resolved
-    }
-    // don't external symlink packages
-    if (!allowLinkedExternal && !isInNodeModules(resolved.id)) {
-      return resolved
-    }
-    const resolvedExt = path.extname(resolved.id)
-    // don't external non-js imports
-    if (
-      resolvedExt &&
-      resolvedExt !== '.js' &&
-      resolvedExt !== '.mjs' &&
-      resolvedExt !== '.cjs'
-    ) {
-      return resolved
-    }
-    let resolvedId = id
-    if (deepMatch && !pkg?.data.exports && path.extname(id) !== resolvedExt) {
-      // id date-fns/locale
-      // resolve.id ...date-fns/esm/locale/index.js
-      const index = resolved.id.indexOf(id)
-      if (index > -1) {
-        resolvedId = resolved.id.slice(index)
-        debug?.(
-          `[processResult] ${colors.cyan(id)} -> ${colors.dim(resolvedId)}`,
-        )
-      }
-    }
-    return { ...resolved, id: resolvedId, external: true }
-  }
-
-  if (
-    !options.idOnly &&
-    ((!options.scan && isBuild && !depsOptimizer) || externalize)
-  ) {
-    // Resolve package side effects for build so that rollup can better
-    // perform tree-shaking
-    return processResult({
-      id: resolved,
-      moduleSideEffects: pkg.hasSideEffects(resolved),
-    })
-  }
-
-  if (
-    !options.ssrOptimizeCheck &&
-    (!isInNodeModules(resolved) || // linked
-      !depsOptimizer || // resolving before listening to the server
-      options.scan) // initial esbuild scan phase
-  ) {
-    return { id: resolved }
-  }
-
-  // if we reach here, it's a valid dep import that hasn't been optimized.
-  const isJsType = depsOptimizer
-    ? isOptimizable(resolved, depsOptimizer.options)
-    : OPTIMIZABLE_ENTRY_RE.test(resolved)
-
-  let exclude = depsOptimizer?.options.exclude
-  let include = depsOptimizer?.options.include
-  if (options.ssrOptimizeCheck) {
-    // we don't have the depsOptimizer
-    exclude = options.ssrConfig?.optimizeDeps?.exclude
-    include = options.ssrConfig?.optimizeDeps?.include
-  }
-
-  const skipOptimization =
-    (!options.ssrOptimizeCheck && depsOptimizer?.options.noDiscovery) ||
-    !isJsType ||
-    (importer && isInNodeModules(importer)) ||
-    exclude?.includes(pkgId) ||
-    exclude?.includes(id) ||
-    SPECIAL_QUERY_RE.test(resolved) ||
-    // During dev SSR, we don't have a way to reload the module graph if
-    // a non-optimized dep is found. So we need to skip optimization here.
-    // The only optimized deps are the ones explicitly listed in the config.
-    (!options.ssrOptimizeCheck && !isBuild && ssr) ||
-    // Only optimize non-external CJS deps during SSR by default
-    (ssr &&
-      isFilePathESM(resolved, options.packageCache) &&
-      !(include?.includes(pkgId) || include?.includes(id)))
-
-  if (options.ssrOptimizeCheck) {
-    return {
-      id: skipOptimization
-        ? injectQuery(resolved, `__vite_skip_optimization`)
-        : resolved,
-    }
-  }
-
-  if (skipOptimization) {
-    // excluded from optimization
-    // Inject a version query to npm deps so that the browser
-    // can cache it without re-validation, but only do so for known js types.
-    // otherwise we may introduce duplicated modules for externalized files
-    // from pre-bundled deps.
-    if (!isBuild) {
-      const versionHash = depsOptimizer!.metadata.browserHash
-      if (versionHash && isJsType) {
-        resolved = injectQuery(resolved, `v=${versionHash}`)
-      }
-    }
-  } else {
-    // this is a missing import, queue optimize-deps re-run and
-    // get a resolved its optimized info
-    const optimizedInfo = depsOptimizer!.registerMissingImport(id, resolved)
-    resolved = depsOptimizer!.getOptimizedDepId(optimizedInfo)
-  }
-
-  if (!options.idOnly && !options.scan && isBuild) {
-    // Resolve package side effects for build so that rollup can better
-    // perform tree-shaking
-    return {
-      id: resolved,
-      moduleSideEffects: pkg.hasSideEffects(resolved),
-    }
-  } else {
-    return { id: resolved! }
-  }
-}
-
-export async function tryOptimizedResolve(
-  depsOptimizer: DepsOptimizer,
-  id: string,
-  importer?: string,
-  preserveSymlinks?: boolean,
-  packageCache?: PackageCache,
-): Promise<string | undefined> {
-  // TODO: we need to wait until scanning is done here as this function
-  // is used in the preAliasPlugin to decide if an aliased dep is optimized,
-  // and avoid replacing the bare import with the resolved path.
-  // We should be able to remove this in the future
-  await depsOptimizer.scanProcessing
-
-  const metadata = depsOptimizer.metadata
-
-  const depInfo = optimizedDepInfoFromId(metadata, id)
-  if (depInfo) {
-    return depsOptimizer.getOptimizedDepId(depInfo)
-  }
-
-  if (!importer) return
-
-  // further check if id is imported by nested dependency
-  let idPkgDir: string | undefined
-  const nestedIdMatch = `> ${id}`
-
-  for (const optimizedData of metadata.depInfoList) {
-    if (!optimizedData.src) continue // Ignore chunks
-
-    // check where "foo" is nested in "my-lib > foo"
-    if (!optimizedData.id.endsWith(nestedIdMatch)) continue
-
-    // lazily initialize idPkgDir
-    if (idPkgDir == null) {
-      const pkgName = getNpmPackageName(id)
-      if (!pkgName) break
-      idPkgDir = resolvePackageData(
-        pkgName,
-        importer,
-        preserveSymlinks,
-        packageCache,
-      )?.dir
-      // if still null, it likely means that this id isn't a dep for importer.
-      // break to bail early
-      if (idPkgDir == null) break
-      idPkgDir = normalizePath(idPkgDir)
-    }
-
-    // match by src to correctly identify if id belongs to nested dependency
-    if (optimizedData.src.startsWith(withTrailingSlash(idPkgDir))) {
-      return depsOptimizer.getOptimizedDepId(optimizedData)
-    }
-  }
-}
-
-export function resolvePackageEntry(
-  id: string,
-  { dir, data, setResolvedCache, getResolvedCache }: PackageData,
-  targetWeb: boolean,
-  options: InternalResolveOptions,
-): string | undefined {
-  const { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id)
-
-  const cached = getResolvedCache('.', targetWeb)
-  if (cached) {
-    return cached + postfix
-  }
-
-  try {
-    let entryPoint: string | undefined
-
-    // resolve exports field with highest priority
-    // using https://github.com/lukeed/resolve.exports
-    if (data.exports) {
-      entryPoint = resolveExportsOrImports(
-        data,
-        '.',
-        options,
-        targetWeb,
-        'exports',
-      )
-    }
-
-    // fallback to mainFields if still not resolved
-    if (!entryPoint) {
-      for (const field of options.mainFields) {
-        if (field === 'browser') {
-          if (targetWeb) {
-            entryPoint = tryResolveBrowserEntry(dir, data, options)
-            if (entryPoint) {
-              break
-            }
-          }
-        } else if (typeof data[field] === 'string') {
-          entryPoint = data[field]
-          break
-        }
-      }
-    }
-    entryPoint ||= data.main
-
-    // try default entry when entry is not define
-    // https://nodejs.org/api/modules.html#all-together
-    const entryPoints = entryPoint
-      ? [entryPoint]
-      : ['index.js', 'index.json', 'index.node']
-
-    for (let entry of entryPoints) {
-      // make sure we don't get scripts when looking for sass
-      let skipPackageJson = false
-      if (
-        options.mainFields[0] === 'sass' &&
-        !options.extensions.includes(path.extname(entry))
-      ) {
-        entry = ''
-        skipPackageJson = true
-      } else {
-        // resolve object browser field in package.json
-        const { browser: browserField } = data
-        if (
-          targetWeb &&
-          options.mainFields.includes('browser') &&
-          isObject(browserField)
-        ) {
-          entry = mapWithBrowserField(entry, browserField) || entry
-        }
-      }
-
-      const entryPointPath = path.join(dir, entry)
-      const resolvedEntryPoint = tryFsResolve(
-        entryPointPath,
-        options,
-        true,
-        true,
-        skipPackageJson,
-      )
-      if (resolvedEntryPoint) {
-        debug?.(
-          `[package entry] ${colors.cyan(idWithoutPostfix)} -> ${colors.dim(
-            resolvedEntryPoint,
-          )}${postfix !== '' ? ` (postfix: ${postfix})` : ''}`,
-        )
-        setResolvedCache('.', resolvedEntryPoint, targetWeb)
-        return resolvedEntryPoint + postfix
-      }
-    }
-  } catch (e) {
-    packageEntryFailure(id, e.message)
-  }
-  packageEntryFailure(id)
-}
-
 function packageEntryFailure(id: string, details?: string) {
   const err: any = new Error(
     `Failed to resolve entry for package "${id}". ` +
@@ -1082,121 +164,6 @@ function packageEntryFailure(id: string, details?: string) {
   throw err
 }
 
-function resolveExportsOrImports(
-  pkg: PackageData['data'],
-  key: string,
-  options: InternalResolveOptionsWithOverrideConditions,
-  targetWeb: boolean,
-  type: 'imports' | 'exports',
-) {
-  const additionalConditions = new Set(
-    options.overrideConditions || [
-      'production',
-      'development',
-      'module',
-      ...options.conditions,
-    ],
-  )
-
-  const conditions = [...additionalConditions].filter((condition) => {
-    switch (condition) {
-      case 'production':
-        return options.isProduction
-      case 'development':
-        return !options.isProduction
-    }
-    return true
-  })
-
-  const fn = type === 'imports' ? imports : exports
-  const result = fn(pkg, key, {
-    browser: targetWeb && !additionalConditions.has('node'),
-    require: options.isRequire && !additionalConditions.has('import'),
-    conditions,
-  })
-
-  return result ? result[0] : undefined
-}
-
-function resolveDeepImport(
-  id: string,
-  {
-    webResolvedImports,
-    setResolvedCache,
-    getResolvedCache,
-    dir,
-    data,
-  }: PackageData,
-  targetWeb: boolean,
-  options: InternalResolveOptions,
-): string | undefined {
-  const cache = getResolvedCache(id, targetWeb)
-  if (cache) {
-    return cache
-  }
-
-  let relativeId: string | undefined | void = id
-  const { exports: exportsField, browser: browserField } = data
-
-  // map relative based on exports data
-  if (exportsField) {
-    if (isObject(exportsField) && !Array.isArray(exportsField)) {
-      // resolve without postfix (see #7098)
-      const { file, postfix } = splitFileAndPostfix(relativeId)
-      const exportsId = resolveExportsOrImports(
-        data,
-        file,
-        options,
-        targetWeb,
-        'exports',
-      )
-      if (exportsId !== undefined) {
-        relativeId = exportsId + postfix
-      } else {
-        relativeId = undefined
-      }
-    } else {
-      // not exposed
-      relativeId = undefined
-    }
-    if (!relativeId) {
-      throw new Error(
-        `Package subpath '${relativeId}' is not defined by "exports" in ` +
-          `${path.join(dir, 'package.json')}.`,
-      )
-    }
-  } else if (
-    targetWeb &&
-    options.mainFields.includes('browser') &&
-    isObject(browserField)
-  ) {
-    // resolve without postfix (see #7098)
-    const { file, postfix } = splitFileAndPostfix(relativeId)
-    const mapped = mapWithBrowserField(file, browserField)
-    if (mapped) {
-      relativeId = mapped + postfix
-    } else if (mapped === false) {
-      return (webResolvedImports[id] = browserExternalId)
-    }
-  }
-
-  if (relativeId) {
-    const resolved = tryFsResolve(
-      path.join(dir, relativeId),
-      options,
-      !exportsField, // try index only if no exports field
-      targetWeb,
-    )
-    if (resolved) {
-      debug?.(
-        `[node/deep-import] ${colors.cyan(id)} -> ${colors.dim(resolved)}`,
-      )
-      setResolvedCache(id, resolved, targetWeb)
-      return resolved
-    }
-  }
-}
-
 function tryResolveBrowserMapping(
   id: string,
   importer: string | undefined,
diff --git a/packages/vite/src/node/plugins/resolve/resolveDeepImport.ts b/packages/vite/src/node/plugins/resolve/resolveDeepImport.ts
new file mode 100644
index 000000000..d6088f0ee
--- /dev/null
+++ b/packages/vite/src/node/plugins/resolve/resolveDeepImport.ts
@@ -0,0 +1,238 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import { isObject } from 'packages/vite/src/node/utils';
+import { PackageData } from 'packages/vite/src/node/packages';
+import { DepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { SSROptions } from 'packages/vite/src/node/index';
+import { PackageCache } from 'packages/vite/src/node/packages';
+import { FsUtils } from 'packages/vite/src/node/fsUtils';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { isInNodeModules } from 'packages/vite/src/node/utils';
+import { exports, imports } from 'resolve.exports'
+
+
+// special id for paths marked with browser: false
+// https://github.com/defunctzombie/package-browser-field-spec#ignore-a-module
+export const browserExternalId = '__vite-browser-external'
+
+export interface ResolveOptions {
+  /**
+   * @default ['browser', 'module', 'jsnext:main', 'jsnext']
+   */
+  mainFields?: string[]
+  conditions?: string[]
+  /**
+   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
+   */
+  extensions?: string[]
+  dedupe?: string[]
+  /**
+   * @default false
+   */
+  preserveSymlinks?: boolean
+}
+
+export interface InternalResolveOptions extends Required<ResolveOptions> {
+  root: string
+  isBuild: boolean
+  isProduction: boolean
+  ssrConfig?: SSROptions
+  packageCache?: PackageCache
+  fsUtils?: FsUtils
+  /**
+   * src code mode also attempts the following:
+   * - resolving /xxx as URLs
+   * - resolving bare imports from optimized deps
+   */
+  asSrc?: boolean
+  tryIndex?: boolean
+  tryPrefix?: string
+  preferRelative?: boolean
+  isRequire?: boolean
+  // #3040
+  // when the importer is a ts module,
+  // if the specifier requests a non-existent `.js/jsx/mjs/cjs` file,
+  // should also try import from `.ts/tsx/mts/cts` source file as fallback.
+  isFromTsImporter?: boolean
+  tryEsmOnly?: boolean
+  // True when resolving during the scan phase to discover dependencies
+  scan?: boolean
+  // Appends ?__vite_skip_optimization to the resolved id if shouldn't be optimized
+  ssrOptimizeCheck?: boolean
+  // Resolve using esbuild deps optimization
+  getDepsOptimizer?: (ssr: boolean) => DepsOptimizer | undefined
+  shouldExternalize?: (id: string, importer?: string) => boolean | undefined
+
+  /**
+   * Set by createResolver, we only care about the resolved id. moduleSideEffects
+   * and other fields are discarded so we can avoid computing them.
+   * @internal
+   */
+  idOnly?: boolean
+}
+
+export function splitFileAndPostfix(path: string) {
+  const file = cleanUrl(path)
+  return { file, postfix: path.slice(file.length) }
+}
+
+export function tryFsResolve(
+  fsPath: string,
+  options: InternalResolveOptions,
+  tryIndex = true,
+  targetWeb = true,
+  skipPackageJson = false,
+): string | undefined {
+  // Dependencies like es5-ext use `#` in their paths. We don't support `#` in user
+  // source code so we only need to perform the check for dependencies.
+  // We don't support `?` in node_modules paths, so we only need to check in this branch.
+  const hashIndex = fsPath.indexOf('#')
+  if (hashIndex >= 0 && isInNodeModules(fsPath)) {
+    const queryIndex = fsPath.indexOf('?')
+    // We only need to check foo#bar?baz and foo#bar, ignore foo?bar#baz
+    if (queryIndex < 0 || queryIndex > hashIndex) {
+      const file = queryIndex > hashIndex ? fsPath.slice(0, queryIndex) : fsPath
+      const res = tryCleanFsResolve(
+        file,
+        options,
+        tryIndex,
+        targetWeb,
+        skipPackageJson,
+      )
+      if (res) return res + fsPath.slice(file.length)
+    }
+  }
+
+  const { file, postfix } = splitFileAndPostfix(fsPath)
+  const res = tryCleanFsResolve(
+    file,
+    options,
+    tryIndex,
+    targetWeb,
+    skipPackageJson,
+  )
+  if (res) return res + postfix
+}
+
+export type InternalResolveOptionsWithOverrideConditions =
+  InternalResolveOptions & {
+    /**
+     * @internal
+     */
+    overrideConditions?: string[]
+  }
+
+export function resolveExportsOrImports(
+  pkg: PackageData['data'],
+  key: string,
+  options: InternalResolveOptionsWithOverrideConditions,
+  targetWeb: boolean,
+  type: 'imports' | 'exports',
+) {
+  const additionalConditions = new Set(
+    options.overrideConditions || [
+      'production',
+      'development',
+      'module',
+      ...options.conditions,
+    ],
+  )
+
+  const conditions = [...additionalConditions].filter((condition) => {
+    switch (condition) {
+      case 'production':
+        return options.isProduction
+      case 'development':
+        return !options.isProduction
+    }
+    return true
+  })
+
+  const fn = type === 'imports' ? imports : exports
+  const result = fn(pkg, key, {
+    browser: targetWeb && !additionalConditions.has('node'),
+    require: options.isRequire && !additionalConditions.has('import'),
+    conditions,
+  })
+
+  return result ? result[0] : undefined
+}
+
+export function resolveDeepImport(
+  id: string,
+  {
+    webResolvedImports,
+    setResolvedCache,
+    getResolvedCache,
+    dir,
+    data,
+  }: PackageData,
+  targetWeb: boolean,
+  options: InternalResolveOptions,
+): string | undefined {
+  const cache = getResolvedCache(id, targetWeb)
+  if (cache) {
+    return cache
+  }
+
+  let relativeId: string | undefined | void = id
+  const { exports: exportsField, browser: browserField } = data
+
+  // map relative based on exports data
+  if (exportsField) {
+    if (isObject(exportsField) && !Array.isArray(exportsField)) {
+      // resolve without postfix (see #7098)
+      const { file, postfix } = splitFileAndPostfix(relativeId)
+      const exportsId = resolveExportsOrImports(
+        data,
+        file,
+        options,
+        targetWeb,
+        'exports',
+      )
+      if (exportsId !== undefined) {
+        relativeId = exportsId + postfix
+      } else {
+        relativeId = undefined
+      }
+    } else {
+      // not exposed
+      relativeId = undefined
+    }
+    if (!relativeId) {
+      throw new Error(
+        `Package subpath '${relativeId}' is not defined by "exports" in ` +
+          `${path.join(dir, 'package.json')}.`,
+      )
+    }
+  } else if (
+    targetWeb &&
+    options.mainFields.includes('browser') &&
+    isObject(browserField)
+  ) {
+    // resolve without postfix (see #7098)
+    const { file, postfix } = splitFileAndPostfix(relativeId)
+    const mapped = mapWithBrowserField(file, browserField)
+    if (mapped) {
+      relativeId = mapped + postfix
+    } else if (mapped === false) {
+      return (webResolvedImports[id] = browserExternalId)
+    }
+  }
+
+  if (relativeId) {
+    const resolved = tryFsResolve(
+      path.join(dir, relativeId),
+      options,
+      !exportsField, // try index only if no exports field
+      targetWeb,
+    )
+    if (resolved) {
+      debug?.(
+        `[node/deep-import] ${colors.cyan(id)} -> ${colors.dim(resolved)}`,
+      )
+      setResolvedCache(id, resolved, targetWeb)
+      return resolved
+    }
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/resolve/resolvePackageEntry.ts b/packages/vite/src/node/plugins/resolve/resolvePackageEntry.ts
new file mode 100644
index 000000000..ece6f681c
--- /dev/null
+++ b/packages/vite/src/node/plugins/resolve/resolvePackageEntry.ts
@@ -0,0 +1,207 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import { isObject } from 'packages/vite/src/node/utils';
+import { PackageData } from 'packages/vite/src/node/packages';
+import { DepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { SSROptions } from 'packages/vite/src/node/index';
+import { PackageCache } from 'packages/vite/src/node/packages';
+import { FsUtils } from 'packages/vite/src/node/fsUtils';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { isInNodeModules } from 'packages/vite/src/node/utils';
+
+
+export interface ResolveOptions {
+  /**
+   * @default ['browser', 'module', 'jsnext:main', 'jsnext']
+   */
+  mainFields?: string[]
+  conditions?: string[]
+  /**
+   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
+   */
+  extensions?: string[]
+  dedupe?: string[]
+  /**
+   * @default false
+   */
+  preserveSymlinks?: boolean
+}
+
+export interface InternalResolveOptions extends Required<ResolveOptions> {
+  root: string
+  isBuild: boolean
+  isProduction: boolean
+  ssrConfig?: SSROptions
+  packageCache?: PackageCache
+  fsUtils?: FsUtils
+  /**
+   * src code mode also attempts the following:
+   * - resolving /xxx as URLs
+   * - resolving bare imports from optimized deps
+   */
+  asSrc?: boolean
+  tryIndex?: boolean
+  tryPrefix?: string
+  preferRelative?: boolean
+  isRequire?: boolean
+  // #3040
+  // when the importer is a ts module,
+  // if the specifier requests a non-existent `.js/jsx/mjs/cjs` file,
+  // should also try import from `.ts/tsx/mts/cts` source file as fallback.
+  isFromTsImporter?: boolean
+  tryEsmOnly?: boolean
+  // True when resolving during the scan phase to discover dependencies
+  scan?: boolean
+  // Appends ?__vite_skip_optimization to the resolved id if shouldn't be optimized
+  ssrOptimizeCheck?: boolean
+  // Resolve using esbuild deps optimization
+  getDepsOptimizer?: (ssr: boolean) => DepsOptimizer | undefined
+  shouldExternalize?: (id: string, importer?: string) => boolean | undefined
+
+  /**
+   * Set by createResolver, we only care about the resolved id. moduleSideEffects
+   * and other fields are discarded so we can avoid computing them.
+   * @internal
+   */
+  idOnly?: boolean
+}
+
+export function splitFileAndPostfix(path: string) {
+  const file = cleanUrl(path)
+  return { file, postfix: path.slice(file.length) }
+}
+
+export function tryFsResolve(
+  fsPath: string,
+  options: InternalResolveOptions,
+  tryIndex = true,
+  targetWeb = true,
+  skipPackageJson = false,
+): string | undefined {
+  // Dependencies like es5-ext use `#` in their paths. We don't support `#` in user
+  // source code so we only need to perform the check for dependencies.
+  // We don't support `?` in node_modules paths, so we only need to check in this branch.
+  const hashIndex = fsPath.indexOf('#')
+  if (hashIndex >= 0 && isInNodeModules(fsPath)) {
+    const queryIndex = fsPath.indexOf('?')
+    // We only need to check foo#bar?baz and foo#bar, ignore foo?bar#baz
+    if (queryIndex < 0 || queryIndex > hashIndex) {
+      const file = queryIndex > hashIndex ? fsPath.slice(0, queryIndex) : fsPath
+      const res = tryCleanFsResolve(
+        file,
+        options,
+        tryIndex,
+        targetWeb,
+        skipPackageJson,
+      )
+      if (res) return res + fsPath.slice(file.length)
+    }
+  }
+
+  const { file, postfix } = splitFileAndPostfix(fsPath)
+  const res = tryCleanFsResolve(
+    file,
+    options,
+    tryIndex,
+    targetWeb,
+    skipPackageJson,
+  )
+  if (res) return res + postfix
+}
+
+export function resolvePackageEntry(
+  id: string,
+  { dir, data, setResolvedCache, getResolvedCache }: PackageData,
+  targetWeb: boolean,
+  options: InternalResolveOptions,
+): string | undefined {
+  const { file: idWithoutPostfix, postfix } = splitFileAndPostfix(id)
+
+  const cached = getResolvedCache('.', targetWeb)
+  if (cached) {
+    return cached + postfix
+  }
+
+  try {
+    let entryPoint: string | undefined
+
+    // resolve exports field with highest priority
+    // using https://github.com/lukeed/resolve.exports
+    if (data.exports) {
+      entryPoint = resolveExportsOrImports(
+        data,
+        '.',
+        options,
+        targetWeb,
+        'exports',
+      )
+    }
+
+    // fallback to mainFields if still not resolved
+    if (!entryPoint) {
+      for (const field of options.mainFields) {
+        if (field === 'browser') {
+          if (targetWeb) {
+            entryPoint = tryResolveBrowserEntry(dir, data, options)
+            if (entryPoint) {
+              break
+            }
+          }
+        } else if (typeof data[field] === 'string') {
+          entryPoint = data[field]
+          break
+        }
+      }
+    }
+    entryPoint ||= data.main
+
+    // try default entry when entry is not define
+    // https://nodejs.org/api/modules.html#all-together
+    const entryPoints = entryPoint
+      ? [entryPoint]
+      : ['index.js', 'index.json', 'index.node']
+
+    for (let entry of entryPoints) {
+      // make sure we don't get scripts when looking for sass
+      let skipPackageJson = false
+      if (
+        options.mainFields[0] === 'sass' &&
+        !options.extensions.includes(path.extname(entry))
+      ) {
+        entry = ''
+        skipPackageJson = true
+      } else {
+        // resolve object browser field in package.json
+        const { browser: browserField } = data
+        if (
+          targetWeb &&
+          options.mainFields.includes('browser') &&
+          isObject(browserField)
+        ) {
+          entry = mapWithBrowserField(entry, browserField) || entry
+        }
+      }
+
+      const entryPointPath = path.join(dir, entry)
+      const resolvedEntryPoint = tryFsResolve(
+        entryPointPath,
+        options,
+        true,
+        true,
+        skipPackageJson,
+      )
+      if (resolvedEntryPoint) {
+        debug?.(
+          `[package entry] ${colors.cyan(idWithoutPostfix)} -> ${colors.dim(
+            resolvedEntryPoint,
+          )}${postfix !== '' ? ` (postfix: ${postfix})` : ''}`,
+        )
+        setResolvedCache('.', resolvedEntryPoint, targetWeb)
+        return resolvedEntryPoint + postfix
+      }
+    }
+  } catch (e) {
+    packageEntryFailure(id, e.message)
+  }
+  packageEntryFailure(id)
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/resolve/resolvePlugin.ts b/packages/vite/src/node/plugins/resolve/resolvePlugin.ts
new file mode 100644
index 000000000..cadc7077f
--- /dev/null
+++ b/packages/vite/src/node/plugins/resolve/resolvePlugin.ts
@@ -0,0 +1,427 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import { Plugin } from 'packages/vite/src/node/plugin';
+import { FS_PREFIX } from 'packages/vite/src/node/constants';
+import { DEP_VERSION_RE } from 'packages/vite/src/node/constants';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { isTsRequest } from 'packages/vite/src/node/utils';
+import { injectQuery } from 'packages/vite/src/node/utils';
+import { isNonDriveRelativeAbsolutePath } from 'packages/vite/src/node/utils';
+import { isExternalUrl } from 'packages/vite/src/node/utils';
+import { isDataUrl } from 'packages/vite/src/node/utils';
+import { bareImportRE } from 'packages/vite/src/node/utils';
+import { isBuiltin } from 'packages/vite/src/node/utils';
+import { tryStatSync } from 'packages/vite/src/node/utils';
+import { withTrailingSlash } from 'packages/vite/src/shared/utils';
+import { isWindows } from 'packages/vite/src/shared/utils';
+import { DepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { SSROptions } from 'packages/vite/src/node/index';
+import { PackageCache } from 'packages/vite/src/node/packages';
+import { FsUtils } from 'packages/vite/src/node/fsUtils';
+
+
+// special id for paths marked with browser: false
+// https://github.com/defunctzombie/package-browser-field-spec#ignore-a-module
+export const browserExternalId = '__vite-browser-external'
+
+// special id for packages that are optional peer deps
+export const optionalPeerDepId = '__vite-optional-peer-dep'
+
+const export startsWithWordCharRE = /^\w/
+
+export interface ResolveOptions {
+  /**
+   * @default ['browser', 'module', 'jsnext:main', 'jsnext']
+   */
+  mainFields?: string[]
+  conditions?: string[]
+  /**
+   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
+   */
+  extensions?: string[]
+  dedupe?: string[]
+  /**
+   * @default false
+   */
+  preserveSymlinks?: boolean
+}
+
+export interface InternalResolveOptions extends Required<ResolveOptions> {
+  root: string
+  isBuild: boolean
+  isProduction: boolean
+  ssrConfig?: SSROptions
+  packageCache?: PackageCache
+  fsUtils?: FsUtils
+  /**
+   * src code mode also attempts the following:
+   * - resolving /xxx as URLs
+   * - resolving bare imports from optimized deps
+   */
+  asSrc?: boolean
+  tryIndex?: boolean
+  tryPrefix?: string
+  preferRelative?: boolean
+  isRequire?: boolean
+  // #3040
+  // when the importer is a ts module,
+  // if the specifier requests a non-existent `.js/jsx/mjs/cjs` file,
+  // should also try import from `.ts/tsx/mts/cts` source file as fallback.
+  isFromTsImporter?: boolean
+  tryEsmOnly?: boolean
+  // True when resolving during the scan phase to discover dependencies
+  scan?: boolean
+  // Appends ?__vite_skip_optimization to the resolved id if shouldn't be optimized
+  ssrOptimizeCheck?: boolean
+  // Resolve using esbuild deps optimization
+  getDepsOptimizer?: (ssr: boolean) => DepsOptimizer | undefined
+  shouldExternalize?: (id: string, importer?: string) => boolean | undefined
+
+  /**
+   * Set by createResolver, we only care about the resolved id. moduleSideEffects
+   * and other fields are discarded so we can avoid computing them.
+   * @internal
+   */
+  idOnly?: boolean
+}
+
+export function resolvePlugin(resolveOptions: InternalResolveOptions): Plugin {
+  const {
+    root,
+    isProduction,
+    asSrc,
+    ssrConfig,
+    preferRelative = false,
+  } = resolveOptions
+
+  const {
+    target: ssrTarget,
+    noExternal: ssrNoExternal,
+    external: ssrExternal,
+  } = ssrConfig ?? {}
+
+  // In unix systems, absolute paths inside root first needs to be checked as an
+  // absolute URL (/root/root/path-to-file) resulting in failed checks before falling
+  // back to checking the path as absolute. If /root/root isn't a valid path, we can
+  // avoid these checks. Absolute paths inside root are common in user code as many
+  // paths are resolved by the user. For example for an alias.
+  const rootInRoot = tryStatSync(path.join(root, root))?.isDirectory() ?? false
+
+  return {
+    name: 'vite:resolve',
+
+    async resolveId(id, importer, resolveOpts) {
+      if (
+        id[0] === '\0' ||
+        id.startsWith('virtual:') ||
+        // When injected directly in html/client code
+        id.startsWith('/virtual:')
+      ) {
+        return
+      }
+
+      const ssr = resolveOpts?.ssr === true
+
+      // We need to delay depsOptimizer until here instead of passing it as an option
+      // the resolvePlugin because the optimizer is created on server listen during dev
+      const depsOptimizer = resolveOptions.getDepsOptimizer?.(ssr)
+
+      if (id.startsWith(browserExternalId)) {
+        return id
+      }
+
+      const targetWeb = !ssr || ssrTarget === 'webworker'
+
+      // this is passed by @rollup/plugin-commonjs
+      const isRequire: boolean =
+        resolveOpts?.custom?.['node-resolve']?.isRequire ?? false
+
+      // end user can configure different conditions for ssr and client.
+      // falls back to client conditions if no ssr conditions supplied
+      const ssrConditions =
+        resolveOptions.ssrConfig?.resolve?.conditions ||
+        resolveOptions.conditions
+
+      const options: InternalResolveOptions = {
+        isRequire,
+        ...resolveOptions,
+        scan: resolveOpts?.scan ?? resolveOptions.scan,
+        conditions: ssr ? ssrConditions : resolveOptions.conditions,
+      }
+
+      const resolvedImports = resolveSubpathImports(
+        id,
+        importer,
+        options,
+        targetWeb,
+      )
+      if (resolvedImports) {
+        id = resolvedImports
+
+        if (resolveOpts.custom?.['vite:import-glob']?.isSubImportsPattern) {
+          return normalizePath(path.join(root, id))
+        }
+      }
+
+      if (importer) {
+        if (
+          isTsRequest(importer) ||
+          resolveOpts.custom?.depScan?.loader?.startsWith('ts')
+        ) {
+          options.isFromTsImporter = true
+        } else {
+          const moduleLang = this.getModuleInfo(importer)?.meta?.vite?.lang
+          options.isFromTsImporter = moduleLang && isTsRequest(`.${moduleLang}`)
+        }
+      }
+
+      let res: string | PartialResolvedId | undefined
+
+      // resolve pre-bundled deps requests, these could be resolved by
+      // tryFileResolve or /fs/ resolution but these files may not yet
+      // exists if we are in the middle of a deps re-processing
+      if (asSrc && depsOptimizer?.isOptimizedDepUrl(id)) {
+        const optimizedPath = id.startsWith(FS_PREFIX)
+          ? fsPathFromId(id)
+          : normalizePath(path.resolve(root, id.slice(1)))
+        return optimizedPath
+      }
+
+      // explicit fs paths that starts with /@fs/*
+      if (asSrc && id.startsWith(FS_PREFIX)) {
+        res = fsPathFromId(id)
+        // We don't need to resolve these paths since they are already resolved
+        // always return here even if res doesn't exist since /@fs/ is explicit
+        // if the file doesn't exist it should be a 404.
+        debug?.(`[@fs] ${colors.cyan(id)} -> ${colors.dim(res)}`)
+        return ensureVersionQuery(res, id, options, depsOptimizer)
+      }
+
+      // URL
+      // /foo -> /fs-root/foo
+      if (
+        asSrc &&
+        id[0] === '/' &&
+        (rootInRoot || !id.startsWith(withTrailingSlash(root)))
+      ) {
+        const fsPath = path.resolve(root, id.slice(1))
+        if ((res = tryFsResolve(fsPath, options))) {
+          debug?.(`[url] ${colors.cyan(id)} -> ${colors.dim(res)}`)
+          return ensureVersionQuery(res, id, options, depsOptimizer)
+        }
+      }
+
+      // relative
+      if (
+        id[0] === '.' ||
+        ((preferRelative || importer?.endsWith('.html')) &&
+          startsWithWordCharRE.test(id))
+      ) {
+        const basedir = importer ? path.dirname(importer) : process.cwd()
+        const fsPath = path.resolve(basedir, id)
+        // handle browser field mapping for relative imports
+
+        const normalizedFsPath = normalizePath(fsPath)
+
+        if (depsOptimizer?.isOptimizedDepFile(normalizedFsPath)) {
+          // Optimized files could not yet exist in disk, resolve to the full path
+          // Inject the current browserHash version if the path doesn't have one
+          if (
+            !resolveOptions.isBuild &&
+            !DEP_VERSION_RE.test(normalizedFsPath)
+          ) {
+            const browserHash = optimizedDepInfoFromFile(
+              depsOptimizer.metadata,
+              normalizedFsPath,
+            )?.browserHash
+            if (browserHash) {
+              return injectQuery(normalizedFsPath, `v=${browserHash}`)
+            }
+          }
+          return normalizedFsPath
+        }
+
+        if (
+          targetWeb &&
+          options.mainFields.includes('browser') &&
+          (res = tryResolveBrowserMapping(fsPath, importer, options, true))
+        ) {
+          return res
+        }
+
+        if ((res = tryFsResolve(fsPath, options))) {
+          res = ensureVersionQuery(res, id, options, depsOptimizer)
+          debug?.(`[relative] ${colors.cyan(id)} -> ${colors.dim(res)}`)
+
+          // If this isn't a script imported from a .html file, include side effects
+          // hints so the non-used code is properly tree-shaken during build time.
+          if (
+            !options.idOnly &&
+            !options.scan &&
+            options.isBuild &&
+            !importer?.endsWith('.html')
+          ) {
+            const resPkg = findNearestPackageData(
+              path.dirname(res),
+              options.packageCache,
+            )
+            if (resPkg) {
+              return {
+                id: res,
+                moduleSideEffects: resPkg.hasSideEffects(res),
+              }
+            }
+          }
+          return res
+        }
+      }
+
+      // drive relative fs paths (only windows)
+      if (isWindows && id[0] === '/') {
+        const basedir = importer ? path.dirname(importer) : process.cwd()
+        const fsPath = path.resolve(basedir, id)
+        if ((res = tryFsResolve(fsPath, options))) {
+          debug?.(`[drive-relative] ${colors.cyan(id)} -> ${colors.dim(res)}`)
+          return ensureVersionQuery(res, id, options, depsOptimizer)
+        }
+      }
+
+      // absolute fs paths
+      if (
+        isNonDriveRelativeAbsolutePath(id) &&
+        (res = tryFsResolve(id, options))
+      ) {
+        debug?.(`[fs] ${colors.cyan(id)} -> ${colors.dim(res)}`)
+        return ensureVersionQuery(res, id, options, depsOptimizer)
+      }
+
+      // external
+      if (isExternalUrl(id)) {
+        return options.idOnly ? id : { id, external: true }
+      }
+
+      // data uri: pass through (this only happens during build and will be
+      // handled by dedicated plugin)
+      if (isDataUrl(id)) {
+        return null
+      }
+
+      // bare package imports, perform node resolve
+      if (bareImportRE.test(id)) {
+        const external = options.shouldExternalize?.(id, importer)
+        if (
+          !external &&
+          asSrc &&
+          depsOptimizer &&
+          !options.scan &&
+          (res = await tryOptimizedResolve(
+            depsOptimizer,
+            id,
+            importer,
+            options.preserveSymlinks,
+            options.packageCache,
+          ))
+        ) {
+          return res
+        }
+
+        if (
+          targetWeb &&
+          options.mainFields.includes('browser') &&
+          (res = tryResolveBrowserMapping(
+            id,
+            importer,
+            options,
+            false,
+            external,
+          ))
+        ) {
+          return res
+        }
+
+        if (
+          (res = tryNodeResolve(
+            id,
+            importer,
+            options,
+            targetWeb,
+            depsOptimizer,
+            ssr,
+            external,
+          ))
+        ) {
+          return res
+        }
+
+        // node built-ins.
+        // externalize if building for SSR, otherwise redirect to empty module
+        if (isBuiltin(id)) {
+          if (ssr) {
+            if (
+              targetWeb &&
+              ssrNoExternal === true &&
+              // if both noExternal and external are true, noExternal will take the higher priority and bundle it.
+              // only if the id is explicitly listed in external, we will externalize it and skip this error.
+              (ssrExternal === true || !ssrExternal?.includes(id))
+            ) {
+              let message = `Cannot bundle Node.js built-in "${id}"`
+              if (importer) {
+                message += ` imported from "${path.relative(
+                  process.cwd(),
+                  importer,
+                )}"`
+              }
+              message += `. Consider disabling ssr.noExternal or remove the built-in dependency.`
+              this.error(message)
+            }
+
+            return options.idOnly
+              ? id
+              : { id, external: true, moduleSideEffects: false }
+          } else {
+            if (!asSrc) {
+              debug?.(
+                `externalized node built-in "${id}" to empty module. ` +
+                  `(imported by: ${colors.white(colors.dim(importer))})`,
+              )
+            } else if (isProduction) {
+              this.warn(
+                `Module "${id}" has been externalized for browser compatibility, imported by "${importer}". ` +
+                  `See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`,
+              )
+            }
+            return isProduction
+              ? browserExternalId
+              : `${browserExternalId}:${id}`
+          }
+        }
+      }
+
+      debug?.(`[fallthrough] ${colors.dim(id)}`)
+    },
+
+    load(id) {
+      if (id.startsWith(browserExternalId)) {
+        if (isProduction) {
+          return `export default {}`
+        } else {
+          id = id.slice(browserExternalId.length + 1)
+          return `\
+export default new Proxy({}, {
+  get(_, key) {
+    throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.  See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
+  }
+})`
+        }
+      }
+      if (id.startsWith(optionalPeerDepId)) {
+        if (isProduction) {
+          return `export default {}`
+        } else {
+          const [, peerDep, parentDep] = id.split(':')
+          return `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`
+        }
+      }
+    },
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/resolve/tryCleanFsResolve.ts b/packages/vite/src/node/plugins/resolve/tryCleanFsResolve.ts
new file mode 100644
index 000000000..72cc1effe
--- /dev/null
+++ b/packages/vite/src/node/plugins/resolve/tryCleanFsResolve.ts
@@ -0,0 +1,189 @@
+import path from 'node:path'
+import { commonFsUtils } from 'packages/vite/src/node/fsUtils';
+import { loadPackageData } from 'packages/vite/src/node/packages';
+import { DepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { SSROptions } from 'packages/vite/src/node/index';
+import { PackageCache } from 'packages/vite/src/node/packages';
+import { FsUtils } from 'packages/vite/src/node/fsUtils';
+
+
+const export ERR_RESOLVE_PACKAGE_ENTRY_FAIL = 'ERR_RESOLVE_PACKAGE_ENTRY_FAIL'
+
+export interface ResolveOptions {
+  /**
+   * @default ['browser', 'module', 'jsnext:main', 'jsnext']
+   */
+  mainFields?: string[]
+  conditions?: string[]
+  /**
+   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
+   */
+  extensions?: string[]
+  dedupe?: string[]
+  /**
+   * @default false
+   */
+  preserveSymlinks?: boolean
+}
+
+export interface InternalResolveOptions extends Required<ResolveOptions> {
+  root: string
+  isBuild: boolean
+  isProduction: boolean
+  ssrConfig?: SSROptions
+  packageCache?: PackageCache
+  fsUtils?: FsUtils
+  /**
+   * src code mode also attempts the following:
+   * - resolving /xxx as URLs
+   * - resolving bare imports from optimized deps
+   */
+  asSrc?: boolean
+  tryIndex?: boolean
+  tryPrefix?: string
+  preferRelative?: boolean
+  isRequire?: boolean
+  // #3040
+  // when the importer is a ts module,
+  // if the specifier requests a non-existent `.js/jsx/mjs/cjs` file,
+  // should also try import from `.ts/tsx/mts/cts` source file as fallback.
+  isFromTsImporter?: boolean
+  tryEsmOnly?: boolean
+  // True when resolving during the scan phase to discover dependencies
+  scan?: boolean
+  // Appends ?__vite_skip_optimization to the resolved id if shouldn't be optimized
+  ssrOptimizeCheck?: boolean
+  // Resolve using esbuild deps optimization
+  getDepsOptimizer?: (ssr: boolean) => DepsOptimizer | undefined
+  shouldExternalize?: (id: string, importer?: string) => boolean | undefined
+
+  /**
+   * Set by createResolver, we only care about the resolved id. moduleSideEffects
+   * and other fields are discarded so we can avoid computing them.
+   * @internal
+   */
+  idOnly?: boolean
+}
+
+const export knownTsOutputRE = /\.(?:js|mjs|cjs|jsx)$/
+
+export const isPossibleTsOutput = (url: string): boolean => knownTsOutputRE.test(url)
+
+export function tryCleanFsResolve(
+  file: string,
+  options: InternalResolveOptions,
+  tryIndex = true,
+  targetWeb = true,
+  skipPackageJson = false,
+): string | undefined {
+  const { tryPrefix, extensions, preserveSymlinks } = options
+
+  const fsUtils = options.fsUtils ?? commonFsUtils
+
+  // Optimization to get the real type or file type (directory, file, other)
+  const fileResult = fsUtils.tryResolveRealFileOrType(
+    file,
+    options.preserveSymlinks,
+  )
+
+  if (fileResult?.path) return fileResult.path
+
+  let res: string | undefined
+
+  // If path.dirname is a valid directory, try extensions and ts resolution logic
+  const possibleJsToTs = options.isFromTsImporter && isPossibleTsOutput(file)
+  if (possibleJsToTs || options.extensions.length || tryPrefix) {
+    const dirPath = path.dirname(file)
+    if (fsUtils.isDirectory(dirPath)) {
+      if (possibleJsToTs) {
+        // try resolve .js, .mjs, .cjs or .jsx import to typescript file
+        const fileExt = path.extname(file)
+        const fileName = file.slice(0, -fileExt.length)
+        if (
+          (res = fsUtils.tryResolveRealFile(
+            fileName + fileExt.replace('js', 'ts'),
+            preserveSymlinks,
+          ))
+        )
+          return res
+        // for .js, also try .tsx
+        if (
+          fileExt === '.js' &&
+          (res = fsUtils.tryResolveRealFile(
+            fileName + '.tsx',
+            preserveSymlinks,
+          ))
+        )
+          return res
+      }
+
+      if (
+        (res = fsUtils.tryResolveRealFileWithExtensions(
+          file,
+          extensions,
+          preserveSymlinks,
+        ))
+      )
+        return res
+
+      if (tryPrefix) {
+        const prefixed = `${dirPath}/${options.tryPrefix}${path.basename(file)}`
+
+        if ((res = fsUtils.tryResolveRealFile(prefixed, preserveSymlinks)))
+          return res
+
+        if (
+          (res = fsUtils.tryResolveRealFileWithExtensions(
+            prefixed,
+            extensions,
+            preserveSymlinks,
+          ))
+        )
+          return res
+      }
+    }
+  }
+
+  if (tryIndex && fileResult?.type === 'directory') {
+    // Path points to a directory, check for package.json and entry and /index file
+    const dirPath = file
+
+    if (!skipPackageJson) {
+      let pkgPath = `${dirPath}/package.json`
+      try {
+        if (fsUtils.existsSync(pkgPath)) {
+          if (!options.preserveSymlinks) {
+            pkgPath = safeRealpathSync(pkgPath)
+          }
+          // path points to a node package
+          const pkg = loadPackageData(pkgPath)
+          return resolvePackageEntry(dirPath, pkg, targetWeb, options)
+        }
+      } catch (e) {
+        // This check is best effort, so if an entry is not found, skip error for now
+        if (e.code !== ERR_RESOLVE_PACKAGE_ENTRY_FAIL && e.code !== 'ENOENT')
+          throw e
+      }
+    }
+
+    if (
+      (res = fsUtils.tryResolveRealFileWithExtensions(
+        `${dirPath}/index`,
+        extensions,
+        preserveSymlinks,
+      ))
+    )
+      return res
+
+    if (tryPrefix) {
+      if (
+        (res = fsUtils.tryResolveRealFileWithExtensions(
+          `${dirPath}/${options.tryPrefix}index`,
+          extensions,
+          preserveSymlinks,
+        ))
+      )
+        return res
+    }
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/resolve/tryNodeResolve.ts b/packages/vite/src/node/plugins/resolve/tryNodeResolve.ts
new file mode 100644
index 000000000..32bd0bfc0
--- /dev/null
+++ b/packages/vite/src/node/plugins/resolve/tryNodeResolve.ts
@@ -0,0 +1,308 @@
+import fs from 'node:fs'
+import path from 'node:path'
+import colors from 'picocolors'
+import type { PartialResolvedId } from 'rollup'
+import { DEFAULT_MAIN_FIELDS } from 'packages/vite/src/node/constants';
+import { DEFAULT_EXTENSIONS } from 'packages/vite/src/node/constants';
+import { OPTIMIZABLE_ENTRY_RE } from 'packages/vite/src/node/constants';
+import { SPECIAL_QUERY_RE } from 'packages/vite/src/node/constants';
+import { isBuiltin } from 'packages/vite/src/node/utils';
+import { bareImportRE } from 'packages/vite/src/node/utils';
+import { isInNodeModules } from 'packages/vite/src/node/utils';
+import { injectQuery } from 'packages/vite/src/node/utils';
+import { deepImportRE } from 'packages/vite/src/node/utils';
+import { getNpmPackageName } from 'packages/vite/src/node/utils';
+import { isOptimizable } from 'packages/vite/src/node/utils';
+import { isFilePathESM } from 'packages/vite/src/node/utils';
+import { DepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { findNearestPackageData } from 'packages/vite/src/node/packages';
+import { resolvePackageData } from 'packages/vite/src/node/packages';
+import { findNearestMainPackageData } from 'packages/vite/src/node/packages';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { SSROptions } from 'packages/vite/src/node/index';
+import { PackageCache } from 'packages/vite/src/node/packages';
+import { FsUtils } from 'packages/vite/src/node/fsUtils';
+
+
+// special id for packages that are optional peer deps
+export const optionalPeerDepId = '__vite-optional-peer-dep'
+
+export interface ResolveOptions {
+  /**
+   * @default ['browser', 'module', 'jsnext:main', 'jsnext']
+   */
+  mainFields?: string[]
+  conditions?: string[]
+  /**
+   * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']
+   */
+  extensions?: string[]
+  dedupe?: string[]
+  /**
+   * @default false
+   */
+  preserveSymlinks?: boolean
+}
+
+export interface InternalResolveOptions extends Required<ResolveOptions> {
+  root: string
+  isBuild: boolean
+  isProduction: boolean
+  ssrConfig?: SSROptions
+  packageCache?: PackageCache
+  fsUtils?: FsUtils
+  /**
+   * src code mode also attempts the following:
+   * - resolving /xxx as URLs
+   * - resolving bare imports from optimized deps
+   */
+  asSrc?: boolean
+  tryIndex?: boolean
+  tryPrefix?: string
+  preferRelative?: boolean
+  isRequire?: boolean
+  // #3040
+  // when the importer is a ts module,
+  // if the specifier requests a non-existent `.js/jsx/mjs/cjs` file,
+  // should also try import from `.ts/tsx/mts/cts` source file as fallback.
+  isFromTsImporter?: boolean
+  tryEsmOnly?: boolean
+  // True when resolving during the scan phase to discover dependencies
+  scan?: boolean
+  // Appends ?__vite_skip_optimization to the resolved id if shouldn't be optimized
+  ssrOptimizeCheck?: boolean
+  // Resolve using esbuild deps optimization
+  getDepsOptimizer?: (ssr: boolean) => DepsOptimizer | undefined
+  shouldExternalize?: (id: string, importer?: string) => boolean | undefined
+
+  /**
+   * Set by createResolver, we only care about the resolved id. moduleSideEffects
+   * and other fields are discarded so we can avoid computing them.
+   * @internal
+   */
+  idOnly?: boolean
+}
+
+export type InternalResolveOptionsWithOverrideConditions =
+  InternalResolveOptions & {
+    /**
+     * @internal
+     */
+    overrideConditions?: string[]
+  }
+
+export function tryNodeResolve(
+  id: string,
+  importer: string | null | undefined,
+  options: InternalResolveOptionsWithOverrideConditions,
+  targetWeb: boolean,
+  depsOptimizer?: DepsOptimizer,
+  ssr: boolean = false,
+  externalize?: boolean,
+  allowLinkedExternal: boolean = true,
+): PartialResolvedId | undefined {
+  const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options
+
+  // check for deep import, e.g. "my-lib/foo"
+  const deepMatch = deepImportRE.exec(id)
+  // package name doesn't include postfixes
+  // trim them to support importing package with queries (e.g. `import css from 'normalize.css?inline'`)
+  const pkgId = deepMatch ? deepMatch[1] || deepMatch[2] : cleanUrl(id)
+
+  let basedir: string
+  if (dedupe?.includes(pkgId)) {
+    basedir = root
+  } else if (
+    importer &&
+    path.isAbsolute(importer) &&
+    // css processing appends `*` for importer
+    (importer[importer.length - 1] === '*' || fs.existsSync(cleanUrl(importer)))
+  ) {
+    basedir = path.dirname(importer)
+  } else {
+    basedir = root
+  }
+
+  let selfPkg = null
+  if (!isBuiltin(id) && !id.includes('\0') && bareImportRE.test(id)) {
+    // check if it's a self reference dep.
+    const selfPackageData = findNearestPackageData(basedir, packageCache)
+    selfPkg =
+      selfPackageData?.data.exports && selfPackageData?.data.name === pkgId
+        ? selfPackageData
+        : null
+  }
+
+  const pkg =
+    selfPkg ||
+    resolvePackageData(pkgId, basedir, preserveSymlinks, packageCache)
+  if (!pkg) {
+    // if import can't be found, check if it's an optional peer dep.
+    // if so, we can resolve to a special id that errors only when imported.
+    if (
+      basedir !== root && // root has no peer dep
+      !isBuiltin(id) &&
+      !id.includes('\0') &&
+      bareImportRE.test(id)
+    ) {
+      const mainPkg = findNearestMainPackageData(basedir, packageCache)?.data
+      if (mainPkg) {
+        const pkgName = getNpmPackageName(id)
+        if (
+          pkgName != null &&
+          mainPkg.peerDependencies?.[pkgName] &&
+          mainPkg.peerDependenciesMeta?.[pkgName]?.optional
+        ) {
+          return {
+            id: `${optionalPeerDepId}:${id}:${mainPkg.name}`,
+          }
+        }
+      }
+    }
+    return
+  }
+
+  const resolveId = deepMatch ? resolveDeepImport : resolvePackageEntry
+  const unresolvedId = deepMatch ? '.' + id.slice(pkgId.length) : id
+
+  let resolved: string | undefined
+  try {
+    resolved = resolveId(unresolvedId, pkg, targetWeb, options)
+  } catch (err) {
+    if (!options.tryEsmOnly) {
+      throw err
+    }
+  }
+  if (!resolved && options.tryEsmOnly) {
+    resolved = resolveId(unresolvedId, pkg, targetWeb, {
+      ...options,
+      isRequire: false,
+      mainFields: DEFAULT_MAIN_FIELDS,
+      extensions: DEFAULT_EXTENSIONS,
+    })
+  }
+  if (!resolved) {
+    return
+  }
+
+  const processResult = (resolved: PartialResolvedId) => {
+    if (!externalize) {
+      return resolved
+    }
+    // don't external symlink packages
+    if (!allowLinkedExternal && !isInNodeModules(resolved.id)) {
+      return resolved
+    }
+    const resolvedExt = path.extname(resolved.id)
+    // don't external non-js imports
+    if (
+      resolvedExt &&
+      resolvedExt !== '.js' &&
+      resolvedExt !== '.mjs' &&
+      resolvedExt !== '.cjs'
+    ) {
+      return resolved
+    }
+    let resolvedId = id
+    if (deepMatch && !pkg?.data.exports && path.extname(id) !== resolvedExt) {
+      // id date-fns/locale
+      // resolve.id ...date-fns/esm/locale/index.js
+      const index = resolved.id.indexOf(id)
+      if (index > -1) {
+        resolvedId = resolved.id.slice(index)
+        debug?.(
+          `[processResult] ${colors.cyan(id)} -> ${colors.dim(resolvedId)}`,
+        )
+      }
+    }
+    return { ...resolved, id: resolvedId, external: true }
+  }
+
+  if (
+    !options.idOnly &&
+    ((!options.scan && isBuild && !depsOptimizer) || externalize)
+  ) {
+    // Resolve package side effects for build so that rollup can better
+    // perform tree-shaking
+    return processResult({
+      id: resolved,
+      moduleSideEffects: pkg.hasSideEffects(resolved),
+    })
+  }
+
+  if (
+    !options.ssrOptimizeCheck &&
+    (!isInNodeModules(resolved) || // linked
+      !depsOptimizer || // resolving before listening to the server
+      options.scan) // initial esbuild scan phase
+  ) {
+    return { id: resolved }
+  }
+
+  // if we reach here, it's a valid dep import that hasn't been optimized.
+  const isJsType = depsOptimizer
+    ? isOptimizable(resolved, depsOptimizer.options)
+    : OPTIMIZABLE_ENTRY_RE.test(resolved)
+
+  let exclude = depsOptimizer?.options.exclude
+  let include = depsOptimizer?.options.include
+  if (options.ssrOptimizeCheck) {
+    // we don't have the depsOptimizer
+    exclude = options.ssrConfig?.optimizeDeps?.exclude
+    include = options.ssrConfig?.optimizeDeps?.include
+  }
+
+  const skipOptimization =
+    (!options.ssrOptimizeCheck && depsOptimizer?.options.noDiscovery) ||
+    !isJsType ||
+    (importer && isInNodeModules(importer)) ||
+    exclude?.includes(pkgId) ||
+    exclude?.includes(id) ||
+    SPECIAL_QUERY_RE.test(resolved) ||
+    // During dev SSR, we don't have a way to reload the module graph if
+    // a non-optimized dep is found. So we need to skip optimization here.
+    // The only optimized deps are the ones explicitly listed in the config.
+    (!options.ssrOptimizeCheck && !isBuild && ssr) ||
+    // Only optimize non-external CJS deps during SSR by default
+    (ssr &&
+      isFilePathESM(resolved, options.packageCache) &&
+      !(include?.includes(pkgId) || include?.includes(id)))
+
+  if (options.ssrOptimizeCheck) {
+    return {
+      id: skipOptimization
+        ? injectQuery(resolved, `__vite_skip_optimization`)
+        : resolved,
+    }
+  }
+
+  if (skipOptimization) {
+    // excluded from optimization
+    // Inject a version query to npm deps so that the browser
+    // can cache it without re-validation, but only do so for known js types.
+    // otherwise we may introduce duplicated modules for externalized files
+    // from pre-bundled deps.
+    if (!isBuild) {
+      const versionHash = depsOptimizer!.metadata.browserHash
+      if (versionHash && isJsType) {
+        resolved = injectQuery(resolved, `v=${versionHash}`)
+      }
+    }
+  } else {
+    // this is a missing import, queue optimize-deps re-run and
+    // get a resolved its optimized info
+    const optimizedInfo = depsOptimizer!.registerMissingImport(id, resolved)
+    resolved = depsOptimizer!.getOptimizedDepId(optimizedInfo)
+  }
+
+  if (!options.idOnly && !options.scan && isBuild) {
+    // Resolve package side effects for build so that rollup can better
+    // perform tree-shaking
+    return {
+      id: resolved,
+      moduleSideEffects: pkg.hasSideEffects(resolved),
+    }
+  } else {
+    return { id: resolved! }
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/resolve/tryOptimizedResolve.ts b/packages/vite/src/node/plugins/resolve/tryOptimizedResolve.ts
new file mode 100644
index 000000000..0b9b3d111
--- /dev/null
+++ b/packages/vite/src/node/plugins/resolve/tryOptimizedResolve.ts
@@ -0,0 +1,63 @@
+import { getNpmPackageName } from 'packages/vite/src/node/utils';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { optimizedDepInfoFromId } from 'packages/vite/src/node/optimizer/index';
+import { DepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { PackageCache } from 'packages/vite/src/node/packages';
+import { resolvePackageData } from 'packages/vite/src/node/packages';
+import { withTrailingSlash } from 'packages/vite/src/shared/utils';
+
+
+export async function tryOptimizedResolve(
+  depsOptimizer: DepsOptimizer,
+  id: string,
+  importer?: string,
+  preserveSymlinks?: boolean,
+  packageCache?: PackageCache,
+): Promise<string | undefined> {
+  // TODO: we need to wait until scanning is done here as this function
+  // is used in the preAliasPlugin to decide if an aliased dep is optimized,
+  // and avoid replacing the bare import with the resolved path.
+  // We should be able to remove this in the future
+  await depsOptimizer.scanProcessing
+
+  const metadata = depsOptimizer.metadata
+
+  const depInfo = optimizedDepInfoFromId(metadata, id)
+  if (depInfo) {
+    return depsOptimizer.getOptimizedDepId(depInfo)
+  }
+
+  if (!importer) return
+
+  // further check if id is imported by nested dependency
+  let idPkgDir: string | undefined
+  const nestedIdMatch = `> ${id}`
+
+  for (const optimizedData of metadata.depInfoList) {
+    if (!optimizedData.src) continue // Ignore chunks
+
+    // check where "foo" is nested in "my-lib > foo"
+    if (!optimizedData.id.endsWith(nestedIdMatch)) continue
+
+    // lazily initialize idPkgDir
+    if (idPkgDir == null) {
+      const pkgName = getNpmPackageName(id)
+      if (!pkgName) break
+      idPkgDir = resolvePackageData(
+        pkgName,
+        importer,
+        preserveSymlinks,
+        packageCache,
+      )?.dir
+      // if still null, it likely means that this id isn't a dep for importer.
+      // break to bail early
+      if (idPkgDir == null) break
+      idPkgDir = normalizePath(idPkgDir)
+    }
+
+    // match by src to correctly identify if id belongs to nested dependency
+    if (optimizedData.src.startsWith(withTrailingSlash(idPkgDir))) {
+      return depsOptimizer.getOptimizedDepId(optimizedData)
+    }
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/plugins/wasm.ts b/packages/vite/src/node/plugins/wasm.ts
index 407ea5f00..3522fbbf5 100644
--- a/packages/vite/src/node/plugins/wasm.ts
+++ b/packages/vite/src/node/plugins/wasm.ts
@@ -1,4 +1,4 @@
-import type { ResolvedConfig } from '../config'
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import type { Plugin } from '../plugin'
 import { fileToUrl } from './asset'
 
diff --git a/packages/vite/src/node/plugins/worker.ts b/packages/vite/src/node/plugins/worker.ts
index dcaed0473..2155a04ce 100644
--- a/packages/vite/src/node/plugins/worker.ts
+++ b/packages/vite/src/node/plugins/worker.ts
@@ -1,9 +1,12 @@
+import { onRollupWarning } from 'packages/vite/src/node/build/onRollupWarning';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import path from 'node:path'
 import MagicString from 'magic-string'
 import type { OutputChunk } from 'rollup'
-import type { ResolvedConfig } from '../config'
 import type { Plugin } from '../plugin'
-import type { ViteDevServer } from '../server'
 import { ENV_ENTRY, ENV_PUBLIC_PATH } from '../constants'
 import {
   encodeURIPath,
@@ -14,7 +17,6 @@ import {
 } from '../utils'
 import {
   createToImportMetaURLBasedRelativeRuntime,
-  onRollupWarning,
   toOutputFilePathInJS,
 } from '../build'
 import { cleanUrl } from '../../shared/utils'
diff --git a/packages/vite/src/node/plugins/workerImportMetaUrl.ts b/packages/vite/src/node/plugins/workerImportMetaUrl.ts
index 4065c6470..584e9aa1d 100644
--- a/packages/vite/src/node/plugins/workerImportMetaUrl.ts
+++ b/packages/vite/src/node/plugins/workerImportMetaUrl.ts
@@ -1,8 +1,15 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { tryFsResolve } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { tryFsResolve } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
 import path from 'node:path'
 import MagicString from 'magic-string'
 import type { RollupError } from 'rollup'
 import { stripLiteral } from 'strip-literal'
-import type { ResolvedConfig } from '../config'
 import type { Plugin } from '../plugin'
 import { evalValue, injectQuery, transformStableResult } from '../utils'
 import type { ResolveFn } from '..'
@@ -10,8 +17,6 @@ import { cleanUrl, slash } from '../../shared/utils'
 import type { WorkerType } from './worker'
 import { WORKER_FILE_ID, workerFileToUrl } from './worker'
 import { fileToUrl } from './asset'
-import type { InternalResolveOptions } from './resolve'
-import { tryFsResolve } from './resolve'
 import { hasViteIgnoreRE } from './importAnalysis'
 
 interface WorkerOptions {
diff --git a/packages/vite/src/node/preview.ts b/packages/vite/src/node/preview.ts
index 38192abea..4b59e43bc 100644
--- a/packages/vite/src/node/preview.ts
+++ b/packages/vite/src/node/preview.ts
@@ -1,3 +1,15 @@
+import { InlineConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { HttpServer } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/_createServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { ResolvedServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/restartServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/restartServer';
 import fs from 'node:fs'
 import path from 'node:path'
 import sirv from 'sirv'
@@ -6,11 +18,6 @@ import connect from 'connect'
 import type { Connect } from 'dep-types/connect'
 import corsMiddleware from 'cors'
 import { DEFAULT_PREVIEW_PORT } from './constants'
-import type {
-  HttpServer,
-  ResolvedServerOptions,
-  ResolvedServerUrls,
-} from './server'
 import { createServerCloseFn } from './server'
 import type { CommonServerOptions } from './http'
 import {
@@ -35,8 +42,6 @@ import {
 import { printServerUrls } from './logger'
 import { bindCLIShortcuts } from './shortcuts'
 import type { BindCLIShortcutsOptions } from './shortcuts'
-import { resolveConfig } from './config'
-import type { InlineConfig, ResolvedConfig } from './config'
 
 export interface PreviewOptions extends CommonServerOptions {}
 
diff --git a/packages/vite/src/node/publicDir.ts b/packages/vite/src/node/publicDir.ts
index a72afd414..07badc628 100644
--- a/packages/vite/src/node/publicDir.ts
+++ b/packages/vite/src/node/publicDir.ts
@@ -1,7 +1,7 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import fs from 'node:fs'
 import path from 'node:path'
 import { cleanUrl, withTrailingSlash } from '../shared/utils'
-import type { ResolvedConfig } from './config'
 import {
   ERR_SYMLINK_IN_RECURSIVE_READDIR,
   normalizePath,
diff --git a/packages/vite/src/node/server/__tests__/pluginContainer.spec.ts b/packages/vite/src/node/server/__tests__/pluginContainer.spec.ts
index 070dedd2a..e0642dca6 100644
--- a/packages/vite/src/node/server/__tests__/pluginContainer.spec.ts
+++ b/packages/vite/src/node/server/__tests__/pluginContainer.spec.ts
@@ -1,6 +1,8 @@
+import { UserConfig } from 'packages/vite/src/node/config/UserConfig';
+import { UserConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { UserConfig } from 'packages/vite/src/node/config/loadConfigFromFile';
 import { beforeEach, describe, expect, it } from 'vitest'
-import type { UserConfig } from '../../config'
-import { resolveConfig } from '../../config'
 import type { Plugin } from '../../plugin'
 import { ModuleGraph } from '../moduleGraph'
 import type { PluginContainer } from '../pluginContainer'
diff --git a/packages/vite/src/node/server/__tests__/watcher.spec.ts b/packages/vite/src/node/server/__tests__/watcher.spec.ts
index 3c4a009f6..13ccd814e 100644
--- a/packages/vite/src/node/server/__tests__/watcher.spec.ts
+++ b/packages/vite/src/node/server/__tests__/watcher.spec.ts
@@ -1,7 +1,9 @@
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import { resolve } from 'node:path'
 import { fileURLToPath } from 'node:url'
 import { afterEach, describe, expect, it, vi } from 'vitest'
-import { type ViteDevServer, createServer } from '../index'
 
 const stubGetWatchedCode = /getWatched\(\) \{.+?return \{\};.+?\}/s
 
diff --git a/packages/vite/src/node/server/hmr.ts b/packages/vite/src/node/server/hmr.ts
index 0c659a1d5..2538388a9 100644
--- a/packages/vite/src/node/server/hmr.ts
+++ b/packages/vite/src/node/server/hmr.ts
@@ -1,3 +1,32 @@
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { normalizedClientDir } from 'packages/vite/src/node/server/hmr/handleHMRUpdate';
+import { HmrContext } from 'packages/vite/src/node/server/hmr/handleHMRUpdate';
+import { getShortName } from 'packages/vite/src/node/server/hmr/handleHMRUpdate';
+import { handleHMRUpdate } from 'packages/vite/src/node/server/hmr';
+import { PropagationBoundary } from 'packages/vite/src/node/server/hmr/updateModules';
+import { HasDeadEnd } from 'packages/vite/src/node/server/hmr/updateModules';
+import { updateModules } from 'packages/vite/src/node/server/hmr/updateModules';
+import { updateModules } from 'packages/vite/src/node/server/hmr';
+import { PropagationBoundary } from 'packages/vite/src/node/server/hmr/propagateUpdate';
+import { HasDeadEnd } from 'packages/vite/src/node/server/hmr/propagateUpdate';
+import { areAllImportsAccepted } from 'packages/vite/src/node/server/hmr/propagateUpdate';
+import { propagateUpdate } from 'packages/vite/src/node/server/hmr/propagateUpdate';
+import { propagateUpdate } from 'packages/vite/src/node/server/hmr';
+import { debugHmr } from 'packages/vite/src/node/server/hmr/isNodeWithinCircularImports';
+import { isNodeWithinCircularImports } from 'packages/vite/src/node/server/hmr/isNodeWithinCircularImports';
+import { isNodeWithinCircularImports } from 'packages/vite/src/node/server/hmr';
+import { whitespaceRE } from 'packages/vite/src/node/server/hmr/lexAcceptedHmrDeps';
+import { LexerState } from 'packages/vite/src/node/server/hmr/lexAcceptedHmrDeps';
+import { lexAcceptedHmrDeps } from 'packages/vite/src/node/server/hmr/lexAcceptedHmrDeps';
+import { lexAcceptedHmrDeps } from 'packages/vite/src/node/server/hmr';
+import { isExplicitImportRequired } from 'packages/vite/src/node/plugins/importAnalysis/importAnalysisPlugin';
+import { HttpServer } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/_createServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/restartServer';
 import fsp from 'node:fs/promises'
 import path from 'node:path'
 import { EventEmitter } from 'node:events'
@@ -7,21 +36,12 @@ import type { RollupError } from 'rollup'
 import { CLIENT_DIR } from '../constants'
 import { createDebugger, normalizePath } from '../utils'
 import type { InferCustomEventPayload, ViteDevServer } from '..'
-import { isCSSRequest } from '../plugins/css'
 import { getAffectedGlobModules } from '../plugins/importMetaGlob'
-import { isExplicitImportRequired } from '../plugins/importAnalysis'
 import { getEnvFilesForMode } from '../env'
 import { withTrailingSlash, wrapId } from '../../shared/utils'
 import type { ModuleNode } from './moduleGraph'
-import type { HttpServer } from '.'
 import { restartServerWithUrls } from '.'
 
-export const debugHmr = createDebugger('vite:hmr')
-
-const whitespaceRE = /\s/
-
-const normalizedClientDir = normalizePath(CLIENT_DIR)
-
 export interface HmrOptions {
   protocol?: string
   host?: string
@@ -35,20 +55,6 @@ export interface HmrOptions {
   channels?: HMRChannel[]
 }
 
-export interface HmrContext {
-  file: string
-  timestamp: number
-  modules: Array<ModuleNode>
-  read: () => string | Promise<string>
-  server: ViteDevServer
-}
-
-interface PropagationBoundary {
-  boundary: ModuleNode
-  acceptedVia: ModuleNode
-  isWithinCircularImport: boolean
-}
-
 export interface HMRBroadcasterClient {
   /**
    * Send event to the client
@@ -111,195 +117,6 @@ export interface HMRBroadcaster extends Omit<HMRChannel, 'close' | 'name'> {
   close(): Promise<unknown[]>
 }
 
-export function getShortName(file: string, root: string): string {
-  return file.startsWith(withTrailingSlash(root))
-    ? path.posix.relative(root, file)
-    : file
-}
-
-export async function handleHMRUpdate(
-  type: 'create' | 'delete' | 'update',
-  file: string,
-  server: ViteDevServer,
-): Promise<void> {
-  const { hot, config, moduleGraph } = server
-  const shortFile = getShortName(file, config.root)
-
-  const isConfig = file === config.configFile
-  const isConfigDependency = config.configFileDependencies.some(
-    (name) => file === name,
-  )
-
-  const isEnv =
-    config.inlineConfig.envFile !== false &&
-    getEnvFilesForMode(config.mode, config.envDir).includes(file)
-  if (isConfig || isConfigDependency || isEnv) {
-    // auto restart server
-    debugHmr?.(`[config change] ${colors.dim(shortFile)}`)
-    config.logger.info(
-      colors.green(
-        `${normalizePath(
-          path.relative(process.cwd(), file),
-        )} changed, restarting server...`,
-      ),
-      { clear: true, timestamp: true },
-    )
-    try {
-      await restartServerWithUrls(server)
-    } catch (e) {
-      config.logger.error(colors.red(e))
-    }
-    return
-  }
-
-  debugHmr?.(`[file change] ${colors.dim(shortFile)}`)
-
-  // (dev only) the client itself cannot be hot updated.
-  if (file.startsWith(withTrailingSlash(normalizedClientDir))) {
-    hot.send({
-      type: 'full-reload',
-      path: '*',
-      triggeredBy: path.resolve(config.root, file),
-    })
-    return
-  }
-
-  const mods = new Set(moduleGraph.getModulesByFile(file))
-  if (type === 'create') {
-    for (const mod of moduleGraph._hasResolveFailedErrorModules) {
-      mods.add(mod)
-    }
-  }
-  if (type === 'create' || type === 'delete') {
-    for (const mod of getAffectedGlobModules(file, server)) {
-      mods.add(mod)
-    }
-  }
-
-  // check if any plugin wants to perform custom HMR handling
-  const timestamp = Date.now()
-  const hmrContext: HmrContext = {
-    file,
-    timestamp,
-    modules: [...mods],
-    read: () => readModifiedFile(file),
-    server,
-  }
-
-  if (type === 'update') {
-    for (const hook of config.getSortedPluginHooks('handleHotUpdate')) {
-      const filteredModules = await hook(hmrContext)
-      if (filteredModules) {
-        hmrContext.modules = filteredModules
-      }
-    }
-  }
-
-  if (!hmrContext.modules.length) {
-    // html file cannot be hot updated
-    if (file.endsWith('.html')) {
-      config.logger.info(colors.green(`page reload `) + colors.dim(shortFile), {
-        clear: true,
-        timestamp: true,
-      })
-      hot.send({
-        type: 'full-reload',
-        path: config.server.middlewareMode
-          ? '*'
-          : '/' + normalizePath(path.relative(config.root, file)),
-      })
-    } else {
-      // loaded but not in the module graph, probably not js
-      debugHmr?.(`[no modules matched] ${colors.dim(shortFile)}`)
-    }
-    return
-  }
-
-  updateModules(shortFile, hmrContext.modules, timestamp, server)
-}
-
-type HasDeadEnd = boolean
-
-export function updateModules(
-  file: string,
-  modules: ModuleNode[],
-  timestamp: number,
-  { config, hot, moduleGraph }: ViteDevServer,
-  afterInvalidation?: boolean,
-): void {
-  const updates: Update[] = []
-  const invalidatedModules = new Set<ModuleNode>()
-  const traversedModules = new Set<ModuleNode>()
-  // Modules could be empty if a root module is invalidated via import.meta.hot.invalidate()
-  let needFullReload: HasDeadEnd = modules.length === 0
-
-  for (const mod of modules) {
-    const boundaries: PropagationBoundary[] = []
-    const hasDeadEnd = propagateUpdate(mod, traversedModules, boundaries)
-
-    moduleGraph.invalidateModule(mod, invalidatedModules, timestamp, true)
-
-    if (needFullReload) {
-      continue
-    }
-
-    if (hasDeadEnd) {
-      needFullReload = hasDeadEnd
-      continue
-    }
-
-    updates.push(
-      ...boundaries.map(
-        ({ boundary, acceptedVia, isWithinCircularImport }) => ({
-          type: `${boundary.type}-update` as const,
-          timestamp,
-          path: normalizeHmrUrl(boundary.url),
-          acceptedPath: normalizeHmrUrl(acceptedVia.url),
-          explicitImportRequired:
-            boundary.type === 'js'
-              ? isExplicitImportRequired(acceptedVia.url)
-              : false,
-          isWithinCircularImport,
-          // browser modules are invalidated by changing ?t= query,
-          // but in ssr we control the module system, so we can directly remove them form cache
-          ssrInvalidates: getSSRInvalidatedImporters(acceptedVia),
-        }),
-      ),
-    )
-  }
-
-  if (needFullReload) {
-    const reason =
-      typeof needFullReload === 'string'
-        ? colors.dim(` (${needFullReload})`)
-        : ''
-    config.logger.info(
-      colors.green(`page reload `) + colors.dim(file) + reason,
-      { clear: !afterInvalidation, timestamp: true },
-    )
-    hot.send({
-      type: 'full-reload',
-      triggeredBy: path.resolve(config.root, file),
-    })
-    return
-  }
-
-  if (updates.length === 0) {
-    debugHmr?.(colors.yellow(`no update happened `) + colors.dim(file))
-    return
-  }
-
-  config.logger.info(
-    colors.green(`hmr update `) +
-      colors.dim([...new Set(updates.map((u) => u.path))].join(', ')),
-    { clear: !afterInvalidation, timestamp: true },
-  )
-  hot.send({
-    type: 'update',
-    updates,
-  })
-}
-
 function populateSSRImporters(
   module: ModuleNode,
   timestamp: number,
@@ -326,206 +143,6 @@ function getSSRInvalidatedImporters(module: ModuleNode) {
   )
 }
 
-function areAllImportsAccepted(
-  importedBindings: Set<string>,
-  acceptedExports: Set<string>,
-) {
-  for (const binding of importedBindings) {
-    if (!acceptedExports.has(binding)) {
-      return false
-    }
-  }
-  return true
-}
-
-function propagateUpdate(
-  node: ModuleNode,
-  traversedModules: Set<ModuleNode>,
-  boundaries: PropagationBoundary[],
-  currentChain: ModuleNode[] = [node],
-): HasDeadEnd {
-  if (traversedModules.has(node)) {
-    return false
-  }
-  traversedModules.add(node)
-
-  // #7561
-  // if the imports of `node` have not been analyzed, then `node` has not
-  // been loaded in the browser and we should stop propagation.
-  if (node.id && node.isSelfAccepting === undefined) {
-    debugHmr?.(
-      `[propagate update] stop propagation because not analyzed: ${colors.dim(
-        node.id,
-      )}`,
-    )
-    return false
-  }
-
-  if (node.isSelfAccepting) {
-    boundaries.push({
-      boundary: node,
-      acceptedVia: node,
-      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain),
-    })
-
-    // additionally check for CSS importers, since a PostCSS plugin like
-    // Tailwind JIT may register any file as a dependency to a CSS file.
-    for (const importer of node.importers) {
-      if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
-        propagateUpdate(
-          importer,
-          traversedModules,
-          boundaries,
-          currentChain.concat(importer),
-        )
-      }
-    }
-
-    return false
-  }
-
-  // A partially accepted module with no importers is considered self accepting,
-  // because the deal is "there are parts of myself I can't self accept if they
-  // are used outside of me".
-  // Also, the imported module (this one) must be updated before the importers,
-  // so that they do get the fresh imported module when/if they are reloaded.
-  if (node.acceptedHmrExports) {
-    boundaries.push({
-      boundary: node,
-      acceptedVia: node,
-      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain),
-    })
-  } else {
-    if (!node.importers.size) {
-      return true
-    }
-
-    // #3716, #3913
-    // For a non-CSS file, if all of its importers are CSS files (registered via
-    // PostCSS plugins) it should be considered a dead end and force full reload.
-    if (
-      !isCSSRequest(node.url) &&
-      [...node.importers].every((i) => isCSSRequest(i.url))
-    ) {
-      return true
-    }
-  }
-
-  for (const importer of node.importers) {
-    const subChain = currentChain.concat(importer)
-
-    if (importer.acceptedHmrDeps.has(node)) {
-      boundaries.push({
-        boundary: importer,
-        acceptedVia: node,
-        isWithinCircularImport: isNodeWithinCircularImports(importer, subChain),
-      })
-      continue
-    }
-
-    if (node.id && node.acceptedHmrExports && importer.importedBindings) {
-      const importedBindingsFromNode = importer.importedBindings.get(node.id)
-      if (
-        importedBindingsFromNode &&
-        areAllImportsAccepted(importedBindingsFromNode, node.acceptedHmrExports)
-      ) {
-        continue
-      }
-    }
-
-    if (
-      !currentChain.includes(importer) &&
-      propagateUpdate(importer, traversedModules, boundaries, subChain)
-    ) {
-      return true
-    }
-  }
-  return false
-}
-
-/**
- * Check importers recursively if it's an import loop. An accepted module within
- * an import loop cannot recover its execution order and should be reloaded.
- *
- * @param node The node that accepts HMR and is a boundary
- * @param nodeChain The chain of nodes/imports that lead to the node.
- *   (The last node in the chain imports the `node` parameter)
- * @param currentChain The current chain tracked from the `node` parameter
- * @param traversedModules The set of modules that have traversed
- */
-function isNodeWithinCircularImports(
-  node: ModuleNode,
-  nodeChain: ModuleNode[],
-  currentChain: ModuleNode[] = [node],
-  traversedModules = new Set<ModuleNode>(),
-): boolean {
-  // To help visualize how each parameters work, imagine this import graph:
-  //
-  // A -> B -> C -> ACCEPTED -> D -> E -> NODE
-  //      ^--------------------------|
-  //
-  // ACCEPTED: the node that accepts HMR. the `node` parameter.
-  // NODE    : the initial node that triggered this HMR.
-  //
-  // This function will return true in the above graph, which:
-  // `node`         : ACCEPTED
-  // `nodeChain`    : [NODE, E, D, ACCEPTED]
-  // `currentChain` : [ACCEPTED, C, B]
-  //
-  // It works by checking if any `node` importers are within `nodeChain`, which
-  // means there's an import loop with a HMR-accepted module in it.
-
-  if (traversedModules.has(node)) {
-    return false
-  }
-  traversedModules.add(node)
-
-  for (const importer of node.importers) {
-    // Node may import itself which is safe
-    if (importer === node) continue
-
-    // a PostCSS plugin like Tailwind JIT may register
-    // any file as a dependency to a CSS file.
-    // But in that case, the actual dependency chain is separate.
-    if (isCSSRequest(importer.url)) continue
-
-    // Check circular imports
-    const importerIndex = nodeChain.indexOf(importer)
-    if (importerIndex > -1) {
-      // Log extra debug information so users can fix and remove the circular imports
-      if (debugHmr) {
-        // Following explanation above:
-        // `importer`                    : E
-        // `currentChain` reversed       : [B, C, ACCEPTED]
-        // `nodeChain` sliced & reversed : [D, E]
-        // Combined                      : [E, B, C, ACCEPTED, D, E]
-        const importChain = [
-          importer,
-          ...[...currentChain].reverse(),
-          ...nodeChain.slice(importerIndex, -1).reverse(),
-        ]
-        debugHmr(
-          colors.yellow(`circular imports detected: `) +
-            importChain.map((m) => colors.dim(m.url)).join(' -> '),
-        )
-      }
-      return true
-    }
-
-    // Continue recursively
-    if (!currentChain.includes(importer)) {
-      const result = isNodeWithinCircularImports(
-        importer,
-        nodeChain,
-        currentChain.concat(importer),
-        traversedModules,
-      )
-      if (result) return result
-    }
-  }
-  return false
-}
-
 export function handlePrunedModules(
   mods: Set<ModuleNode>,
   { hot }: ViteDevServer,
@@ -545,125 +162,6 @@ export function handlePrunedModules(
   })
 }
 
-const enum LexerState {
-  inCall,
-  inSingleQuoteString,
-  inDoubleQuoteString,
-  inTemplateString,
-  inArray,
-}
-
-/**
- * Lex import.meta.hot.accept() for accepted deps.
- * Since hot.accept() can only accept string literals or array of string
- * literals, we don't really need a heavy @babel/parse call on the entire source.
- *
- * @returns selfAccepts
- */
-export function lexAcceptedHmrDeps(
-  code: string,
-  start: number,
-  urls: Set<{ url: string; start: number; end: number }>,
-): boolean {
-  let state: LexerState = LexerState.inCall
-  // the state can only be 2 levels deep so no need for a stack
-  let prevState: LexerState = LexerState.inCall
-  let currentDep: string = ''
-
-  function addDep(index: number) {
-    urls.add({
-      url: currentDep,
-      start: index - currentDep.length - 1,
-      end: index + 1,
-    })
-    currentDep = ''
-  }
-
-  for (let i = start; i < code.length; i++) {
-    const char = code.charAt(i)
-    switch (state) {
-      case LexerState.inCall:
-      case LexerState.inArray:
-        if (char === `'`) {
-          prevState = state
-          state = LexerState.inSingleQuoteString
-        } else if (char === `"`) {
-          prevState = state
-          state = LexerState.inDoubleQuoteString
-        } else if (char === '`') {
-          prevState = state
-          state = LexerState.inTemplateString
-        } else if (whitespaceRE.test(char)) {
-          continue
-        } else {
-          if (state === LexerState.inCall) {
-            if (char === `[`) {
-              state = LexerState.inArray
-            } else {
-              // reaching here means the first arg is neither a string literal
-              // nor an Array literal (direct callback) or there is no arg
-              // in both case this indicates a self-accepting module
-              return true // done
-            }
-          } else if (state === LexerState.inArray) {
-            if (char === `]`) {
-              return false // done
-            } else if (char === ',') {
-              continue
-            } else {
-              error(i)
-            }
-          }
-        }
-        break
-      case LexerState.inSingleQuoteString:
-        if (char === `'`) {
-          addDep(i)
-          if (prevState === LexerState.inCall) {
-            // accept('foo', ...)
-            return false
-          } else {
-            state = prevState
-          }
-        } else {
-          currentDep += char
-        }
-        break
-      case LexerState.inDoubleQuoteString:
-        if (char === `"`) {
-          addDep(i)
-          if (prevState === LexerState.inCall) {
-            // accept('foo', ...)
-            return false
-          } else {
-            state = prevState
-          }
-        } else {
-          currentDep += char
-        }
-        break
-      case LexerState.inTemplateString:
-        if (char === '`') {
-          addDep(i)
-          if (prevState === LexerState.inCall) {
-            // accept('foo', ...)
-            return false
-          } else {
-            state = prevState
-          }
-        } else if (char === '$' && code.charAt(i + 1) === '{') {
-          error(i)
-        } else {
-          currentDep += char
-        }
-        break
-      default:
-        throw new Error('unknown import.meta.hot lexer state')
-    }
-  }
-  return false
-}
-
 export function lexAcceptedHmrExports(
   code: string,
   start: number,
diff --git a/packages/vite/src/node/server/hmr/handleHMRUpdate.ts b/packages/vite/src/node/server/hmr/handleHMRUpdate.ts
new file mode 100644
index 000000000..5ef583497
--- /dev/null
+++ b/packages/vite/src/node/server/hmr/handleHMRUpdate.ts
@@ -0,0 +1,128 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { getAffectedGlobModules } from 'packages/vite/src/node/plugins/importMetaGlob';
+import { getEnvFilesForMode } from 'packages/vite/src/node/env';
+import { withTrailingSlash } from 'packages/vite/src/shared/utils';
+import { restartServerWithUrls } from 'packages/vite/src/node/server/index';
+import { CLIENT_DIR } from 'packages/vite/src/node/constants';
+import { ModuleNode } from 'packages/vite/src/node/server/moduleGraph';
+
+
+const export normalizedClientDir = normalizePath(CLIENT_DIR)
+
+export interface HmrContext {
+  file: string
+  timestamp: number
+  modules: Array<ModuleNode>
+  read: () => string | Promise<string>
+  server: ViteDevServer
+}
+
+export function getShortName(file: string, root: string): string {
+  return file.startsWith(withTrailingSlash(root))
+    ? path.posix.relative(root, file)
+    : file
+}
+
+export async function handleHMRUpdate(
+  type: 'create' | 'delete' | 'update',
+  file: string,
+  server: ViteDevServer,
+): Promise<void> {
+  const { hot, config, moduleGraph } = server
+  const shortFile = getShortName(file, config.root)
+
+  const isConfig = file === config.configFile
+  const isConfigDependency = config.configFileDependencies.some(
+    (name) => file === name,
+  )
+
+  const isEnv =
+    config.inlineConfig.envFile !== false &&
+    getEnvFilesForMode(config.mode, config.envDir).includes(file)
+  if (isConfig || isConfigDependency || isEnv) {
+    // auto restart server
+    debugHmr?.(`[config change] ${colors.dim(shortFile)}`)
+    config.logger.info(
+      colors.green(
+        `${normalizePath(
+          path.relative(process.cwd(), file),
+        )} changed, restarting server...`,
+      ),
+      { clear: true, timestamp: true },
+    )
+    try {
+      await restartServerWithUrls(server)
+    } catch (e) {
+      config.logger.error(colors.red(e))
+    }
+    return
+  }
+
+  debugHmr?.(`[file change] ${colors.dim(shortFile)}`)
+
+  // (dev only) the client itself cannot be hot updated.
+  if (file.startsWith(withTrailingSlash(normalizedClientDir))) {
+    hot.send({
+      type: 'full-reload',
+      path: '*',
+      triggeredBy: path.resolve(config.root, file),
+    })
+    return
+  }
+
+  const mods = new Set(moduleGraph.getModulesByFile(file))
+  if (type === 'create') {
+    for (const mod of moduleGraph._hasResolveFailedErrorModules) {
+      mods.add(mod)
+    }
+  }
+  if (type === 'create' || type === 'delete') {
+    for (const mod of getAffectedGlobModules(file, server)) {
+      mods.add(mod)
+    }
+  }
+
+  // check if any plugin wants to perform custom HMR handling
+  const timestamp = Date.now()
+  const hmrContext: HmrContext = {
+    file,
+    timestamp,
+    modules: [...mods],
+    read: () => readModifiedFile(file),
+    server,
+  }
+
+  if (type === 'update') {
+    for (const hook of config.getSortedPluginHooks('handleHotUpdate')) {
+      const filteredModules = await hook(hmrContext)
+      if (filteredModules) {
+        hmrContext.modules = filteredModules
+      }
+    }
+  }
+
+  if (!hmrContext.modules.length) {
+    // html file cannot be hot updated
+    if (file.endsWith('.html')) {
+      config.logger.info(colors.green(`page reload `) + colors.dim(shortFile), {
+        clear: true,
+        timestamp: true,
+      })
+      hot.send({
+        type: 'full-reload',
+        path: config.server.middlewareMode
+          ? '*'
+          : '/' + normalizePath(path.relative(config.root, file)),
+      })
+    } else {
+      // loaded but not in the module graph, probably not js
+      debugHmr?.(`[no modules matched] ${colors.dim(shortFile)}`)
+    }
+    return
+  }
+
+  updateModules(shortFile, hmrContext.modules, timestamp, server)
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/hmr/isNodeWithinCircularImports.ts b/packages/vite/src/node/server/hmr/isNodeWithinCircularImports.ts
new file mode 100644
index 000000000..3b1f558bd
--- /dev/null
+++ b/packages/vite/src/node/server/hmr/isNodeWithinCircularImports.ts
@@ -0,0 +1,90 @@
+import colors from 'picocolors'
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css';
+import { ModuleNode } from 'packages/vite/src/node/server/moduleGraph';
+import { createDebugger } from 'packages/vite/src/node/utils';
+
+
+export const debugHmr = createDebugger('vite:hmr')
+
+/**
+ * Check importers recursively if it's an import loop. An accepted module within
+ * an import loop cannot recover its execution order and should be reloaded.
+ *
+ * @param node The node that accepts HMR and is a boundary
+ * @param nodeChain The chain of nodes/imports that lead to the node.
+ *   (The last node in the chain imports the `node` parameter)
+ * @param currentChain The current chain tracked from the `node` parameter
+ * @param traversedModules The set of modules that have traversed
+ */
+export function isNodeWithinCircularImports(
+  node: ModuleNode,
+  nodeChain: ModuleNode[],
+  currentChain: ModuleNode[] = [node],
+  traversedModules = new Set<ModuleNode>(),
+): boolean {
+  // To help visualize how each parameters work, imagine this import graph:
+  //
+  // A -> B -> C -> ACCEPTED -> D -> E -> NODE
+  //      ^--------------------------|
+  //
+  // ACCEPTED: the node that accepts HMR. the `node` parameter.
+  // NODE    : the initial node that triggered this HMR.
+  //
+  // This function will return true in the above graph, which:
+  // `node`         : ACCEPTED
+  // `nodeChain`    : [NODE, E, D, ACCEPTED]
+  // `currentChain` : [ACCEPTED, C, B]
+  //
+  // It works by checking if any `node` importers are within `nodeChain`, which
+  // means there's an import loop with a HMR-accepted module in it.
+
+  if (traversedModules.has(node)) {
+    return false
+  }
+  traversedModules.add(node)
+
+  for (const importer of node.importers) {
+    // Node may import itself which is safe
+    if (importer === node) continue
+
+    // a PostCSS plugin like Tailwind JIT may register
+    // any file as a dependency to a CSS file.
+    // But in that case, the actual dependency chain is separate.
+    if (isCSSRequest(importer.url)) continue
+
+    // Check circular imports
+    const importerIndex = nodeChain.indexOf(importer)
+    if (importerIndex > -1) {
+      // Log extra debug information so users can fix and remove the circular imports
+      if (debugHmr) {
+        // Following explanation above:
+        // `importer`                    : E
+        // `currentChain` reversed       : [B, C, ACCEPTED]
+        // `nodeChain` sliced & reversed : [D, E]
+        // Combined                      : [E, B, C, ACCEPTED, D, E]
+        const importChain = [
+          importer,
+          ...[...currentChain].reverse(),
+          ...nodeChain.slice(importerIndex, -1).reverse(),
+        ]
+        debugHmr(
+          colors.yellow(`circular imports detected: `) +
+            importChain.map((m) => colors.dim(m.url)).join(' -> '),
+        )
+      }
+      return true
+    }
+
+    // Continue recursively
+    if (!currentChain.includes(importer)) {
+      const result = isNodeWithinCircularImports(
+        importer,
+        nodeChain,
+        currentChain.concat(importer),
+        traversedModules,
+      )
+      if (result) return result
+    }
+  }
+  return false
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/hmr/lexAcceptedHmrDeps.ts b/packages/vite/src/node/server/hmr/lexAcceptedHmrDeps.ts
new file mode 100644
index 000000000..8016e4d47
--- /dev/null
+++ b/packages/vite/src/node/server/hmr/lexAcceptedHmrDeps.ts
@@ -0,0 +1,122 @@
+
+
+const export whitespaceRE = /\s/
+
+export const enum LexerState {
+  inCall,
+  inSingleQuoteString,
+  inDoubleQuoteString,
+  inTemplateString,
+  inArray,
+}
+
+/**
+ * Lex import.meta.hot.accept() for accepted deps.
+ * Since hot.accept() can only accept string literals or array of string
+ * literals, we don't really need a heavy @babel/parse call on the entire source.
+ *
+ * @returns selfAccepts
+ */
+export function lexAcceptedHmrDeps(
+  code: string,
+  start: number,
+  urls: Set<{ url: string; start: number; end: number }>,
+): boolean {
+  let state: LexerState = LexerState.inCall
+  // the state can only be 2 levels deep so no need for a stack
+  let prevState: LexerState = LexerState.inCall
+  let currentDep: string = ''
+
+  function addDep(index: number) {
+    urls.add({
+      url: currentDep,
+      start: index - currentDep.length - 1,
+      end: index + 1,
+    })
+    currentDep = ''
+  }
+
+  for (let i = start; i < code.length; i++) {
+    const char = code.charAt(i)
+    switch (state) {
+      case LexerState.inCall:
+      case LexerState.inArray:
+        if (char === `'`) {
+          prevState = state
+          state = LexerState.inSingleQuoteString
+        } else if (char === `"`) {
+          prevState = state
+          state = LexerState.inDoubleQuoteString
+        } else if (char === '`') {
+          prevState = state
+          state = LexerState.inTemplateString
+        } else if (whitespaceRE.test(char)) {
+          continue
+        } else {
+          if (state === LexerState.inCall) {
+            if (char === `[`) {
+              state = LexerState.inArray
+            } else {
+              // reaching here means the first arg is neither a string literal
+              // nor an Array literal (direct callback) or there is no arg
+              // in both case this indicates a self-accepting module
+              return true // done
+            }
+          } else if (state === LexerState.inArray) {
+            if (char === `]`) {
+              return false // done
+            } else if (char === ',') {
+              continue
+            } else {
+              error(i)
+            }
+          }
+        }
+        break
+      case LexerState.inSingleQuoteString:
+        if (char === `'`) {
+          addDep(i)
+          if (prevState === LexerState.inCall) {
+            // accept('foo', ...)
+            return false
+          } else {
+            state = prevState
+          }
+        } else {
+          currentDep += char
+        }
+        break
+      case LexerState.inDoubleQuoteString:
+        if (char === `"`) {
+          addDep(i)
+          if (prevState === LexerState.inCall) {
+            // accept('foo', ...)
+            return false
+          } else {
+            state = prevState
+          }
+        } else {
+          currentDep += char
+        }
+        break
+      case LexerState.inTemplateString:
+        if (char === '`') {
+          addDep(i)
+          if (prevState === LexerState.inCall) {
+            // accept('foo', ...)
+            return false
+          } else {
+            state = prevState
+          }
+        } else if (char === '$' && code.charAt(i + 1) === '{') {
+          error(i)
+        } else {
+          currentDep += char
+        }
+        break
+      default:
+        throw new Error('unknown import.meta.hot lexer state')
+    }
+  }
+  return false
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/hmr/propagateUpdate.ts b/packages/vite/src/node/server/hmr/propagateUpdate.ts
new file mode 100644
index 000000000..ee257453d
--- /dev/null
+++ b/packages/vite/src/node/server/hmr/propagateUpdate.ts
@@ -0,0 +1,129 @@
+import colors from 'picocolors'
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css';
+import { ModuleNode } from 'packages/vite/src/node/server/moduleGraph';
+
+
+export interface PropagationBoundary {
+  boundary: ModuleNode
+  acceptedVia: ModuleNode
+  isWithinCircularImport: boolean
+}
+
+export type HasDeadEnd = boolean
+
+export function areAllImportsAccepted(
+  importedBindings: Set<string>,
+  acceptedExports: Set<string>,
+) {
+  for (const binding of importedBindings) {
+    if (!acceptedExports.has(binding)) {
+      return false
+    }
+  }
+  return true
+}
+
+export function propagateUpdate(
+  node: ModuleNode,
+  traversedModules: Set<ModuleNode>,
+  boundaries: PropagationBoundary[],
+  currentChain: ModuleNode[] = [node],
+): HasDeadEnd {
+  if (traversedModules.has(node)) {
+    return false
+  }
+  traversedModules.add(node)
+
+  // #7561
+  // if the imports of `node` have not been analyzed, then `node` has not
+  // been loaded in the browser and we should stop propagation.
+  if (node.id && node.isSelfAccepting === undefined) {
+    debugHmr?.(
+      `[propagate update] stop propagation because not analyzed: ${colors.dim(
+        node.id,
+      )}`,
+    )
+    return false
+  }
+
+  if (node.isSelfAccepting) {
+    boundaries.push({
+      boundary: node,
+      acceptedVia: node,
+      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain),
+    })
+
+    // additionally check for CSS importers, since a PostCSS plugin like
+    // Tailwind JIT may register any file as a dependency to a CSS file.
+    for (const importer of node.importers) {
+      if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
+        propagateUpdate(
+          importer,
+          traversedModules,
+          boundaries,
+          currentChain.concat(importer),
+        )
+      }
+    }
+
+    return false
+  }
+
+  // A partially accepted module with no importers is considered self accepting,
+  // because the deal is "there are parts of myself I can't self accept if they
+  // are used outside of me".
+  // Also, the imported module (this one) must be updated before the importers,
+  // so that they do get the fresh imported module when/if they are reloaded.
+  if (node.acceptedHmrExports) {
+    boundaries.push({
+      boundary: node,
+      acceptedVia: node,
+      isWithinCircularImport: isNodeWithinCircularImports(node, currentChain),
+    })
+  } else {
+    if (!node.importers.size) {
+      return true
+    }
+
+    // #3716, #3913
+    // For a non-CSS file, if all of its importers are CSS files (registered via
+    // PostCSS plugins) it should be considered a dead end and force full reload.
+    if (
+      !isCSSRequest(node.url) &&
+      [...node.importers].every((i) => isCSSRequest(i.url))
+    ) {
+      return true
+    }
+  }
+
+  for (const importer of node.importers) {
+    const subChain = currentChain.concat(importer)
+
+    if (importer.acceptedHmrDeps.has(node)) {
+      boundaries.push({
+        boundary: importer,
+        acceptedVia: node,
+        isWithinCircularImport: isNodeWithinCircularImports(importer, subChain),
+      })
+      continue
+    }
+
+    if (node.id && node.acceptedHmrExports && importer.importedBindings) {
+      const importedBindingsFromNode = importer.importedBindings.get(node.id)
+      if (
+        importedBindingsFromNode &&
+        areAllImportsAccepted(importedBindingsFromNode, node.acceptedHmrExports)
+      ) {
+        continue
+      }
+    }
+
+    if (
+      !currentChain.includes(importer) &&
+      propagateUpdate(importer, traversedModules, boundaries, subChain)
+    ) {
+      return true
+    }
+  }
+  return false
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/hmr/updateModules.ts b/packages/vite/src/node/server/hmr/updateModules.ts
new file mode 100644
index 000000000..892173496
--- /dev/null
+++ b/packages/vite/src/node/server/hmr/updateModules.ts
@@ -0,0 +1,95 @@
+import path from 'node:path'
+import colors from 'picocolors'
+import type { CustomPayload, HMRPayload, Update } from 'types/hmrPayload'
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { isExplicitImportRequired } from 'packages/vite/src/node/plugins/importAnalysis';
+import { ModuleNode } from 'packages/vite/src/node/server/moduleGraph';
+
+
+export interface PropagationBoundary {
+  boundary: ModuleNode
+  acceptedVia: ModuleNode
+  isWithinCircularImport: boolean
+}
+
+export type HasDeadEnd = boolean
+
+export function updateModules(
+  file: string,
+  modules: ModuleNode[],
+  timestamp: number,
+  { config, hot, moduleGraph }: ViteDevServer,
+  afterInvalidation?: boolean,
+): void {
+  const updates: Update[] = []
+  const invalidatedModules = new Set<ModuleNode>()
+  const traversedModules = new Set<ModuleNode>()
+  // Modules could be empty if a root module is invalidated via import.meta.hot.invalidate()
+  let needFullReload: HasDeadEnd = modules.length === 0
+
+  for (const mod of modules) {
+    const boundaries: PropagationBoundary[] = []
+    const hasDeadEnd = propagateUpdate(mod, traversedModules, boundaries)
+
+    moduleGraph.invalidateModule(mod, invalidatedModules, timestamp, true)
+
+    if (needFullReload) {
+      continue
+    }
+
+    if (hasDeadEnd) {
+      needFullReload = hasDeadEnd
+      continue
+    }
+
+    updates.push(
+      ...boundaries.map(
+        ({ boundary, acceptedVia, isWithinCircularImport }) => ({
+          type: `${boundary.type}-update` as const,
+          timestamp,
+          path: normalizeHmrUrl(boundary.url),
+          acceptedPath: normalizeHmrUrl(acceptedVia.url),
+          explicitImportRequired:
+            boundary.type === 'js'
+              ? isExplicitImportRequired(acceptedVia.url)
+              : false,
+          isWithinCircularImport,
+          // browser modules are invalidated by changing ?t= query,
+          // but in ssr we control the module system, so we can directly remove them form cache
+          ssrInvalidates: getSSRInvalidatedImporters(acceptedVia),
+        }),
+      ),
+    )
+  }
+
+  if (needFullReload) {
+    const reason =
+      typeof needFullReload === 'string'
+        ? colors.dim(` (${needFullReload})`)
+        : ''
+    config.logger.info(
+      colors.green(`page reload `) + colors.dim(file) + reason,
+      { clear: !afterInvalidation, timestamp: true },
+    )
+    hot.send({
+      type: 'full-reload',
+      triggeredBy: path.resolve(config.root, file),
+    })
+    return
+  }
+
+  if (updates.length === 0) {
+    debugHmr?.(colors.yellow(`no update happened `) + colors.dim(file))
+    return
+  }
+
+  config.logger.info(
+    colors.green(`hmr update `) +
+      colors.dim([...new Set(updates.map((u) => u.path))].join(', ')),
+    { clear: !afterInvalidation, timestamp: true },
+  )
+  hot.send({
+    type: 'update',
+    updates,
+  })
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/index.ts b/packages/vite/src/node/server/index.ts
index b5e1d9c57..3286c5245 100644
--- a/packages/vite/src/node/server/index.ts
+++ b/packages/vite/src/node/server/index.ts
@@ -1,3 +1,41 @@
+import { InlineConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { getShortName } from 'packages/vite/src/node/server/hmr/handleHMRUpdate';
+import { handleHMRUpdate } from 'packages/vite/src/node/server/hmr/handleHMRUpdate';
+import { updateModules } from 'packages/vite/src/node/server/hmr/updateModules';
+import { FileSystemServeOptions } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ServerOptions';
+import { ServerOptions } from 'packages/vite/src/node/server/index/ServerOptions';
+import { ServerOptions } from 'packages/vite/src/node/server/index';
+import { HttpServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index';
+import { HttpServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { _createServer } from 'packages/vite/src/node/server/index/_createServer';
+import { _createServer } from 'packages/vite/src/node/server/index';
+import { FileSystemServeOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { ServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { ResolvedServerOptions } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { resolvedAllowDir } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { resolveServerOptions } from 'packages/vite/src/node/server/index';
+import { HttpServer } from 'packages/vite/src/node/server/index/restartServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
+import { _createServer } from 'packages/vite/src/node/server/index/restartServer';
+import { restartServer } from 'packages/vite/src/node/server/index';
+import { callCrawlEndIfIdleAfterMs } from 'packages/vite/src/node/server/index/setupOnCrawlEnd';
+import { CrawlEndFinder } from 'packages/vite/src/node/server/index/setupOnCrawlEnd';
+import { setupOnCrawlEnd } from 'packages/vite/src/node/server/index/setupOnCrawlEnd';
+import { setupOnCrawlEnd } from 'packages/vite/src/node/server/index';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { transformRequest } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/doTransform';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation';
 import path from 'node:path'
 import { execSync } from 'node:child_process'
 import type * as net from 'node:net'
@@ -23,8 +61,7 @@ import {
   resolveHttpsConfig,
   setClientErrorHandler,
 } from '../http'
-import type { InlineConfig, ResolvedConfig } from '../config'
-import { isDepsOptimizerEnabled, resolveConfig } from '../config'
+import { isDepsOptimizerEnabled } from '../config'
 import {
   diffDnsOrderChange,
   isInNodeModules,
@@ -88,886 +125,22 @@ import type { HMRBroadcaster, HmrOptions } from './hmr'
 import {
   createHMRBroadcaster,
   createServerHMRChannel,
-  getShortName,
-  handleHMRUpdate,
-  updateModules,
 } from './hmr'
 import { openBrowser as _openBrowser } from './openBrowser'
-import type { TransformOptions, TransformResult } from './transformRequest'
-import { transformRequest } from './transformRequest'
 import { searchForWorkspaceRoot } from './searchRoot'
 import { warmupFiles } from './warmup'
 
-export interface ServerOptions extends CommonServerOptions {
-  /**
-   * Configure HMR-specific options (port, host, path & protocol)
-   */
-  hmr?: HmrOptions | boolean
-  /**
-   * Do not start the websocket connection.
-   * @experimental
-   */
-  ws?: false
-  /**
-   * Warm-up files to transform and cache the results in advance. This improves the
-   * initial page load during server starts and prevents transform waterfalls.
-   */
-  warmup?: {
-    /**
-     * The files to be transformed and used on the client-side. Supports glob patterns.
-     */
-    clientFiles?: string[]
-    /**
-     * The files to be transformed and used in SSR. Supports glob patterns.
-     */
-    ssrFiles?: string[]
-  }
-  /**
-   * chokidar watch options or null to disable FS watching
-   * https://github.com/paulmillr/chokidar#api
-   */
-  watch?: WatchOptions | null
-  /**
-   * Create Vite dev server to be used as a middleware in an existing server
-   * @default false
-   */
-  middlewareMode?:
-    | boolean
-    | {
-        /**
-         * Parent server instance to attach to
-         *
-         * This is needed to proxy WebSocket connections to the parent server.
-         */
-        server: HttpServer
-      }
-  /**
-   * Options for files served via '/\@fs/'.
-   */
-  fs?: FileSystemServeOptions
-  /**
-   * Origin for the generated asset URLs.
-   *
-   * @example `http://127.0.0.1:8080`
-   */
-  origin?: string
-  /**
-   * Pre-transform known direct imports
-   * @default true
-   */
-  preTransformRequests?: boolean
-  /**
-   * Whether or not to ignore-list source files in the dev server sourcemap, used to populate
-   * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).
-   *
-   * By default, it excludes all paths containing `node_modules`. You can pass `false` to
-   * disable this behavior, or, for full control, a function that takes the source path and
-   * sourcemap path and returns whether to ignore the source path.
-   */
-  sourcemapIgnoreList?:
-    | false
-    | ((sourcePath: string, sourcemapPath: string) => boolean)
-}
-
-export interface ResolvedServerOptions
-  extends Omit<ServerOptions, 'fs' | 'middlewareMode' | 'sourcemapIgnoreList'> {
-  fs: Required<FileSystemServeOptions>
-  middlewareMode: NonNullable<ServerOptions['middlewareMode']>
-  sourcemapIgnoreList: Exclude<
-    ServerOptions['sourcemapIgnoreList'],
-    false | undefined
-  >
-}
-
-export interface FileSystemServeOptions {
-  /**
-   * Strictly restrict file accessing outside of allowing paths.
-   *
-   * Set to `false` to disable the warning
-   *
-   * @default true
-   */
-  strict?: boolean
-
-  /**
-   * Restrict accessing files outside the allowed directories.
-   *
-   * Accepts absolute path or a path relative to project root.
-   * Will try to search up for workspace root by default.
-   */
-  allow?: string[]
-
-  /**
-   * Restrict accessing files that matches the patterns.
-   *
-   * This will have higher priority than `allow`.
-   * picomatch patterns are supported.
-   *
-   * @default ['.env', '.env.*', '*.crt', '*.pem']
-   */
-  deny?: string[]
-
-  /**
-   * Enable caching of fs calls. It is enabled by default if no custom watch ignored patterns are provided.
-   *
-   * @experimental
-   * @default undefined
-   */
-  cachedChecks?: boolean
-}
-
 export type ServerHook = (
   this: void,
   server: ViteDevServer,
 ) => (() => void) | void | Promise<(() => void) | void>
 
-export type HttpServer = http.Server | Http2SecureServer
-
-export interface ViteDevServer {
-  /**
-   * The resolved vite config object
-   */
-  config: ResolvedConfig
-  /**
-   * A connect app instance.
-   * - Can be used to attach custom middlewares to the dev server.
-   * - Can also be used as the handler function of a custom http server
-   *   or as a middleware in any connect-style Node.js frameworks
-   *
-   * https://github.com/senchalabs/connect#use-middleware
-   */
-  middlewares: Connect.Server
-  /**
-   * native Node http server instance
-   * will be null in middleware mode
-   */
-  httpServer: HttpServer | null
-  /**
-   * chokidar watcher instance
-   * https://github.com/paulmillr/chokidar#api
-   */
-  watcher: FSWatcher
-  /**
-   * web socket server with `send(payload)` method
-   */
-  ws: WebSocketServer
-  /**
-   * HMR broadcaster that can be used to send custom HMR messages to the client
-   *
-   * Always sends a message to at least a WebSocket client. Any third party can
-   * add a channel to the broadcaster to process messages
-   * @deprecated will be replaced with the environment api in v6.
-   */
-  hot: HMRBroadcaster
-  /**
-   * Rollup plugin container that can run plugin hooks on a given file
-   */
-  pluginContainer: PluginContainer
-  /**
-   * Module graph that tracks the import relationships, url to file mapping
-   * and hmr state.
-   */
-  moduleGraph: ModuleGraph
-  /**
-   * The resolved urls Vite prints on the CLI. null in middleware mode or
-   * before `server.listen` is called.
-   */
-  resolvedUrls: ResolvedServerUrls | null
-  /**
-   * Programmatically resolve, load and transform a URL and get the result
-   * without going through the http request pipeline.
-   */
-  transformRequest(
-    url: string,
-    options?: TransformOptions,
-  ): Promise<TransformResult | null>
-  /**
-   * Same as `transformRequest` but only warm up the URLs so the next request
-   * will already be cached. The function will never throw as it handles and
-   * reports errors internally.
-   */
-  warmupRequest(url: string, options?: TransformOptions): Promise<void>
-  /**
-   * Apply vite built-in HTML transforms and any plugin HTML transforms.
-   */
-  transformIndexHtml(
-    url: string,
-    html: string,
-    originalUrl?: string,
-  ): Promise<string>
-  /**
-   * Transform module code into SSR format.
-   */
-  ssrTransform(
-    code: string,
-    inMap: SourceMap | { mappings: '' } | null,
-    url: string,
-    originalCode?: string,
-  ): Promise<TransformResult | null>
-  /**
-   * Load a given URL as an instantiated module for SSR.
-   */
-  ssrLoadModule(
-    url: string,
-    opts?: { fixStacktrace?: boolean },
-  ): Promise<Record<string, any>>
-  /**
-   * Fetch information about the module for Vite SSR runtime.
-   * @experimental
-   */
-  ssrFetchModule(id: string, importer?: string): Promise<FetchResult>
-  /**
-   * Returns a fixed version of the given stack
-   */
-  ssrRewriteStacktrace(stack: string): string
-  /**
-   * Mutates the given SSR error by rewriting the stacktrace
-   */
-  ssrFixStacktrace(e: Error): void
-  /**
-   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`
-   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.
-   */
-  reloadModule(module: ModuleNode): Promise<void>
-  /**
-   * Start the server.
-   */
-  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
-  /**
-   * Stop the server.
-   */
-  close(): Promise<void>
-  /**
-   * Print server urls
-   */
-  printUrls(): void
-  /**
-   * Bind CLI shortcuts
-   */
-  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
-  /**
-   * Restart the server.
-   *
-   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
-   */
-  restart(forceOptimize?: boolean): Promise<void>
-
-  /**
-   * Open browser
-   */
-  openBrowser(): void
-  /**
-   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports
-   * are processed. If called from a load or transform plugin hook, the id needs to be
-   * passed as a parameter to avoid deadlocks. Calling this function after the first
-   * static imports section of the module graph has been processed will resolve immediately.
-   * @experimental
-   */
-  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
-  /**
-   * @internal
-   */
-  _registerRequestProcessing: (id: string, done: () => Promise<unknown>) => void
-  /**
-   * @internal
-   */
-  _onCrawlEnd(cb: () => void): void
-  /**
-   * @internal
-   */
-  _setInternalServer(server: ViteDevServer): void
-  /**
-   * @internal
-   */
-  _importGlobMap: Map<string, { affirmed: string[]; negated: string[] }[]>
-  /**
-   * @internal
-   */
-  _restartPromise: Promise<void> | null
-  /**
-   * @internal
-   */
-  _forceOptimizeOnRestart: boolean
-  /**
-   * @internal
-   */
-  _pendingRequests: Map<
-    string,
-    {
-      request: Promise<TransformResult | null>
-      timestamp: number
-      abort: () => void
-    }
-  >
-  /**
-   * @internal
-   */
-  _fsDenyGlob: Matcher
-  /**
-   * @internal
-   */
-  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>
-  /**
-   * @internal
-   */
-  _currentServerPort?: number | undefined
-  /**
-   * @internal
-   */
-  _configServerPort?: number | undefined
-}
-
-export interface ResolvedServerUrls {
-  local: string[]
-  network: string[]
-}
-
 export function createServer(
   inlineConfig: InlineConfig = {},
 ): Promise<ViteDevServer> {
   return _createServer(inlineConfig, { hotListen: true })
 }
 
-export async function _createServer(
-  inlineConfig: InlineConfig = {},
-  options: { hotListen: boolean },
-): Promise<ViteDevServer> {
-  const config = await resolveConfig(inlineConfig, 'serve')
-
-  const initPublicFilesPromise = initPublicFiles(config)
-
-  const { root, server: serverConfig } = config
-  const httpsOptions = await resolveHttpsConfig(config.server.https)
-  const { middlewareMode } = serverConfig
-
-  const resolvedOutDirs = getResolvedOutDirs(
-    config.root,
-    config.build.outDir,
-    config.build.rollupOptions?.output,
-  )
-  const emptyOutDir = resolveEmptyOutDir(
-    config.build.emptyOutDir,
-    config.root,
-    resolvedOutDirs,
-  )
-  const resolvedWatchOptions = resolveChokidarOptions(
-    config,
-    {
-      disableGlobbing: true,
-      ...serverConfig.watch,
-    },
-    resolvedOutDirs,
-    emptyOutDir,
-  )
-
-  const middlewares = connect() as Connect.Server
-  const httpServer = middlewareMode
-    ? null
-    : await resolveHttpServer(serverConfig, middlewares, httpsOptions)
-
-  const ws = createWebSocketServer(httpServer, config, httpsOptions)
-  const hot = createHMRBroadcaster()
-    .addChannel(ws)
-    .addChannel(createServerHMRChannel())
-  if (typeof config.server.hmr === 'object' && config.server.hmr.channels) {
-    config.server.hmr.channels.forEach((channel) => hot.addChannel(channel))
-  }
-
-  const publicFiles = await initPublicFilesPromise
-  const { publicDir } = config
-
-  if (httpServer) {
-    setClientErrorHandler(httpServer, config.logger)
-  }
-
-  // eslint-disable-next-line eqeqeq
-  const watchEnabled = serverConfig.watch !== null
-  const watcher = watchEnabled
-    ? (chokidar.watch(
-        // config file dependencies and env file might be outside of root
-        [
-          root,
-          ...config.configFileDependencies,
-          ...getEnvFilesForMode(config.mode, config.envDir),
-          // Watch the public directory explicitly because it might be outside
-          // of the root directory.
-          ...(publicDir && publicFiles ? [publicDir] : []),
-        ],
-        resolvedWatchOptions,
-      ) as FSWatcher)
-    : createNoopWatcher(resolvedWatchOptions)
-
-  const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>
-    container.resolveId(url, undefined, { ssr }),
-  )
-
-  const container = await createPluginContainer(config, moduleGraph, watcher)
-  const closeHttpServer = createServerCloseFn(httpServer)
-
-  const devHtmlTransformFn = createDevHtmlTransformFn(config)
-
-  const onCrawlEndCallbacks: (() => void)[] = []
-  const crawlEndFinder = setupOnCrawlEnd(() => {
-    onCrawlEndCallbacks.forEach((cb) => cb())
-  })
-  function waitForRequestsIdle(ignoredId?: string): Promise<void> {
-    return crawlEndFinder.waitForRequestsIdle(ignoredId)
-  }
-  function _registerRequestProcessing(id: string, done: () => Promise<any>) {
-    crawlEndFinder.registerRequestProcessing(id, done)
-  }
-  function _onCrawlEnd(cb: () => void) {
-    onCrawlEndCallbacks.push(cb)
-  }
-
-  let server: ViteDevServer = {
-    config,
-    middlewares,
-    httpServer,
-    watcher,
-    pluginContainer: container,
-    ws,
-    hot,
-    moduleGraph,
-    resolvedUrls: null, // will be set on listen
-    ssrTransform(
-      code: string,
-      inMap: SourceMap | { mappings: '' } | null,
-      url: string,
-      originalCode = code,
-    ) {
-      return ssrTransform(code, inMap, url, originalCode, server.config)
-    },
-    transformRequest(url, options) {
-      return transformRequest(url, server, options)
-    },
-    async warmupRequest(url, options) {
-      try {
-        await transformRequest(url, server, options)
-      } catch (e) {
-        if (
-          e?.code === ERR_OUTDATED_OPTIMIZED_DEP ||
-          e?.code === ERR_CLOSED_SERVER
-        ) {
-          // these are expected errors
-          return
-        }
-        // Unexpected error, log the issue but avoid an unhandled exception
-        server.config.logger.error(`Pre-transform error: ${e.message}`, {
-          error: e,
-          timestamp: true,
-        })
-      }
-    },
-    transformIndexHtml(url, html, originalUrl) {
-      return devHtmlTransformFn(server, url, html, originalUrl)
-    },
-    async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {
-      return ssrLoadModule(url, server, undefined, opts?.fixStacktrace)
-    },
-    async ssrFetchModule(url: string, importer?: string) {
-      return ssrFetchModule(server, url, importer)
-    },
-    ssrFixStacktrace(e) {
-      ssrFixStacktrace(e, moduleGraph)
-    },
-    ssrRewriteStacktrace(stack: string) {
-      return ssrRewriteStacktrace(stack, moduleGraph)
-    },
-    async reloadModule(module) {
-      if (serverConfig.hmr !== false && module.file) {
-        updateModules(module.file, [module], Date.now(), server)
-      }
-    },
-    async listen(port?: number, isRestart?: boolean) {
-      await startServer(server, port)
-      if (httpServer) {
-        server.resolvedUrls = await resolveServerUrls(
-          httpServer,
-          config.server,
-          config,
-        )
-        if (!isRestart && config.server.open) server.openBrowser()
-      }
-      return server
-    },
-    openBrowser() {
-      const options = server.config.server
-      const url =
-        server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0]
-      if (url) {
-        const path =
-          typeof options.open === 'string'
-            ? new URL(options.open, url).href
-            : url
-
-        // We know the url that the browser would be opened to, so we can
-        // start the request while we are awaiting the browser. This will
-        // start the crawling of static imports ~500ms before.
-        // preTransformRequests needs to be enabled for this optimization.
-        if (server.config.server.preTransformRequests) {
-          setTimeout(() => {
-            const getMethod = path.startsWith('https:') ? httpsGet : httpGet
-
-            getMethod(
-              path,
-              {
-                headers: {
-                  // Allow the history middleware to redirect to /index.html
-                  Accept: 'text/html',
-                },
-              },
-              (res) => {
-                res.on('end', () => {
-                  // Ignore response, scripts discovered while processing the entry
-                  // will be preprocessed (server.config.server.preTransformRequests)
-                })
-              },
-            )
-              .on('error', () => {
-                // Ignore errors
-              })
-              .end()
-          }, 0)
-        }
-
-        _openBrowser(path, true, server.config.logger)
-      } else {
-        server.config.logger.warn('No URL available to open in browser')
-      }
-    },
-    async close() {
-      if (!middlewareMode) {
-        teardownSIGTERMListener(closeServerAndExit)
-      }
-      await Promise.allSettled([
-        watcher.close(),
-        hot.close(),
-        container.close(),
-        crawlEndFinder?.cancel(),
-        getDepsOptimizer(server.config)?.close(),
-        getDepsOptimizer(server.config, true)?.close(),
-        closeHttpServer(),
-      ])
-      // Await pending requests. We throw early in transformRequest
-      // and in hooks if the server is closing for non-ssr requests,
-      // so the import analysis plugin stops pre-transforming static
-      // imports and this block is resolved sooner.
-      // During SSR, we let pending requests finish to avoid exposing
-      // the server closed error to the users.
-      while (server._pendingRequests.size > 0) {
-        await Promise.allSettled(
-          [...server._pendingRequests.values()].map(
-            (pending) => pending.request,
-          ),
-        )
-      }
-      server.resolvedUrls = null
-    },
-    printUrls() {
-      if (server.resolvedUrls) {
-        printServerUrls(
-          server.resolvedUrls,
-          serverConfig.host,
-          config.logger.info,
-        )
-      } else if (middlewareMode) {
-        throw new Error('cannot print server URLs in middleware mode.')
-      } else {
-        throw new Error(
-          'cannot print server URLs before server.listen is called.',
-        )
-      }
-    },
-    bindCLIShortcuts(options) {
-      bindCLIShortcuts(server, options)
-    },
-    async restart(forceOptimize?: boolean) {
-      if (!server._restartPromise) {
-        server._forceOptimizeOnRestart = !!forceOptimize
-        server._restartPromise = restartServer(server).finally(() => {
-          server._restartPromise = null
-          server._forceOptimizeOnRestart = false
-        })
-      }
-      return server._restartPromise
-    },
-
-    waitForRequestsIdle,
-    _registerRequestProcessing,
-    _onCrawlEnd,
-
-    _setInternalServer(_server: ViteDevServer) {
-      // Rebind internal the server variable so functions reference the user
-      // server instance after a restart
-      server = _server
-    },
-    _restartPromise: null,
-    _importGlobMap: new Map(),
-    _forceOptimizeOnRestart: false,
-    _pendingRequests: new Map(),
-    _fsDenyGlob: picomatch(
-      // matchBase: true does not work as it's documented
-      // https://github.com/micromatch/picomatch/issues/89
-      // convert patterns without `/` on our side for now
-      config.server.fs.deny.map((pattern) =>
-        pattern.includes('/') ? pattern : `**/${pattern}`,
-      ),
-      {
-        matchBase: false,
-        nocase: true,
-        dot: true,
-      },
-    ),
-    _shortcutsOptions: undefined,
-  }
-
-  // maintain consistency with the server instance after restarting.
-  const reflexServer = new Proxy(server, {
-    get: (_, property: keyof ViteDevServer) => {
-      return server[property]
-    },
-    set: (_, property: keyof ViteDevServer, value: never) => {
-      server[property] = value
-      return true
-    },
-  })
-
-  const closeServerAndExit = async () => {
-    try {
-      await server.close()
-    } finally {
-      process.exit()
-    }
-  }
-
-  if (!middlewareMode) {
-    setupSIGTERMListener(closeServerAndExit)
-  }
-
-  const onHMRUpdate = async (
-    type: 'create' | 'delete' | 'update',
-    file: string,
-  ) => {
-    if (serverConfig.hmr !== false) {
-      try {
-        await handleHMRUpdate(type, file, server)
-      } catch (err) {
-        hot.send({
-          type: 'error',
-          err: prepareError(err),
-        })
-      }
-    }
-  }
-
-  const onFileAddUnlink = async (file: string, isUnlink: boolean) => {
-    file = normalizePath(file)
-    await container.watchChange(file, { event: isUnlink ? 'delete' : 'create' })
-
-    if (publicDir && publicFiles) {
-      if (file.startsWith(publicDir)) {
-        const path = file.slice(publicDir.length)
-        publicFiles[isUnlink ? 'delete' : 'add'](path)
-        if (!isUnlink) {
-          const moduleWithSamePath = await moduleGraph.getModuleByUrl(path)
-          const etag = moduleWithSamePath?.transformResult?.etag
-          if (etag) {
-            // The public file should win on the next request over a module with the
-            // same path. Prevent the transform etag fast path from serving the module
-            moduleGraph.etagToModuleMap.delete(etag)
-          }
-        }
-      }
-    }
-    if (isUnlink) moduleGraph.onFileDelete(file)
-    await onHMRUpdate(isUnlink ? 'delete' : 'create', file)
-  }
-
-  watcher.on('change', async (file) => {
-    file = normalizePath(file)
-    await container.watchChange(file, { event: 'update' })
-    // invalidate module graph cache on file change
-    moduleGraph.onFileChange(file)
-    await onHMRUpdate('update', file)
-  })
-
-  getFsUtils(config).initWatcher?.(watcher)
-
-  watcher.on('add', (file) => {
-    onFileAddUnlink(file, false)
-  })
-  watcher.on('unlink', (file) => {
-    onFileAddUnlink(file, true)
-  })
-
-  hot.on('vite:invalidate', async ({ path, message }) => {
-    const mod = moduleGraph.urlToModuleMap.get(path)
-    if (
-      mod &&
-      mod.isSelfAccepting &&
-      mod.lastHMRTimestamp > 0 &&
-      !mod.lastHMRInvalidationReceived
-    ) {
-      mod.lastHMRInvalidationReceived = true
-      config.logger.info(
-        colors.yellow(`hmr invalidate `) +
-          colors.dim(path) +
-          (message ? ` ${message}` : ''),
-        { timestamp: true },
-      )
-      const file = getShortName(mod.file!, config.root)
-      updateModules(
-        file,
-        [...mod.importers],
-        mod.lastHMRTimestamp,
-        server,
-        true,
-      )
-    }
-  })
-
-  if (!middlewareMode && httpServer) {
-    httpServer.once('listening', () => {
-      // update actual port since this may be different from initial value
-      serverConfig.port = (httpServer.address() as net.AddressInfo).port
-    })
-  }
-
-  // apply server configuration hooks from plugins
-  const postHooks: ((() => void) | void)[] = []
-  for (const hook of config.getSortedPluginHooks('configureServer')) {
-    postHooks.push(await hook(reflexServer))
-  }
-
-  // Internal middlewares ------------------------------------------------------
-
-  // request timer
-  if (process.env.DEBUG) {
-    middlewares.use(timeMiddleware(root))
-  }
-
-  // cors (enabled by default)
-  const { cors } = serverConfig
-  if (cors !== false) {
-    middlewares.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))
-  }
-
-  middlewares.use(cachedTransformMiddleware(server))
-
-  // proxy
-  const { proxy } = serverConfig
-  if (proxy) {
-    const middlewareServer =
-      (isObject(middlewareMode) ? middlewareMode.server : null) || httpServer
-    middlewares.use(proxyMiddleware(middlewareServer, proxy, config))
-  }
-
-  // base
-  if (config.base !== '/') {
-    middlewares.use(baseMiddleware(config.rawBase, !!middlewareMode))
-  }
-
-  // open in editor support
-  middlewares.use('/__open-in-editor', launchEditorMiddleware())
-
-  // ping request handler
-  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
-  middlewares.use(function viteHMRPingMiddleware(req, res, next) {
-    if (req.headers['accept'] === 'text/x-vite-ping') {
-      res.writeHead(204).end()
-    } else {
-      next()
-    }
-  })
-
-  // serve static files under /public
-  // this applies before the transform middleware so that these files are served
-  // as-is without transforms.
-  if (publicDir) {
-    middlewares.use(servePublicMiddleware(server, publicFiles))
-  }
-
-  // main transform middleware
-  middlewares.use(transformMiddleware(server))
-
-  // serve static files
-  middlewares.use(serveRawFsMiddleware(server))
-  middlewares.use(serveStaticMiddleware(server))
-
-  // html fallback
-  if (config.appType === 'spa' || config.appType === 'mpa') {
-    middlewares.use(
-      htmlFallbackMiddleware(
-        root,
-        config.appType === 'spa',
-        getFsUtils(config),
-      ),
-    )
-  }
-
-  // run post config hooks
-  // This is applied before the html middleware so that user middleware can
-  // serve custom content instead of index.html.
-  postHooks.forEach((fn) => fn && fn())
-
-  if (config.appType === 'spa' || config.appType === 'mpa') {
-    // transform index.html
-    middlewares.use(indexHtmlMiddleware(root, server))
-
-    // handle 404s
-    middlewares.use(notFoundMiddleware())
-  }
-
-  // error handler
-  middlewares.use(errorMiddleware(server, !!middlewareMode))
-
-  // httpServer.listen can be called multiple times
-  // when port when using next port number
-  // this code is to avoid calling buildStart multiple times
-  let initingServer: Promise<void> | undefined
-  let serverInited = false
-  const initServer = async () => {
-    if (serverInited) return
-    if (initingServer) return initingServer
-
-    initingServer = (async function () {
-      await container.buildStart({})
-      // start deps optimizer after all container plugins are ready
-      if (isDepsOptimizerEnabled(config, false)) {
-        await initDepsOptimizer(config, server)
-      }
-      warmupFiles(server)
-      initingServer = undefined
-      serverInited = true
-    })()
-    return initingServer
-  }
-
-  if (!middlewareMode && httpServer) {
-    // overwrite listen to init optimizer before server start
-    const listen = httpServer.listen.bind(httpServer)
-    httpServer.listen = (async (port: number, ...args: any[]) => {
-      try {
-        // ensure ws server started
-        hot.listen()
-        await initServer()
-      } catch (e) {
-        httpServer.emit('error', e)
-        return
-      }
-      return listen(port, ...args)
-    }) as any
-  } else {
-    if (options.hotListen) {
-      hot.listen()
-    }
-    await initServer()
-  }
-
-  return server
-}
-
 async function startServer(
   server: ViteDevServer,
   inlinePort?: number,
@@ -1036,145 +209,6 @@ export function createServerCloseFn(
     })
 }
 
-function resolvedAllowDir(root: string, dir: string): string {
-  return normalizePath(path.resolve(root, dir))
-}
-
-export function resolveServerOptions(
-  root: string,
-  raw: ServerOptions | undefined,
-  logger: Logger,
-): ResolvedServerOptions {
-  const server: ResolvedServerOptions = {
-    preTransformRequests: true,
-    ...(raw as Omit<ResolvedServerOptions, 'sourcemapIgnoreList'>),
-    sourcemapIgnoreList:
-      raw?.sourcemapIgnoreList === false
-        ? () => false
-        : raw?.sourcemapIgnoreList || isInNodeModules,
-    middlewareMode: raw?.middlewareMode || false,
-  }
-  let allowDirs = server.fs?.allow
-  const deny = server.fs?.deny || ['.env', '.env.*', '*.{crt,pem}']
-
-  if (!allowDirs) {
-    allowDirs = [searchForWorkspaceRoot(root)]
-  }
-
-  if (process.versions.pnp) {
-    try {
-      const enableGlobalCache =
-        execSync('yarn config get enableGlobalCache', { cwd: root })
-          .toString()
-          .trim() === 'true'
-      const yarnCacheDir = execSync(
-        `yarn config get ${enableGlobalCache ? 'globalFolder' : 'cacheFolder'}`,
-        { cwd: root },
-      )
-        .toString()
-        .trim()
-      allowDirs.push(yarnCacheDir)
-    } catch (e) {
-      logger.warn(`Get yarn cache dir error: ${e.message}`, {
-        timestamp: true,
-      })
-    }
-  }
-
-  allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i))
-
-  // only push client dir when vite itself is outside-of-root
-  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR)
-  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {
-    allowDirs.push(resolvedClientDir)
-  }
-
-  server.fs = {
-    strict: server.fs?.strict ?? true,
-    allow: allowDirs,
-    deny,
-    cachedChecks: server.fs?.cachedChecks,
-  }
-
-  if (server.origin?.endsWith('/')) {
-    server.origin = server.origin.slice(0, -1)
-    logger.warn(
-      colors.yellow(
-        `${colors.bold('(!)')} server.origin should not end with "/". Using "${
-          server.origin
-        }" instead.`,
-      ),
-    )
-  }
-
-  return server
-}
-
-async function restartServer(server: ViteDevServer) {
-  global.__vite_start_time = performance.now()
-  const shortcutsOptions = server._shortcutsOptions
-
-  let inlineConfig = server.config.inlineConfig
-  if (server._forceOptimizeOnRestart) {
-    inlineConfig = mergeConfig(inlineConfig, {
-      optimizeDeps: {
-        force: true,
-      },
-    })
-  }
-
-  // Reinit the server by creating a new instance using the same inlineConfig
-  // This will trigger a reload of the config file and re-create the plugins and
-  // middlewares. We then assign all properties of the new server to the existing
-  // server instance and set the user instance to be used in the new server.
-  // This allows us to keep the same server instance for the user.
-  {
-    let newServer = null
-    try {
-      // delay ws server listen
-      newServer = await _createServer(inlineConfig, { hotListen: false })
-    } catch (err: any) {
-      server.config.logger.error(err.message, {
-        timestamp: true,
-      })
-      server.config.logger.error('server restart failed', { timestamp: true })
-      return
-    }
-
-    await server.close()
-
-    // Assign new server props to existing server instance
-    const middlewares = server.middlewares
-    newServer._configServerPort = server._configServerPort
-    newServer._currentServerPort = server._currentServerPort
-    Object.assign(server, newServer)
-
-    // Keep the same connect instance so app.use(vite.middlewares) works
-    // after a restart in middlewareMode (.route is always '/')
-    middlewares.stack = newServer.middlewares.stack
-    server.middlewares = middlewares
-
-    // Rebind internal server variable so functions reference the user server
-    newServer._setInternalServer(server)
-  }
-
-  const {
-    logger,
-    server: { port, middlewareMode },
-  } = server.config
-  if (!middlewareMode) {
-    await server.listen(port, true)
-  } else {
-    server.hot.listen()
-  }
-  logger.info('server restarted.', { timestamp: true })
-
-  if (shortcutsOptions) {
-    shortcutsOptions.print = false
-    bindCLIShortcuts(server, shortcutsOptions)
-  }
-}
-
 /**
  * Internal function to restart the Vite server and print URLs if changed
  */
@@ -1204,81 +238,3 @@ export async function restartServerWithUrls(
     server.printUrls()
   }
 }
-
-const callCrawlEndIfIdleAfterMs = 50
-
-interface CrawlEndFinder {
-  registerRequestProcessing: (id: string, done: () => Promise<any>) => void
-  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
-  cancel: () => void
-}
-
-function setupOnCrawlEnd(onCrawlEnd: () => void): CrawlEndFinder {
-  const registeredIds = new Set<string>()
-  const seenIds = new Set<string>()
-  const onCrawlEndPromiseWithResolvers = promiseWithResolvers<void>()
-
-  let timeoutHandle: NodeJS.Timeout | undefined
-
-  let cancelled = false
-  function cancel() {
-    cancelled = true
-  }
-
-  let crawlEndCalled = false
-  function callOnCrawlEnd() {
-    if (!cancelled && !crawlEndCalled) {
-      crawlEndCalled = true
-      onCrawlEnd()
-    }
-    onCrawlEndPromiseWithResolvers.resolve()
-  }
-
-  function registerRequestProcessing(
-    id: string,
-    done: () => Promise<any>,
-  ): void {
-    if (!seenIds.has(id)) {
-      seenIds.add(id)
-      registeredIds.add(id)
-      done()
-        .catch(() => {})
-        .finally(() => markIdAsDone(id))
-    }
-  }
-
-  function waitForRequestsIdle(ignoredId?: string): Promise<void> {
-    if (ignoredId) {
-      seenIds.add(ignoredId)
-      markIdAsDone(ignoredId)
-    }
-    return onCrawlEndPromiseWithResolvers.promise
-  }
-
-  function markIdAsDone(id: string): void {
-    if (registeredIds.has(id)) {
-      registeredIds.delete(id)
-      checkIfCrawlEndAfterTimeout()
-    }
-  }
-
-  function checkIfCrawlEndAfterTimeout() {
-    if (cancelled || registeredIds.size > 0) return
-
-    if (timeoutHandle) clearTimeout(timeoutHandle)
-    timeoutHandle = setTimeout(
-      callOnCrawlEndWhenIdle,
-      callCrawlEndIfIdleAfterMs,
-    )
-  }
-  async function callOnCrawlEndWhenIdle() {
-    if (cancelled || registeredIds.size > 0) return
-    callOnCrawlEnd()
-  }
-
-  return {
-    registerRequestProcessing,
-    waitForRequestsIdle,
-    cancel,
-  }
-}
diff --git a/packages/vite/src/node/server/index/ServerOptions.ts b/packages/vite/src/node/server/index/ServerOptions.ts
new file mode 100644
index 000000000..5f6248b71
--- /dev/null
+++ b/packages/vite/src/node/server/index/ServerOptions.ts
@@ -0,0 +1,115 @@
+import type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
+import { CommonServerOptions } from 'packages/vite/src/node/http';
+import { HmrOptions } from 'packages/vite/src/node/server/hmr';
+import type { Http2SecureServer } from 'node:http2'
+
+
+export interface FileSystemServeOptions {
+  /**
+   * Strictly restrict file accessing outside of allowing paths.
+   *
+   * Set to `false` to disable the warning
+   *
+   * @default true
+   */
+  strict?: boolean
+
+  /**
+   * Restrict accessing files outside the allowed directories.
+   *
+   * Accepts absolute path or a path relative to project root.
+   * Will try to search up for workspace root by default.
+   */
+  allow?: string[]
+
+  /**
+   * Restrict accessing files that matches the patterns.
+   *
+   * This will have higher priority than `allow`.
+   * picomatch patterns are supported.
+   *
+   * @default ['.env', '.env.*', '*.crt', '*.pem']
+   */
+  deny?: string[]
+
+  /**
+   * Enable caching of fs calls. It is enabled by default if no custom watch ignored patterns are provided.
+   *
+   * @experimental
+   * @default undefined
+   */
+  cachedChecks?: boolean
+}
+
+export type HttpServer = http.Server | Http2SecureServer
+
+export interface ServerOptions extends CommonServerOptions {
+  /**
+   * Configure HMR-specific options (port, host, path & protocol)
+   */
+  hmr?: HmrOptions | boolean
+  /**
+   * Do not start the websocket connection.
+   * @experimental
+   */
+  ws?: false
+  /**
+   * Warm-up files to transform and cache the results in advance. This improves the
+   * initial page load during server starts and prevents transform waterfalls.
+   */
+  warmup?: {
+    /**
+     * The files to be transformed and used on the client-side. Supports glob patterns.
+     */
+    clientFiles?: string[]
+    /**
+     * The files to be transformed and used in SSR. Supports glob patterns.
+     */
+    ssrFiles?: string[]
+  }
+  /**
+   * chokidar watch options or null to disable FS watching
+   * https://github.com/paulmillr/chokidar#api
+   */
+  watch?: WatchOptions | null
+  /**
+   * Create Vite dev server to be used as a middleware in an existing server
+   * @default false
+   */
+  middlewareMode?:
+    | boolean
+    | {
+        /**
+         * Parent server instance to attach to
+         *
+         * This is needed to proxy WebSocket connections to the parent server.
+         */
+        server: HttpServer
+      }
+  /**
+   * Options for files served via '/\@fs/'.
+   */
+  fs?: FileSystemServeOptions
+  /**
+   * Origin for the generated asset URLs.
+   *
+   * @example `http://127.0.0.1:8080`
+   */
+  origin?: string
+  /**
+   * Pre-transform known direct imports
+   * @default true
+   */
+  preTransformRequests?: boolean
+  /**
+   * Whether or not to ignore-list source files in the dev server sourcemap, used to populate
+   * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).
+   *
+   * By default, it excludes all paths containing `node_modules`. You can pass `false` to
+   * disable this behavior, or, for full control, a function that takes the source path and
+   * sourcemap path and returns whether to ignore the source path.
+   */
+  sourcemapIgnoreList?:
+    | false
+    | ((sourcePath: string, sourcemapPath: string) => boolean)
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/index/ViteDevServer.ts b/packages/vite/src/node/server/index/ViteDevServer.ts
new file mode 100644
index 000000000..d28820b54
--- /dev/null
+++ b/packages/vite/src/node/server/index/ViteDevServer.ts
@@ -0,0 +1,216 @@
+import type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
+import type { SourceMap } from 'rollup'
+import type { Matcher } from 'picomatch'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { BindCLIShortcutsOptions } from 'packages/vite/src/node/shortcuts';
+import { FetchResult } from 'packages/vite/src/runtime/types';
+import { PluginContainer } from 'packages/vite/src/node/server/pluginContainer';
+import { WebSocketServer } from 'packages/vite/src/node/server/ws';
+import { ModuleNode } from 'packages/vite/src/node/server/moduleGraph';
+import { ModuleGraph } from 'packages/vite/src/node/server/moduleGraph';
+import { HMRBroadcaster } from 'packages/vite/src/node/server/hmr';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest';
+import type { Http2SecureServer } from 'node:http2'
+
+
+export type HttpServer = http.Server | Http2SecureServer
+
+export interface ResolvedServerUrls {
+  local: string[]
+  network: string[]
+}
+
+export interface ViteDevServer {
+  /**
+   * The resolved vite config object
+   */
+  config: ResolvedConfig
+  /**
+   * A connect app instance.
+   * - Can be used to attach custom middlewares to the dev server.
+   * - Can also be used as the handler function of a custom http server
+   *   or as a middleware in any connect-style Node.js frameworks
+   *
+   * https://github.com/senchalabs/connect#use-middleware
+   */
+  middlewares: Connect.Server
+  /**
+   * native Node http server instance
+   * will be null in middleware mode
+   */
+  httpServer: HttpServer | null
+  /**
+   * chokidar watcher instance
+   * https://github.com/paulmillr/chokidar#api
+   */
+  watcher: FSWatcher
+  /**
+   * web socket server with `send(payload)` method
+   */
+  ws: WebSocketServer
+  /**
+   * HMR broadcaster that can be used to send custom HMR messages to the client
+   *
+   * Always sends a message to at least a WebSocket client. Any third party can
+   * add a channel to the broadcaster to process messages
+   * @deprecated will be replaced with the environment api in v6.
+   */
+  hot: HMRBroadcaster
+  /**
+   * Rollup plugin container that can run plugin hooks on a given file
+   */
+  pluginContainer: PluginContainer
+  /**
+   * Module graph that tracks the import relationships, url to file mapping
+   * and hmr state.
+   */
+  moduleGraph: ModuleGraph
+  /**
+   * The resolved urls Vite prints on the CLI. null in middleware mode or
+   * before `server.listen` is called.
+   */
+  resolvedUrls: ResolvedServerUrls | null
+  /**
+   * Programmatically resolve, load and transform a URL and get the result
+   * without going through the http request pipeline.
+   */
+  transformRequest(
+    url: string,
+    options?: TransformOptions,
+  ): Promise<TransformResult | null>
+  /**
+   * Same as `transformRequest` but only warm up the URLs so the next request
+   * will already be cached. The function will never throw as it handles and
+   * reports errors internally.
+   */
+  warmupRequest(url: string, options?: TransformOptions): Promise<void>
+  /**
+   * Apply vite built-in HTML transforms and any plugin HTML transforms.
+   */
+  transformIndexHtml(
+    url: string,
+    html: string,
+    originalUrl?: string,
+  ): Promise<string>
+  /**
+   * Transform module code into SSR format.
+   */
+  ssrTransform(
+    code: string,
+    inMap: SourceMap | { mappings: '' } | null,
+    url: string,
+    originalCode?: string,
+  ): Promise<TransformResult | null>
+  /**
+   * Load a given URL as an instantiated module for SSR.
+   */
+  ssrLoadModule(
+    url: string,
+    opts?: { fixStacktrace?: boolean },
+  ): Promise<Record<string, any>>
+  /**
+   * Fetch information about the module for Vite SSR runtime.
+   * @experimental
+   */
+  ssrFetchModule(id: string, importer?: string): Promise<FetchResult>
+  /**
+   * Returns a fixed version of the given stack
+   */
+  ssrRewriteStacktrace(stack: string): string
+  /**
+   * Mutates the given SSR error by rewriting the stacktrace
+   */
+  ssrFixStacktrace(e: Error): void
+  /**
+   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`
+   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.
+   */
+  reloadModule(module: ModuleNode): Promise<void>
+  /**
+   * Start the server.
+   */
+  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
+  /**
+   * Stop the server.
+   */
+  close(): Promise<void>
+  /**
+   * Print server urls
+   */
+  printUrls(): void
+  /**
+   * Bind CLI shortcuts
+   */
+  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
+  /**
+   * Restart the server.
+   *
+   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
+   */
+  restart(forceOptimize?: boolean): Promise<void>
+
+  /**
+   * Open browser
+   */
+  openBrowser(): void
+  /**
+   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports
+   * are processed. If called from a load or transform plugin hook, the id needs to be
+   * passed as a parameter to avoid deadlocks. Calling this function after the first
+   * static imports section of the module graph has been processed will resolve immediately.
+   * @experimental
+   */
+  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
+  /**
+   * @internal
+   */
+  _registerRequestProcessing: (id: string, done: () => Promise<unknown>) => void
+  /**
+   * @internal
+   */
+  _onCrawlEnd(cb: () => void): void
+  /**
+   * @internal
+   */
+  _setInternalServer(server: ViteDevServer): void
+  /**
+   * @internal
+   */
+  _importGlobMap: Map<string, { affirmed: string[]; negated: string[] }[]>
+  /**
+   * @internal
+   */
+  _restartPromise: Promise<void> | null
+  /**
+   * @internal
+   */
+  _forceOptimizeOnRestart: boolean
+  /**
+   * @internal
+   */
+  _pendingRequests: Map<
+    string,
+    {
+      request: Promise<TransformResult | null>
+      timestamp: number
+      abort: () => void
+    }
+  >
+  /**
+   * @internal
+   */
+  _fsDenyGlob: Matcher
+  /**
+   * @internal
+   */
+  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>
+  /**
+   * @internal
+   */
+  _currentServerPort?: number | undefined
+  /**
+   * @internal
+   */
+  _configServerPort?: number | undefined
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/index/_createServer.ts b/packages/vite/src/node/server/index/_createServer.ts
new file mode 100644
index 000000000..595413e32
--- /dev/null
+++ b/packages/vite/src/node/server/index/_createServer.ts
@@ -0,0 +1,811 @@
+import connect from 'connect'
+import corsMiddleware from 'cors'
+import colors from 'picocolors'
+import chokidar from 'chokidar'
+import type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
+import type { Connect } from 'dep-types/connect'
+import launchEditorMiddleware from 'launch-editor-middleware'
+import type { SourceMap } from 'rollup'
+import picomatch from 'picomatch'
+import { setClientErrorHandler } from 'packages/vite/src/node/http';
+import { resolveHttpsConfig } from 'packages/vite/src/node/http';
+import { resolveHttpServer } from 'packages/vite/src/node/http';
+import { InlineConfig } from 'packages/vite/src/node/config';
+import { resolveConfig } from 'packages/vite/src/node/config';
+import { setupSIGTERMListener } from 'packages/vite/src/node/utils';
+import { teardownSIGTERMListener } from 'packages/vite/src/node/utils';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { isObject } from 'packages/vite/src/node/utils';
+import { getFsUtils } from 'packages/vite/src/node/fsUtils';
+import { ssrLoadModule } from 'packages/vite/src/node/ssr/ssrModuleLoader';
+import { ssrFixStacktrace } from 'packages/vite/src/node/ssr/ssrStacktrace';
+import { ssrRewriteStacktrace } from 'packages/vite/src/node/ssr/ssrStacktrace';
+import { ssrTransform } from 'packages/vite/src/node/ssr/ssrTransform';
+import { ERR_OUTDATED_OPTIMIZED_DEP } from 'packages/vite/src/node/plugins/optimizedDeps';
+import { getDepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { bindCLIShortcuts } from 'packages/vite/src/node/shortcuts';
+import { printServerUrls } from 'packages/vite/src/node/logger';
+import { getResolvedOutDirs } from 'packages/vite/src/node/watch';
+import { resolveEmptyOutDir } from 'packages/vite/src/node/watch';
+import { resolveChokidarOptions } from 'packages/vite/src/node/watch';
+import { createNoopWatcher } from 'packages/vite/src/node/watch';
+import { initPublicFiles } from 'packages/vite/src/node/publicDir';
+import { getEnvFilesForMode } from 'packages/vite/src/node/env';
+import { ssrFetchModule } from 'packages/vite/src/node/ssr/ssrFetchModule';
+import { createPluginContainer } from 'packages/vite/src/node/server/pluginContainer';
+import { ERR_CLOSED_SERVER } from 'packages/vite/src/node/server/pluginContainer';
+import { createWebSocketServer } from 'packages/vite/src/node/server/ws';
+import { baseMiddleware } from 'packages/vite/src/node/server/middlewares/base';
+import { proxyMiddleware } from 'packages/vite/src/node/server/middlewares/proxy';
+import { htmlFallbackMiddleware } from 'packages/vite/src/node/server/middlewares/htmlFallback';
+import { cachedTransformMiddleware } from 'packages/vite/src/node/server/middlewares/transform';
+import { transformMiddleware } from 'packages/vite/src/node/server/middlewares/transform';
+import { indexHtmlMiddleware } from 'packages/vite/src/node/server/middlewares/indexHtml';
+import { createDevHtmlTransformFn } from 'packages/vite/src/node/server/middlewares/indexHtml';
+import { servePublicMiddleware } from 'packages/vite/src/node/server/middlewares/static';
+import { serveRawFsMiddleware } from 'packages/vite/src/node/server/middlewares/static';
+import { serveStaticMiddleware } from 'packages/vite/src/node/server/middlewares/static';
+import { timeMiddleware } from 'packages/vite/src/node/server/middlewares/time';
+import { ModuleGraph } from 'packages/vite/src/node/server/moduleGraph';
+import { notFoundMiddleware } from 'packages/vite/src/node/server/middlewares/notFound';
+import { errorMiddleware } from 'packages/vite/src/node/server/middlewares/error';
+import { prepareError } from 'packages/vite/src/node/server/middlewares/error';
+import { updateModules } from 'packages/vite/src/node/server/hmr';
+import { createServerHMRChannel } from 'packages/vite/src/node/server/hmr';
+import { createHMRBroadcaster } from 'packages/vite/src/node/server/hmr';
+import { handleHMRUpdate } from 'packages/vite/src/node/server/hmr';
+import { openBrowser as _openBrowser } from 'packages/vite/src/node/server/openBrowser';
+import { transformRequest } from 'packages/vite/src/node/server/transformRequest';
+import type { Matcher } from 'picomatch'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { BindCLIShortcutsOptions } from 'packages/vite/src/node/shortcuts';
+import { FetchResult } from 'packages/vite/src/runtime/types';
+import { PluginContainer } from 'packages/vite/src/node/server/pluginContainer';
+import { WebSocketServer } from 'packages/vite/src/node/server/ws';
+import { ModuleNode } from 'packages/vite/src/node/server/moduleGraph';
+import { HMRBroadcaster } from 'packages/vite/src/node/server/hmr';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest';
+import type { Http2SecureServer } from 'node:http2'
+
+
+export type HttpServer = http.Server | Http2SecureServer
+
+export interface ResolvedServerUrls {
+  local: string[]
+  network: string[]
+}
+
+export interface ViteDevServer {
+  /**
+   * The resolved vite config object
+   */
+  config: ResolvedConfig
+  /**
+   * A connect app instance.
+   * - Can be used to attach custom middlewares to the dev server.
+   * - Can also be used as the handler function of a custom http server
+   *   or as a middleware in any connect-style Node.js frameworks
+   *
+   * https://github.com/senchalabs/connect#use-middleware
+   */
+  middlewares: Connect.Server
+  /**
+   * native Node http server instance
+   * will be null in middleware mode
+   */
+  httpServer: HttpServer | null
+  /**
+   * chokidar watcher instance
+   * https://github.com/paulmillr/chokidar#api
+   */
+  watcher: FSWatcher
+  /**
+   * web socket server with `send(payload)` method
+   */
+  ws: WebSocketServer
+  /**
+   * HMR broadcaster that can be used to send custom HMR messages to the client
+   *
+   * Always sends a message to at least a WebSocket client. Any third party can
+   * add a channel to the broadcaster to process messages
+   * @deprecated will be replaced with the environment api in v6.
+   */
+  hot: HMRBroadcaster
+  /**
+   * Rollup plugin container that can run plugin hooks on a given file
+   */
+  pluginContainer: PluginContainer
+  /**
+   * Module graph that tracks the import relationships, url to file mapping
+   * and hmr state.
+   */
+  moduleGraph: ModuleGraph
+  /**
+   * The resolved urls Vite prints on the CLI. null in middleware mode or
+   * before `server.listen` is called.
+   */
+  resolvedUrls: ResolvedServerUrls | null
+  /**
+   * Programmatically resolve, load and transform a URL and get the result
+   * without going through the http request pipeline.
+   */
+  transformRequest(
+    url: string,
+    options?: TransformOptions,
+  ): Promise<TransformResult | null>
+  /**
+   * Same as `transformRequest` but only warm up the URLs so the next request
+   * will already be cached. The function will never throw as it handles and
+   * reports errors internally.
+   */
+  warmupRequest(url: string, options?: TransformOptions): Promise<void>
+  /**
+   * Apply vite built-in HTML transforms and any plugin HTML transforms.
+   */
+  transformIndexHtml(
+    url: string,
+    html: string,
+    originalUrl?: string,
+  ): Promise<string>
+  /**
+   * Transform module code into SSR format.
+   */
+  ssrTransform(
+    code: string,
+    inMap: SourceMap | { mappings: '' } | null,
+    url: string,
+    originalCode?: string,
+  ): Promise<TransformResult | null>
+  /**
+   * Load a given URL as an instantiated module for SSR.
+   */
+  ssrLoadModule(
+    url: string,
+    opts?: { fixStacktrace?: boolean },
+  ): Promise<Record<string, any>>
+  /**
+   * Fetch information about the module for Vite SSR runtime.
+   * @experimental
+   */
+  ssrFetchModule(id: string, importer?: string): Promise<FetchResult>
+  /**
+   * Returns a fixed version of the given stack
+   */
+  ssrRewriteStacktrace(stack: string): string
+  /**
+   * Mutates the given SSR error by rewriting the stacktrace
+   */
+  ssrFixStacktrace(e: Error): void
+  /**
+   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`
+   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.
+   */
+  reloadModule(module: ModuleNode): Promise<void>
+  /**
+   * Start the server.
+   */
+  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
+  /**
+   * Stop the server.
+   */
+  close(): Promise<void>
+  /**
+   * Print server urls
+   */
+  printUrls(): void
+  /**
+   * Bind CLI shortcuts
+   */
+  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
+  /**
+   * Restart the server.
+   *
+   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
+   */
+  restart(forceOptimize?: boolean): Promise<void>
+
+  /**
+   * Open browser
+   */
+  openBrowser(): void
+  /**
+   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports
+   * are processed. If called from a load or transform plugin hook, the id needs to be
+   * passed as a parameter to avoid deadlocks. Calling this function after the first
+   * static imports section of the module graph has been processed will resolve immediately.
+   * @experimental
+   */
+  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
+  /**
+   * @internal
+   */
+  _registerRequestProcessing: (id: string, done: () => Promise<unknown>) => void
+  /**
+   * @internal
+   */
+  _onCrawlEnd(cb: () => void): void
+  /**
+   * @internal
+   */
+  _setInternalServer(server: ViteDevServer): void
+  /**
+   * @internal
+   */
+  _importGlobMap: Map<string, { affirmed: string[]; negated: string[] }[]>
+  /**
+   * @internal
+   */
+  _restartPromise: Promise<void> | null
+  /**
+   * @internal
+   */
+  _forceOptimizeOnRestart: boolean
+  /**
+   * @internal
+   */
+  _pendingRequests: Map<
+    string,
+    {
+      request: Promise<TransformResult | null>
+      timestamp: number
+      abort: () => void
+    }
+  >
+  /**
+   * @internal
+   */
+  _fsDenyGlob: Matcher
+  /**
+   * @internal
+   */
+  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>
+  /**
+   * @internal
+   */
+  _currentServerPort?: number | undefined
+  /**
+   * @internal
+   */
+  _configServerPort?: number | undefined
+}
+
+export async function _createServer(
+  inlineConfig: InlineConfig = {},
+  options: { hotListen: boolean },
+): Promise<ViteDevServer> {
+  const config = await resolveConfig(inlineConfig, 'serve')
+
+  const initPublicFilesPromise = initPublicFiles(config)
+
+  const { root, server: serverConfig } = config
+  const httpsOptions = await resolveHttpsConfig(config.server.https)
+  const { middlewareMode } = serverConfig
+
+  const resolvedOutDirs = getResolvedOutDirs(
+    config.root,
+    config.build.outDir,
+    config.build.rollupOptions?.output,
+  )
+  const emptyOutDir = resolveEmptyOutDir(
+    config.build.emptyOutDir,
+    config.root,
+    resolvedOutDirs,
+  )
+  const resolvedWatchOptions = resolveChokidarOptions(
+    config,
+    {
+      disableGlobbing: true,
+      ...serverConfig.watch,
+    },
+    resolvedOutDirs,
+    emptyOutDir,
+  )
+
+  const middlewares = connect() as Connect.Server
+  const httpServer = middlewareMode
+    ? null
+    : await resolveHttpServer(serverConfig, middlewares, httpsOptions)
+
+  const ws = createWebSocketServer(httpServer, config, httpsOptions)
+  const hot = createHMRBroadcaster()
+    .addChannel(ws)
+    .addChannel(createServerHMRChannel())
+  if (typeof config.server.hmr === 'object' && config.server.hmr.channels) {
+    config.server.hmr.channels.forEach((channel) => hot.addChannel(channel))
+  }
+
+  const publicFiles = await initPublicFilesPromise
+  const { publicDir } = config
+
+  if (httpServer) {
+    setClientErrorHandler(httpServer, config.logger)
+  }
+
+  // eslint-disable-next-line eqeqeq
+  const watchEnabled = serverConfig.watch !== null
+  const watcher = watchEnabled
+    ? (chokidar.watch(
+        // config file dependencies and env file might be outside of root
+        [
+          root,
+          ...config.configFileDependencies,
+          ...getEnvFilesForMode(config.mode, config.envDir),
+          // Watch the public directory explicitly because it might be outside
+          // of the root directory.
+          ...(publicDir && publicFiles ? [publicDir] : []),
+        ],
+        resolvedWatchOptions,
+      ) as FSWatcher)
+    : createNoopWatcher(resolvedWatchOptions)
+
+  const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>
+    container.resolveId(url, undefined, { ssr }),
+  )
+
+  const container = await createPluginContainer(config, moduleGraph, watcher)
+  const closeHttpServer = createServerCloseFn(httpServer)
+
+  const devHtmlTransformFn = createDevHtmlTransformFn(config)
+
+  const onCrawlEndCallbacks: (() => void)[] = []
+  const crawlEndFinder = setupOnCrawlEnd(() => {
+    onCrawlEndCallbacks.forEach((cb) => cb())
+  })
+  function waitForRequestsIdle(ignoredId?: string): Promise<void> {
+    return crawlEndFinder.waitForRequestsIdle(ignoredId)
+  }
+  function _registerRequestProcessing(id: string, done: () => Promise<any>) {
+    crawlEndFinder.registerRequestProcessing(id, done)
+  }
+  function _onCrawlEnd(cb: () => void) {
+    onCrawlEndCallbacks.push(cb)
+  }
+
+  let server: ViteDevServer = {
+    config,
+    middlewares,
+    httpServer,
+    watcher,
+    pluginContainer: container,
+    ws,
+    hot,
+    moduleGraph,
+    resolvedUrls: null, // will be set on listen
+    ssrTransform(
+      code: string,
+      inMap: SourceMap | { mappings: '' } | null,
+      url: string,
+      originalCode = code,
+    ) {
+      return ssrTransform(code, inMap, url, originalCode, server.config)
+    },
+    transformRequest(url, options) {
+      return transformRequest(url, server, options)
+    },
+    async warmupRequest(url, options) {
+      try {
+        await transformRequest(url, server, options)
+      } catch (e) {
+        if (
+          e?.code === ERR_OUTDATED_OPTIMIZED_DEP ||
+          e?.code === ERR_CLOSED_SERVER
+        ) {
+          // these are expected errors
+          return
+        }
+        // Unexpected error, log the issue but avoid an unhandled exception
+        server.config.logger.error(`Pre-transform error: ${e.message}`, {
+          error: e,
+          timestamp: true,
+        })
+      }
+    },
+    transformIndexHtml(url, html, originalUrl) {
+      return devHtmlTransformFn(server, url, html, originalUrl)
+    },
+    async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {
+      return ssrLoadModule(url, server, undefined, opts?.fixStacktrace)
+    },
+    async ssrFetchModule(url: string, importer?: string) {
+      return ssrFetchModule(server, url, importer)
+    },
+    ssrFixStacktrace(e) {
+      ssrFixStacktrace(e, moduleGraph)
+    },
+    ssrRewriteStacktrace(stack: string) {
+      return ssrRewriteStacktrace(stack, moduleGraph)
+    },
+    async reloadModule(module) {
+      if (serverConfig.hmr !== false && module.file) {
+        updateModules(module.file, [module], Date.now(), server)
+      }
+    },
+    async listen(port?: number, isRestart?: boolean) {
+      await startServer(server, port)
+      if (httpServer) {
+        server.resolvedUrls = await resolveServerUrls(
+          httpServer,
+          config.server,
+          config,
+        )
+        if (!isRestart && config.server.open) server.openBrowser()
+      }
+      return server
+    },
+    openBrowser() {
+      const options = server.config.server
+      const url =
+        server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0]
+      if (url) {
+        const path =
+          typeof options.open === 'string'
+            ? new URL(options.open, url).href
+            : url
+
+        // We know the url that the browser would be opened to, so we can
+        // start the request while we are awaiting the browser. This will
+        // start the crawling of static imports ~500ms before.
+        // preTransformRequests needs to be enabled for this optimization.
+        if (server.config.server.preTransformRequests) {
+          setTimeout(() => {
+            const getMethod = path.startsWith('https:') ? httpsGet : httpGet
+
+            getMethod(
+              path,
+              {
+                headers: {
+                  // Allow the history middleware to redirect to /index.html
+                  Accept: 'text/html',
+                },
+              },
+              (res) => {
+                res.on('end', () => {
+                  // Ignore response, scripts discovered while processing the entry
+                  // will be preprocessed (server.config.server.preTransformRequests)
+                })
+              },
+            )
+              .on('error', () => {
+                // Ignore errors
+              })
+              .end()
+          }, 0)
+        }
+
+        _openBrowser(path, true, server.config.logger)
+      } else {
+        server.config.logger.warn('No URL available to open in browser')
+      }
+    },
+    async close() {
+      if (!middlewareMode) {
+        teardownSIGTERMListener(closeServerAndExit)
+      }
+      await Promise.allSettled([
+        watcher.close(),
+        hot.close(),
+        container.close(),
+        crawlEndFinder?.cancel(),
+        getDepsOptimizer(server.config)?.close(),
+        getDepsOptimizer(server.config, true)?.close(),
+        closeHttpServer(),
+      ])
+      // Await pending requests. We throw early in transformRequest
+      // and in hooks if the server is closing for non-ssr requests,
+      // so the import analysis plugin stops pre-transforming static
+      // imports and this block is resolved sooner.
+      // During SSR, we let pending requests finish to avoid exposing
+      // the server closed error to the users.
+      while (server._pendingRequests.size > 0) {
+        await Promise.allSettled(
+          [...server._pendingRequests.values()].map(
+            (pending) => pending.request,
+          ),
+        )
+      }
+      server.resolvedUrls = null
+    },
+    printUrls() {
+      if (server.resolvedUrls) {
+        printServerUrls(
+          server.resolvedUrls,
+          serverConfig.host,
+          config.logger.info,
+        )
+      } else if (middlewareMode) {
+        throw new Error('cannot print server URLs in middleware mode.')
+      } else {
+        throw new Error(
+          'cannot print server URLs before server.listen is called.',
+        )
+      }
+    },
+    bindCLIShortcuts(options) {
+      bindCLIShortcuts(server, options)
+    },
+    async restart(forceOptimize?: boolean) {
+      if (!server._restartPromise) {
+        server._forceOptimizeOnRestart = !!forceOptimize
+        server._restartPromise = restartServer(server).finally(() => {
+          server._restartPromise = null
+          server._forceOptimizeOnRestart = false
+        })
+      }
+      return server._restartPromise
+    },
+
+    waitForRequestsIdle,
+    _registerRequestProcessing,
+    _onCrawlEnd,
+
+    _setInternalServer(_server: ViteDevServer) {
+      // Rebind internal the server variable so functions reference the user
+      // server instance after a restart
+      server = _server
+    },
+    _restartPromise: null,
+    _importGlobMap: new Map(),
+    _forceOptimizeOnRestart: false,
+    _pendingRequests: new Map(),
+    _fsDenyGlob: picomatch(
+      // matchBase: true does not work as it's documented
+      // https://github.com/micromatch/picomatch/issues/89
+      // convert patterns without `/` on our side for now
+      config.server.fs.deny.map((pattern) =>
+        pattern.includes('/') ? pattern : `**/${pattern}`,
+      ),
+      {
+        matchBase: false,
+        nocase: true,
+        dot: true,
+      },
+    ),
+    _shortcutsOptions: undefined,
+  }
+
+  // maintain consistency with the server instance after restarting.
+  const reflexServer = new Proxy(server, {
+    get: (_, property: keyof ViteDevServer) => {
+      return server[property]
+    },
+    set: (_, property: keyof ViteDevServer, value: never) => {
+      server[property] = value
+      return true
+    },
+  })
+
+  const closeServerAndExit = async () => {
+    try {
+      await server.close()
+    } finally {
+      process.exit()
+    }
+  }
+
+  if (!middlewareMode) {
+    setupSIGTERMListener(closeServerAndExit)
+  }
+
+  const onHMRUpdate = async (
+    type: 'create' | 'delete' | 'update',
+    file: string,
+  ) => {
+    if (serverConfig.hmr !== false) {
+      try {
+        await handleHMRUpdate(type, file, server)
+      } catch (err) {
+        hot.send({
+          type: 'error',
+          err: prepareError(err),
+        })
+      }
+    }
+  }
+
+  const onFileAddUnlink = async (file: string, isUnlink: boolean) => {
+    file = normalizePath(file)
+    await container.watchChange(file, { event: isUnlink ? 'delete' : 'create' })
+
+    if (publicDir && publicFiles) {
+      if (file.startsWith(publicDir)) {
+        const path = file.slice(publicDir.length)
+        publicFiles[isUnlink ? 'delete' : 'add'](path)
+        if (!isUnlink) {
+          const moduleWithSamePath = await moduleGraph.getModuleByUrl(path)
+          const etag = moduleWithSamePath?.transformResult?.etag
+          if (etag) {
+            // The public file should win on the next request over a module with the
+            // same path. Prevent the transform etag fast path from serving the module
+            moduleGraph.etagToModuleMap.delete(etag)
+          }
+        }
+      }
+    }
+    if (isUnlink) moduleGraph.onFileDelete(file)
+    await onHMRUpdate(isUnlink ? 'delete' : 'create', file)
+  }
+
+  watcher.on('change', async (file) => {
+    file = normalizePath(file)
+    await container.watchChange(file, { event: 'update' })
+    // invalidate module graph cache on file change
+    moduleGraph.onFileChange(file)
+    await onHMRUpdate('update', file)
+  })
+
+  getFsUtils(config).initWatcher?.(watcher)
+
+  watcher.on('add', (file) => {
+    onFileAddUnlink(file, false)
+  })
+  watcher.on('unlink', (file) => {
+    onFileAddUnlink(file, true)
+  })
+
+  hot.on('vite:invalidate', async ({ path, message }) => {
+    const mod = moduleGraph.urlToModuleMap.get(path)
+    if (
+      mod &&
+      mod.isSelfAccepting &&
+      mod.lastHMRTimestamp > 0 &&
+      !mod.lastHMRInvalidationReceived
+    ) {
+      mod.lastHMRInvalidationReceived = true
+      config.logger.info(
+        colors.yellow(`hmr invalidate `) +
+          colors.dim(path) +
+          (message ? ` ${message}` : ''),
+        { timestamp: true },
+      )
+      const file = getShortName(mod.file!, config.root)
+      updateModules(
+        file,
+        [...mod.importers],
+        mod.lastHMRTimestamp,
+        server,
+        true,
+      )
+    }
+  })
+
+  if (!middlewareMode && httpServer) {
+    httpServer.once('listening', () => {
+      // update actual port since this may be different from initial value
+      serverConfig.port = (httpServer.address() as net.AddressInfo).port
+    })
+  }
+
+  // apply server configuration hooks from plugins
+  const postHooks: ((() => void) | void)[] = []
+  for (const hook of config.getSortedPluginHooks('configureServer')) {
+    postHooks.push(await hook(reflexServer))
+  }
+
+  // Internal middlewares ------------------------------------------------------
+
+  // request timer
+  if (process.env.DEBUG) {
+    middlewares.use(timeMiddleware(root))
+  }
+
+  // cors (enabled by default)
+  const { cors } = serverConfig
+  if (cors !== false) {
+    middlewares.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))
+  }
+
+  middlewares.use(cachedTransformMiddleware(server))
+
+  // proxy
+  const { proxy } = serverConfig
+  if (proxy) {
+    const middlewareServer =
+      (isObject(middlewareMode) ? middlewareMode.server : null) || httpServer
+    middlewares.use(proxyMiddleware(middlewareServer, proxy, config))
+  }
+
+  // base
+  if (config.base !== '/') {
+    middlewares.use(baseMiddleware(config.rawBase, !!middlewareMode))
+  }
+
+  // open in editor support
+  middlewares.use('/__open-in-editor', launchEditorMiddleware())
+
+  // ping request handler
+  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
+  middlewares.use(function viteHMRPingMiddleware(req, res, next) {
+    if (req.headers['accept'] === 'text/x-vite-ping') {
+      res.writeHead(204).end()
+    } else {
+      next()
+    }
+  })
+
+  // serve static files under /public
+  // this applies before the transform middleware so that these files are served
+  // as-is without transforms.
+  if (publicDir) {
+    middlewares.use(servePublicMiddleware(server, publicFiles))
+  }
+
+  // main transform middleware
+  middlewares.use(transformMiddleware(server))
+
+  // serve static files
+  middlewares.use(serveRawFsMiddleware(server))
+  middlewares.use(serveStaticMiddleware(server))
+
+  // html fallback
+  if (config.appType === 'spa' || config.appType === 'mpa') {
+    middlewares.use(
+      htmlFallbackMiddleware(
+        root,
+        config.appType === 'spa',
+        getFsUtils(config),
+      ),
+    )
+  }
+
+  // run post config hooks
+  // This is applied before the html middleware so that user middleware can
+  // serve custom content instead of index.html.
+  postHooks.forEach((fn) => fn && fn())
+
+  if (config.appType === 'spa' || config.appType === 'mpa') {
+    // transform index.html
+    middlewares.use(indexHtmlMiddleware(root, server))
+
+    // handle 404s
+    middlewares.use(notFoundMiddleware())
+  }
+
+  // error handler
+  middlewares.use(errorMiddleware(server, !!middlewareMode))
+
+  // httpServer.listen can be called multiple times
+  // when port when using next port number
+  // this code is to avoid calling buildStart multiple times
+  let initingServer: Promise<void> | undefined
+  let serverInited = false
+  const initServer = async () => {
+    if (serverInited) return
+    if (initingServer) return initingServer
+
+    initingServer = (async function () {
+      await container.buildStart({})
+      // start deps optimizer after all container plugins are ready
+      if (isDepsOptimizerEnabled(config, false)) {
+        await initDepsOptimizer(config, server)
+      }
+      warmupFiles(server)
+      initingServer = undefined
+      serverInited = true
+    })()
+    return initingServer
+  }
+
+  if (!middlewareMode && httpServer) {
+    // overwrite listen to init optimizer before server start
+    const listen = httpServer.listen.bind(httpServer)
+    httpServer.listen = (async (port: number, ...args: any[]) => {
+      try {
+        // ensure ws server started
+        hot.listen()
+        await initServer()
+      } catch (e) {
+        httpServer.emit('error', e)
+        return
+      }
+      return listen(port, ...args)
+    }) as any
+  } else {
+    if (options.hotListen) {
+      hot.listen()
+    }
+    await initServer()
+  }
+
+  return server
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/index/resolveServerOptions.ts b/packages/vite/src/node/server/index/resolveServerOptions.ts
new file mode 100644
index 000000000..3ea340399
--- /dev/null
+++ b/packages/vite/src/node/server/index/resolveServerOptions.ts
@@ -0,0 +1,208 @@
+import { execSync } from 'node:child_process'
+import colors from 'picocolors'
+import { isParentDirectory } from 'packages/vite/src/node/utils';
+import { isInNodeModules } from 'packages/vite/src/node/utils';
+import { CLIENT_DIR } from 'packages/vite/src/node/constants';
+import { Logger } from 'packages/vite/src/node/logger';
+import { searchForWorkspaceRoot } from 'packages/vite/src/node/server/searchRoot';
+import type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
+import { CommonServerOptions } from 'packages/vite/src/node/http';
+import { HmrOptions } from 'packages/vite/src/node/server/hmr';
+import type { Http2SecureServer } from 'node:http2'
+import path from 'node:path'
+import { normalizePath } from 'packages/vite/src/node/utils';
+
+
+export interface FileSystemServeOptions {
+  /**
+   * Strictly restrict file accessing outside of allowing paths.
+   *
+   * Set to `false` to disable the warning
+   *
+   * @default true
+   */
+  strict?: boolean
+
+  /**
+   * Restrict accessing files outside the allowed directories.
+   *
+   * Accepts absolute path or a path relative to project root.
+   * Will try to search up for workspace root by default.
+   */
+  allow?: string[]
+
+  /**
+   * Restrict accessing files that matches the patterns.
+   *
+   * This will have higher priority than `allow`.
+   * picomatch patterns are supported.
+   *
+   * @default ['.env', '.env.*', '*.crt', '*.pem']
+   */
+  deny?: string[]
+
+  /**
+   * Enable caching of fs calls. It is enabled by default if no custom watch ignored patterns are provided.
+   *
+   * @experimental
+   * @default undefined
+   */
+  cachedChecks?: boolean
+}
+
+export type HttpServer = http.Server | Http2SecureServer
+
+export interface ServerOptions extends CommonServerOptions {
+  /**
+   * Configure HMR-specific options (port, host, path & protocol)
+   */
+  hmr?: HmrOptions | boolean
+  /**
+   * Do not start the websocket connection.
+   * @experimental
+   */
+  ws?: false
+  /**
+   * Warm-up files to transform and cache the results in advance. This improves the
+   * initial page load during server starts and prevents transform waterfalls.
+   */
+  warmup?: {
+    /**
+     * The files to be transformed and used on the client-side. Supports glob patterns.
+     */
+    clientFiles?: string[]
+    /**
+     * The files to be transformed and used in SSR. Supports glob patterns.
+     */
+    ssrFiles?: string[]
+  }
+  /**
+   * chokidar watch options or null to disable FS watching
+   * https://github.com/paulmillr/chokidar#api
+   */
+  watch?: WatchOptions | null
+  /**
+   * Create Vite dev server to be used as a middleware in an existing server
+   * @default false
+   */
+  middlewareMode?:
+    | boolean
+    | {
+        /**
+         * Parent server instance to attach to
+         *
+         * This is needed to proxy WebSocket connections to the parent server.
+         */
+        server: HttpServer
+      }
+  /**
+   * Options for files served via '/\@fs/'.
+   */
+  fs?: FileSystemServeOptions
+  /**
+   * Origin for the generated asset URLs.
+   *
+   * @example `http://127.0.0.1:8080`
+   */
+  origin?: string
+  /**
+   * Pre-transform known direct imports
+   * @default true
+   */
+  preTransformRequests?: boolean
+  /**
+   * Whether or not to ignore-list source files in the dev server sourcemap, used to populate
+   * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).
+   *
+   * By default, it excludes all paths containing `node_modules`. You can pass `false` to
+   * disable this behavior, or, for full control, a function that takes the source path and
+   * sourcemap path and returns whether to ignore the source path.
+   */
+  sourcemapIgnoreList?:
+    | false
+    | ((sourcePath: string, sourcemapPath: string) => boolean)
+}
+
+export interface ResolvedServerOptions
+  extends Omit<ServerOptions, 'fs' | 'middlewareMode' | 'sourcemapIgnoreList'> {
+  fs: Required<FileSystemServeOptions>
+  middlewareMode: NonNullable<ServerOptions['middlewareMode']>
+  sourcemapIgnoreList: Exclude<
+    ServerOptions['sourcemapIgnoreList'],
+    false | undefined
+  >
+}
+
+export function resolvedAllowDir(root: string, dir: string): string {
+  return normalizePath(path.resolve(root, dir))
+}
+
+export function resolveServerOptions(
+  root: string,
+  raw: ServerOptions | undefined,
+  logger: Logger,
+): ResolvedServerOptions {
+  const server: ResolvedServerOptions = {
+    preTransformRequests: true,
+    ...(raw as Omit<ResolvedServerOptions, 'sourcemapIgnoreList'>),
+    sourcemapIgnoreList:
+      raw?.sourcemapIgnoreList === false
+        ? () => false
+        : raw?.sourcemapIgnoreList || isInNodeModules,
+    middlewareMode: raw?.middlewareMode || false,
+  }
+  let allowDirs = server.fs?.allow
+  const deny = server.fs?.deny || ['.env', '.env.*', '*.{crt,pem}']
+
+  if (!allowDirs) {
+    allowDirs = [searchForWorkspaceRoot(root)]
+  }
+
+  if (process.versions.pnp) {
+    try {
+      const enableGlobalCache =
+        execSync('yarn config get enableGlobalCache', { cwd: root })
+          .toString()
+          .trim() === 'true'
+      const yarnCacheDir = execSync(
+        `yarn config get ${enableGlobalCache ? 'globalFolder' : 'cacheFolder'}`,
+        { cwd: root },
+      )
+        .toString()
+        .trim()
+      allowDirs.push(yarnCacheDir)
+    } catch (e) {
+      logger.warn(`Get yarn cache dir error: ${e.message}`, {
+        timestamp: true,
+      })
+    }
+  }
+
+  allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i))
+
+  // only push client dir when vite itself is outside-of-root
+  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR)
+  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {
+    allowDirs.push(resolvedClientDir)
+  }
+
+  server.fs = {
+    strict: server.fs?.strict ?? true,
+    allow: allowDirs,
+    deny,
+    cachedChecks: server.fs?.cachedChecks,
+  }
+
+  if (server.origin?.endsWith('/')) {
+    server.origin = server.origin.slice(0, -1)
+    logger.warn(
+      colors.yellow(
+        `${colors.bold('(!)')} server.origin should not end with "/". Using "${
+          server.origin
+        }" instead.`,
+      ),
+    )
+  }
+
+  return server
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/index/restartServer.ts b/packages/vite/src/node/server/index/restartServer.ts
new file mode 100644
index 000000000..6094b8105
--- /dev/null
+++ b/packages/vite/src/node/server/index/restartServer.ts
@@ -0,0 +1,878 @@
+import { performance } from 'node:perf_hooks'
+import { mergeConfig } from 'packages/vite/src/node/utils';
+import { bindCLIShortcuts } from 'packages/vite/src/node/shortcuts';
+import type { FSWatcher, WatchOptions } from 'dep-types/chokidar'
+import type { SourceMap } from 'rollup'
+import type { Matcher } from 'picomatch'
+import { ResolvedConfig } from 'packages/vite/src/node/config';
+import { BindCLIShortcutsOptions } from 'packages/vite/src/node/shortcuts';
+import { FetchResult } from 'packages/vite/src/runtime/types';
+import { PluginContainer } from 'packages/vite/src/node/server/pluginContainer';
+import { WebSocketServer } from 'packages/vite/src/node/server/ws';
+import { ModuleNode } from 'packages/vite/src/node/server/moduleGraph';
+import { ModuleGraph } from 'packages/vite/src/node/server/moduleGraph';
+import { HMRBroadcaster } from 'packages/vite/src/node/server/hmr';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest';
+import type { Http2SecureServer } from 'node:http2'
+import connect from 'connect'
+import corsMiddleware from 'cors'
+import colors from 'picocolors'
+import chokidar from 'chokidar'
+import type { Connect } from 'dep-types/connect'
+import launchEditorMiddleware from 'launch-editor-middleware'
+import picomatch from 'picomatch'
+import { setClientErrorHandler } from 'packages/vite/src/node/http';
+import { resolveHttpsConfig } from 'packages/vite/src/node/http';
+import { resolveHttpServer } from 'packages/vite/src/node/http';
+import { InlineConfig } from 'packages/vite/src/node/config';
+import { resolveConfig } from 'packages/vite/src/node/config';
+import { setupSIGTERMListener } from 'packages/vite/src/node/utils';
+import { teardownSIGTERMListener } from 'packages/vite/src/node/utils';
+import { normalizePath } from 'packages/vite/src/node/utils';
+import { isObject } from 'packages/vite/src/node/utils';
+import { getFsUtils } from 'packages/vite/src/node/fsUtils';
+import { ssrLoadModule } from 'packages/vite/src/node/ssr/ssrModuleLoader';
+import { ssrFixStacktrace } from 'packages/vite/src/node/ssr/ssrStacktrace';
+import { ssrRewriteStacktrace } from 'packages/vite/src/node/ssr/ssrStacktrace';
+import { ssrTransform } from 'packages/vite/src/node/ssr/ssrTransform';
+import { ERR_OUTDATED_OPTIMIZED_DEP } from 'packages/vite/src/node/plugins/optimizedDeps';
+import { getDepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { printServerUrls } from 'packages/vite/src/node/logger';
+import { getResolvedOutDirs } from 'packages/vite/src/node/watch';
+import { resolveEmptyOutDir } from 'packages/vite/src/node/watch';
+import { resolveChokidarOptions } from 'packages/vite/src/node/watch';
+import { createNoopWatcher } from 'packages/vite/src/node/watch';
+import { initPublicFiles } from 'packages/vite/src/node/publicDir';
+import { getEnvFilesForMode } from 'packages/vite/src/node/env';
+import { ssrFetchModule } from 'packages/vite/src/node/ssr/ssrFetchModule';
+import { createPluginContainer } from 'packages/vite/src/node/server/pluginContainer';
+import { ERR_CLOSED_SERVER } from 'packages/vite/src/node/server/pluginContainer';
+import { createWebSocketServer } from 'packages/vite/src/node/server/ws';
+import { baseMiddleware } from 'packages/vite/src/node/server/middlewares/base';
+import { proxyMiddleware } from 'packages/vite/src/node/server/middlewares/proxy';
+import { htmlFallbackMiddleware } from 'packages/vite/src/node/server/middlewares/htmlFallback';
+import { cachedTransformMiddleware } from 'packages/vite/src/node/server/middlewares/transform';
+import { transformMiddleware } from 'packages/vite/src/node/server/middlewares/transform';
+import { indexHtmlMiddleware } from 'packages/vite/src/node/server/middlewares/indexHtml';
+import { createDevHtmlTransformFn } from 'packages/vite/src/node/server/middlewares/indexHtml';
+import { servePublicMiddleware } from 'packages/vite/src/node/server/middlewares/static';
+import { serveRawFsMiddleware } from 'packages/vite/src/node/server/middlewares/static';
+import { serveStaticMiddleware } from 'packages/vite/src/node/server/middlewares/static';
+import { timeMiddleware } from 'packages/vite/src/node/server/middlewares/time';
+import { notFoundMiddleware } from 'packages/vite/src/node/server/middlewares/notFound';
+import { errorMiddleware } from 'packages/vite/src/node/server/middlewares/error';
+import { prepareError } from 'packages/vite/src/node/server/middlewares/error';
+import { updateModules } from 'packages/vite/src/node/server/hmr';
+import { createServerHMRChannel } from 'packages/vite/src/node/server/hmr';
+import { createHMRBroadcaster } from 'packages/vite/src/node/server/hmr';
+import { handleHMRUpdate } from 'packages/vite/src/node/server/hmr';
+import { openBrowser as _openBrowser } from 'packages/vite/src/node/server/openBrowser';
+import { transformRequest } from 'packages/vite/src/node/server/transformRequest';
+
+
+export type HttpServer = http.Server | Http2SecureServer
+
+export interface ResolvedServerUrls {
+  local: string[]
+  network: string[]
+}
+
+export interface ViteDevServer {
+  /**
+   * The resolved vite config object
+   */
+  config: ResolvedConfig
+  /**
+   * A connect app instance.
+   * - Can be used to attach custom middlewares to the dev server.
+   * - Can also be used as the handler function of a custom http server
+   *   or as a middleware in any connect-style Node.js frameworks
+   *
+   * https://github.com/senchalabs/connect#use-middleware
+   */
+  middlewares: Connect.Server
+  /**
+   * native Node http server instance
+   * will be null in middleware mode
+   */
+  httpServer: HttpServer | null
+  /**
+   * chokidar watcher instance
+   * https://github.com/paulmillr/chokidar#api
+   */
+  watcher: FSWatcher
+  /**
+   * web socket server with `send(payload)` method
+   */
+  ws: WebSocketServer
+  /**
+   * HMR broadcaster that can be used to send custom HMR messages to the client
+   *
+   * Always sends a message to at least a WebSocket client. Any third party can
+   * add a channel to the broadcaster to process messages
+   * @deprecated will be replaced with the environment api in v6.
+   */
+  hot: HMRBroadcaster
+  /**
+   * Rollup plugin container that can run plugin hooks on a given file
+   */
+  pluginContainer: PluginContainer
+  /**
+   * Module graph that tracks the import relationships, url to file mapping
+   * and hmr state.
+   */
+  moduleGraph: ModuleGraph
+  /**
+   * The resolved urls Vite prints on the CLI. null in middleware mode or
+   * before `server.listen` is called.
+   */
+  resolvedUrls: ResolvedServerUrls | null
+  /**
+   * Programmatically resolve, load and transform a URL and get the result
+   * without going through the http request pipeline.
+   */
+  transformRequest(
+    url: string,
+    options?: TransformOptions,
+  ): Promise<TransformResult | null>
+  /**
+   * Same as `transformRequest` but only warm up the URLs so the next request
+   * will already be cached. The function will never throw as it handles and
+   * reports errors internally.
+   */
+  warmupRequest(url: string, options?: TransformOptions): Promise<void>
+  /**
+   * Apply vite built-in HTML transforms and any plugin HTML transforms.
+   */
+  transformIndexHtml(
+    url: string,
+    html: string,
+    originalUrl?: string,
+  ): Promise<string>
+  /**
+   * Transform module code into SSR format.
+   */
+  ssrTransform(
+    code: string,
+    inMap: SourceMap | { mappings: '' } | null,
+    url: string,
+    originalCode?: string,
+  ): Promise<TransformResult | null>
+  /**
+   * Load a given URL as an instantiated module for SSR.
+   */
+  ssrLoadModule(
+    url: string,
+    opts?: { fixStacktrace?: boolean },
+  ): Promise<Record<string, any>>
+  /**
+   * Fetch information about the module for Vite SSR runtime.
+   * @experimental
+   */
+  ssrFetchModule(id: string, importer?: string): Promise<FetchResult>
+  /**
+   * Returns a fixed version of the given stack
+   */
+  ssrRewriteStacktrace(stack: string): string
+  /**
+   * Mutates the given SSR error by rewriting the stacktrace
+   */
+  ssrFixStacktrace(e: Error): void
+  /**
+   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`
+   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.
+   */
+  reloadModule(module: ModuleNode): Promise<void>
+  /**
+   * Start the server.
+   */
+  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
+  /**
+   * Stop the server.
+   */
+  close(): Promise<void>
+  /**
+   * Print server urls
+   */
+  printUrls(): void
+  /**
+   * Bind CLI shortcuts
+   */
+  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
+  /**
+   * Restart the server.
+   *
+   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
+   */
+  restart(forceOptimize?: boolean): Promise<void>
+
+  /**
+   * Open browser
+   */
+  openBrowser(): void
+  /**
+   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports
+   * are processed. If called from a load or transform plugin hook, the id needs to be
+   * passed as a parameter to avoid deadlocks. Calling this function after the first
+   * static imports section of the module graph has been processed will resolve immediately.
+   * @experimental
+   */
+  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
+  /**
+   * @internal
+   */
+  _registerRequestProcessing: (id: string, done: () => Promise<unknown>) => void
+  /**
+   * @internal
+   */
+  _onCrawlEnd(cb: () => void): void
+  /**
+   * @internal
+   */
+  _setInternalServer(server: ViteDevServer): void
+  /**
+   * @internal
+   */
+  _importGlobMap: Map<string, { affirmed: string[]; negated: string[] }[]>
+  /**
+   * @internal
+   */
+  _restartPromise: Promise<void> | null
+  /**
+   * @internal
+   */
+  _forceOptimizeOnRestart: boolean
+  /**
+   * @internal
+   */
+  _pendingRequests: Map<
+    string,
+    {
+      request: Promise<TransformResult | null>
+      timestamp: number
+      abort: () => void
+    }
+  >
+  /**
+   * @internal
+   */
+  _fsDenyGlob: Matcher
+  /**
+   * @internal
+   */
+  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>
+  /**
+   * @internal
+   */
+  _currentServerPort?: number | undefined
+  /**
+   * @internal
+   */
+  _configServerPort?: number | undefined
+}
+
+export async function _createServer(
+  inlineConfig: InlineConfig = {},
+  options: { hotListen: boolean },
+): Promise<ViteDevServer> {
+  const config = await resolveConfig(inlineConfig, 'serve')
+
+  const initPublicFilesPromise = initPublicFiles(config)
+
+  const { root, server: serverConfig } = config
+  const httpsOptions = await resolveHttpsConfig(config.server.https)
+  const { middlewareMode } = serverConfig
+
+  const resolvedOutDirs = getResolvedOutDirs(
+    config.root,
+    config.build.outDir,
+    config.build.rollupOptions?.output,
+  )
+  const emptyOutDir = resolveEmptyOutDir(
+    config.build.emptyOutDir,
+    config.root,
+    resolvedOutDirs,
+  )
+  const resolvedWatchOptions = resolveChokidarOptions(
+    config,
+    {
+      disableGlobbing: true,
+      ...serverConfig.watch,
+    },
+    resolvedOutDirs,
+    emptyOutDir,
+  )
+
+  const middlewares = connect() as Connect.Server
+  const httpServer = middlewareMode
+    ? null
+    : await resolveHttpServer(serverConfig, middlewares, httpsOptions)
+
+  const ws = createWebSocketServer(httpServer, config, httpsOptions)
+  const hot = createHMRBroadcaster()
+    .addChannel(ws)
+    .addChannel(createServerHMRChannel())
+  if (typeof config.server.hmr === 'object' && config.server.hmr.channels) {
+    config.server.hmr.channels.forEach((channel) => hot.addChannel(channel))
+  }
+
+  const publicFiles = await initPublicFilesPromise
+  const { publicDir } = config
+
+  if (httpServer) {
+    setClientErrorHandler(httpServer, config.logger)
+  }
+
+  // eslint-disable-next-line eqeqeq
+  const watchEnabled = serverConfig.watch !== null
+  const watcher = watchEnabled
+    ? (chokidar.watch(
+        // config file dependencies and env file might be outside of root
+        [
+          root,
+          ...config.configFileDependencies,
+          ...getEnvFilesForMode(config.mode, config.envDir),
+          // Watch the public directory explicitly because it might be outside
+          // of the root directory.
+          ...(publicDir && publicFiles ? [publicDir] : []),
+        ],
+        resolvedWatchOptions,
+      ) as FSWatcher)
+    : createNoopWatcher(resolvedWatchOptions)
+
+  const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>
+    container.resolveId(url, undefined, { ssr }),
+  )
+
+  const container = await createPluginContainer(config, moduleGraph, watcher)
+  const closeHttpServer = createServerCloseFn(httpServer)
+
+  const devHtmlTransformFn = createDevHtmlTransformFn(config)
+
+  const onCrawlEndCallbacks: (() => void)[] = []
+  const crawlEndFinder = setupOnCrawlEnd(() => {
+    onCrawlEndCallbacks.forEach((cb) => cb())
+  })
+  function waitForRequestsIdle(ignoredId?: string): Promise<void> {
+    return crawlEndFinder.waitForRequestsIdle(ignoredId)
+  }
+  function _registerRequestProcessing(id: string, done: () => Promise<any>) {
+    crawlEndFinder.registerRequestProcessing(id, done)
+  }
+  function _onCrawlEnd(cb: () => void) {
+    onCrawlEndCallbacks.push(cb)
+  }
+
+  let server: ViteDevServer = {
+    config,
+    middlewares,
+    httpServer,
+    watcher,
+    pluginContainer: container,
+    ws,
+    hot,
+    moduleGraph,
+    resolvedUrls: null, // will be set on listen
+    ssrTransform(
+      code: string,
+      inMap: SourceMap | { mappings: '' } | null,
+      url: string,
+      originalCode = code,
+    ) {
+      return ssrTransform(code, inMap, url, originalCode, server.config)
+    },
+    transformRequest(url, options) {
+      return transformRequest(url, server, options)
+    },
+    async warmupRequest(url, options) {
+      try {
+        await transformRequest(url, server, options)
+      } catch (e) {
+        if (
+          e?.code === ERR_OUTDATED_OPTIMIZED_DEP ||
+          e?.code === ERR_CLOSED_SERVER
+        ) {
+          // these are expected errors
+          return
+        }
+        // Unexpected error, log the issue but avoid an unhandled exception
+        server.config.logger.error(`Pre-transform error: ${e.message}`, {
+          error: e,
+          timestamp: true,
+        })
+      }
+    },
+    transformIndexHtml(url, html, originalUrl) {
+      return devHtmlTransformFn(server, url, html, originalUrl)
+    },
+    async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {
+      return ssrLoadModule(url, server, undefined, opts?.fixStacktrace)
+    },
+    async ssrFetchModule(url: string, importer?: string) {
+      return ssrFetchModule(server, url, importer)
+    },
+    ssrFixStacktrace(e) {
+      ssrFixStacktrace(e, moduleGraph)
+    },
+    ssrRewriteStacktrace(stack: string) {
+      return ssrRewriteStacktrace(stack, moduleGraph)
+    },
+    async reloadModule(module) {
+      if (serverConfig.hmr !== false && module.file) {
+        updateModules(module.file, [module], Date.now(), server)
+      }
+    },
+    async listen(port?: number, isRestart?: boolean) {
+      await startServer(server, port)
+      if (httpServer) {
+        server.resolvedUrls = await resolveServerUrls(
+          httpServer,
+          config.server,
+          config,
+        )
+        if (!isRestart && config.server.open) server.openBrowser()
+      }
+      return server
+    },
+    openBrowser() {
+      const options = server.config.server
+      const url =
+        server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0]
+      if (url) {
+        const path =
+          typeof options.open === 'string'
+            ? new URL(options.open, url).href
+            : url
+
+        // We know the url that the browser would be opened to, so we can
+        // start the request while we are awaiting the browser. This will
+        // start the crawling of static imports ~500ms before.
+        // preTransformRequests needs to be enabled for this optimization.
+        if (server.config.server.preTransformRequests) {
+          setTimeout(() => {
+            const getMethod = path.startsWith('https:') ? httpsGet : httpGet
+
+            getMethod(
+              path,
+              {
+                headers: {
+                  // Allow the history middleware to redirect to /index.html
+                  Accept: 'text/html',
+                },
+              },
+              (res) => {
+                res.on('end', () => {
+                  // Ignore response, scripts discovered while processing the entry
+                  // will be preprocessed (server.config.server.preTransformRequests)
+                })
+              },
+            )
+              .on('error', () => {
+                // Ignore errors
+              })
+              .end()
+          }, 0)
+        }
+
+        _openBrowser(path, true, server.config.logger)
+      } else {
+        server.config.logger.warn('No URL available to open in browser')
+      }
+    },
+    async close() {
+      if (!middlewareMode) {
+        teardownSIGTERMListener(closeServerAndExit)
+      }
+      await Promise.allSettled([
+        watcher.close(),
+        hot.close(),
+        container.close(),
+        crawlEndFinder?.cancel(),
+        getDepsOptimizer(server.config)?.close(),
+        getDepsOptimizer(server.config, true)?.close(),
+        closeHttpServer(),
+      ])
+      // Await pending requests. We throw early in transformRequest
+      // and in hooks if the server is closing for non-ssr requests,
+      // so the import analysis plugin stops pre-transforming static
+      // imports and this block is resolved sooner.
+      // During SSR, we let pending requests finish to avoid exposing
+      // the server closed error to the users.
+      while (server._pendingRequests.size > 0) {
+        await Promise.allSettled(
+          [...server._pendingRequests.values()].map(
+            (pending) => pending.request,
+          ),
+        )
+      }
+      server.resolvedUrls = null
+    },
+    printUrls() {
+      if (server.resolvedUrls) {
+        printServerUrls(
+          server.resolvedUrls,
+          serverConfig.host,
+          config.logger.info,
+        )
+      } else if (middlewareMode) {
+        throw new Error('cannot print server URLs in middleware mode.')
+      } else {
+        throw new Error(
+          'cannot print server URLs before server.listen is called.',
+        )
+      }
+    },
+    bindCLIShortcuts(options) {
+      bindCLIShortcuts(server, options)
+    },
+    async restart(forceOptimize?: boolean) {
+      if (!server._restartPromise) {
+        server._forceOptimizeOnRestart = !!forceOptimize
+        server._restartPromise = restartServer(server).finally(() => {
+          server._restartPromise = null
+          server._forceOptimizeOnRestart = false
+        })
+      }
+      return server._restartPromise
+    },
+
+    waitForRequestsIdle,
+    _registerRequestProcessing,
+    _onCrawlEnd,
+
+    _setInternalServer(_server: ViteDevServer) {
+      // Rebind internal the server variable so functions reference the user
+      // server instance after a restart
+      server = _server
+    },
+    _restartPromise: null,
+    _importGlobMap: new Map(),
+    _forceOptimizeOnRestart: false,
+    _pendingRequests: new Map(),
+    _fsDenyGlob: picomatch(
+      // matchBase: true does not work as it's documented
+      // https://github.com/micromatch/picomatch/issues/89
+      // convert patterns without `/` on our side for now
+      config.server.fs.deny.map((pattern) =>
+        pattern.includes('/') ? pattern : `**/${pattern}`,
+      ),
+      {
+        matchBase: false,
+        nocase: true,
+        dot: true,
+      },
+    ),
+    _shortcutsOptions: undefined,
+  }
+
+  // maintain consistency with the server instance after restarting.
+  const reflexServer = new Proxy(server, {
+    get: (_, property: keyof ViteDevServer) => {
+      return server[property]
+    },
+    set: (_, property: keyof ViteDevServer, value: never) => {
+      server[property] = value
+      return true
+    },
+  })
+
+  const closeServerAndExit = async () => {
+    try {
+      await server.close()
+    } finally {
+      process.exit()
+    }
+  }
+
+  if (!middlewareMode) {
+    setupSIGTERMListener(closeServerAndExit)
+  }
+
+  const onHMRUpdate = async (
+    type: 'create' | 'delete' | 'update',
+    file: string,
+  ) => {
+    if (serverConfig.hmr !== false) {
+      try {
+        await handleHMRUpdate(type, file, server)
+      } catch (err) {
+        hot.send({
+          type: 'error',
+          err: prepareError(err),
+        })
+      }
+    }
+  }
+
+  const onFileAddUnlink = async (file: string, isUnlink: boolean) => {
+    file = normalizePath(file)
+    await container.watchChange(file, { event: isUnlink ? 'delete' : 'create' })
+
+    if (publicDir && publicFiles) {
+      if (file.startsWith(publicDir)) {
+        const path = file.slice(publicDir.length)
+        publicFiles[isUnlink ? 'delete' : 'add'](path)
+        if (!isUnlink) {
+          const moduleWithSamePath = await moduleGraph.getModuleByUrl(path)
+          const etag = moduleWithSamePath?.transformResult?.etag
+          if (etag) {
+            // The public file should win on the next request over a module with the
+            // same path. Prevent the transform etag fast path from serving the module
+            moduleGraph.etagToModuleMap.delete(etag)
+          }
+        }
+      }
+    }
+    if (isUnlink) moduleGraph.onFileDelete(file)
+    await onHMRUpdate(isUnlink ? 'delete' : 'create', file)
+  }
+
+  watcher.on('change', async (file) => {
+    file = normalizePath(file)
+    await container.watchChange(file, { event: 'update' })
+    // invalidate module graph cache on file change
+    moduleGraph.onFileChange(file)
+    await onHMRUpdate('update', file)
+  })
+
+  getFsUtils(config).initWatcher?.(watcher)
+
+  watcher.on('add', (file) => {
+    onFileAddUnlink(file, false)
+  })
+  watcher.on('unlink', (file) => {
+    onFileAddUnlink(file, true)
+  })
+
+  hot.on('vite:invalidate', async ({ path, message }) => {
+    const mod = moduleGraph.urlToModuleMap.get(path)
+    if (
+      mod &&
+      mod.isSelfAccepting &&
+      mod.lastHMRTimestamp > 0 &&
+      !mod.lastHMRInvalidationReceived
+    ) {
+      mod.lastHMRInvalidationReceived = true
+      config.logger.info(
+        colors.yellow(`hmr invalidate `) +
+          colors.dim(path) +
+          (message ? ` ${message}` : ''),
+        { timestamp: true },
+      )
+      const file = getShortName(mod.file!, config.root)
+      updateModules(
+        file,
+        [...mod.importers],
+        mod.lastHMRTimestamp,
+        server,
+        true,
+      )
+    }
+  })
+
+  if (!middlewareMode && httpServer) {
+    httpServer.once('listening', () => {
+      // update actual port since this may be different from initial value
+      serverConfig.port = (httpServer.address() as net.AddressInfo).port
+    })
+  }
+
+  // apply server configuration hooks from plugins
+  const postHooks: ((() => void) | void)[] = []
+  for (const hook of config.getSortedPluginHooks('configureServer')) {
+    postHooks.push(await hook(reflexServer))
+  }
+
+  // Internal middlewares ------------------------------------------------------
+
+  // request timer
+  if (process.env.DEBUG) {
+    middlewares.use(timeMiddleware(root))
+  }
+
+  // cors (enabled by default)
+  const { cors } = serverConfig
+  if (cors !== false) {
+    middlewares.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))
+  }
+
+  middlewares.use(cachedTransformMiddleware(server))
+
+  // proxy
+  const { proxy } = serverConfig
+  if (proxy) {
+    const middlewareServer =
+      (isObject(middlewareMode) ? middlewareMode.server : null) || httpServer
+    middlewares.use(proxyMiddleware(middlewareServer, proxy, config))
+  }
+
+  // base
+  if (config.base !== '/') {
+    middlewares.use(baseMiddleware(config.rawBase, !!middlewareMode))
+  }
+
+  // open in editor support
+  middlewares.use('/__open-in-editor', launchEditorMiddleware())
+
+  // ping request handler
+  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`
+  middlewares.use(function viteHMRPingMiddleware(req, res, next) {
+    if (req.headers['accept'] === 'text/x-vite-ping') {
+      res.writeHead(204).end()
+    } else {
+      next()
+    }
+  })
+
+  // serve static files under /public
+  // this applies before the transform middleware so that these files are served
+  // as-is without transforms.
+  if (publicDir) {
+    middlewares.use(servePublicMiddleware(server, publicFiles))
+  }
+
+  // main transform middleware
+  middlewares.use(transformMiddleware(server))
+
+  // serve static files
+  middlewares.use(serveRawFsMiddleware(server))
+  middlewares.use(serveStaticMiddleware(server))
+
+  // html fallback
+  if (config.appType === 'spa' || config.appType === 'mpa') {
+    middlewares.use(
+      htmlFallbackMiddleware(
+        root,
+        config.appType === 'spa',
+        getFsUtils(config),
+      ),
+    )
+  }
+
+  // run post config hooks
+  // This is applied before the html middleware so that user middleware can
+  // serve custom content instead of index.html.
+  postHooks.forEach((fn) => fn && fn())
+
+  if (config.appType === 'spa' || config.appType === 'mpa') {
+    // transform index.html
+    middlewares.use(indexHtmlMiddleware(root, server))
+
+    // handle 404s
+    middlewares.use(notFoundMiddleware())
+  }
+
+  // error handler
+  middlewares.use(errorMiddleware(server, !!middlewareMode))
+
+  // httpServer.listen can be called multiple times
+  // when port when using next port number
+  // this code is to avoid calling buildStart multiple times
+  let initingServer: Promise<void> | undefined
+  let serverInited = false
+  const initServer = async () => {
+    if (serverInited) return
+    if (initingServer) return initingServer
+
+    initingServer = (async function () {
+      await container.buildStart({})
+      // start deps optimizer after all container plugins are ready
+      if (isDepsOptimizerEnabled(config, false)) {
+        await initDepsOptimizer(config, server)
+      }
+      warmupFiles(server)
+      initingServer = undefined
+      serverInited = true
+    })()
+    return initingServer
+  }
+
+  if (!middlewareMode && httpServer) {
+    // overwrite listen to init optimizer before server start
+    const listen = httpServer.listen.bind(httpServer)
+    httpServer.listen = (async (port: number, ...args: any[]) => {
+      try {
+        // ensure ws server started
+        hot.listen()
+        await initServer()
+      } catch (e) {
+        httpServer.emit('error', e)
+        return
+      }
+      return listen(port, ...args)
+    }) as any
+  } else {
+    if (options.hotListen) {
+      hot.listen()
+    }
+    await initServer()
+  }
+
+  return server
+}
+
+export async function restartServer(server: ViteDevServer) {
+  global.__vite_start_time = performance.now()
+  const shortcutsOptions = server._shortcutsOptions
+
+  let inlineConfig = server.config.inlineConfig
+  if (server._forceOptimizeOnRestart) {
+    inlineConfig = mergeConfig(inlineConfig, {
+      optimizeDeps: {
+        force: true,
+      },
+    })
+  }
+
+  // Reinit the server by creating a new instance using the same inlineConfig
+  // This will trigger a reload of the config file and re-create the plugins and
+  // middlewares. We then assign all properties of the new server to the existing
+  // server instance and set the user instance to be used in the new server.
+  // This allows us to keep the same server instance for the user.
+  {
+    let newServer = null
+    try {
+      // delay ws server listen
+      newServer = await _createServer(inlineConfig, { hotListen: false })
+    } catch (err: any) {
+      server.config.logger.error(err.message, {
+        timestamp: true,
+      })
+      server.config.logger.error('server restart failed', { timestamp: true })
+      return
+    }
+
+    await server.close()
+
+    // Assign new server props to existing server instance
+    const middlewares = server.middlewares
+    newServer._configServerPort = server._configServerPort
+    newServer._currentServerPort = server._currentServerPort
+    Object.assign(server, newServer)
+
+    // Keep the same connect instance so app.use(vite.middlewares) works
+    // after a restart in middlewareMode (.route is always '/')
+    middlewares.stack = newServer.middlewares.stack
+    server.middlewares = middlewares
+
+    // Rebind internal server variable so functions reference the user server
+    newServer._setInternalServer(server)
+  }
+
+  const {
+    logger,
+    server: { port, middlewareMode },
+  } = server.config
+  if (!middlewareMode) {
+    await server.listen(port, true)
+  } else {
+    server.hot.listen()
+  }
+  logger.info('server restarted.', { timestamp: true })
+
+  if (shortcutsOptions) {
+    shortcutsOptions.print = false
+    bindCLIShortcuts(server, shortcutsOptions)
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/index/setupOnCrawlEnd.ts b/packages/vite/src/node/server/index/setupOnCrawlEnd.ts
new file mode 100644
index 000000000..8110f667b
--- /dev/null
+++ b/packages/vite/src/node/server/index/setupOnCrawlEnd.ts
@@ -0,0 +1,80 @@
+import { promiseWithResolvers } from 'packages/vite/src/node/utils';
+
+
+const export callCrawlEndIfIdleAfterMs = 50
+
+export interface CrawlEndFinder {
+  registerRequestProcessing: (id: string, done: () => Promise<any>) => void
+  waitForRequestsIdle: (ignoredId?: string) => Promise<void>
+  cancel: () => void
+}
+
+export function setupOnCrawlEnd(onCrawlEnd: () => void): CrawlEndFinder {
+  const registeredIds = new Set<string>()
+  const seenIds = new Set<string>()
+  const onCrawlEndPromiseWithResolvers = promiseWithResolvers<void>()
+
+  let timeoutHandle: NodeJS.Timeout | undefined
+
+  let cancelled = false
+  function cancel() {
+    cancelled = true
+  }
+
+  let crawlEndCalled = false
+  function callOnCrawlEnd() {
+    if (!cancelled && !crawlEndCalled) {
+      crawlEndCalled = true
+      onCrawlEnd()
+    }
+    onCrawlEndPromiseWithResolvers.resolve()
+  }
+
+  function registerRequestProcessing(
+    id: string,
+    done: () => Promise<any>,
+  ): void {
+    if (!seenIds.has(id)) {
+      seenIds.add(id)
+      registeredIds.add(id)
+      done()
+        .catch(() => {})
+        .finally(() => markIdAsDone(id))
+    }
+  }
+
+  function waitForRequestsIdle(ignoredId?: string): Promise<void> {
+    if (ignoredId) {
+      seenIds.add(ignoredId)
+      markIdAsDone(ignoredId)
+    }
+    return onCrawlEndPromiseWithResolvers.promise
+  }
+
+  function markIdAsDone(id: string): void {
+    if (registeredIds.has(id)) {
+      registeredIds.delete(id)
+      checkIfCrawlEndAfterTimeout()
+    }
+  }
+
+  function checkIfCrawlEndAfterTimeout() {
+    if (cancelled || registeredIds.size > 0) return
+
+    if (timeoutHandle) clearTimeout(timeoutHandle)
+    timeoutHandle = setTimeout(
+      callOnCrawlEndWhenIdle,
+      callCrawlEndIfIdleAfterMs,
+    )
+  }
+  async function callOnCrawlEndWhenIdle() {
+    if (cancelled || registeredIds.size > 0) return
+    callOnCrawlEnd()
+  }
+
+  return {
+    registerRequestProcessing,
+    waitForRequestsIdle,
+    cancel,
+  }
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/middlewares/indexHtml.ts b/packages/vite/src/node/server/middlewares/indexHtml.ts
index f47811371..5313273f2 100644
--- a/packages/vite/src/node/server/middlewares/indexHtml.ts
+++ b/packages/vite/src/node/server/middlewares/indexHtml.ts
@@ -1,3 +1,6 @@
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
 import fsp from 'node:fs/promises'
 import path from 'node:path'
 import MagicString from 'magic-string'
@@ -41,7 +44,6 @@ import {
 } from '../../utils'
 import { getFsUtils } from '../../fsUtils'
 import { checkPublicFile } from '../../publicDir'
-import { isCSSRequest } from '../../plugins/css'
 import { getCodeWithSourcemap, injectSourcesContent } from '../sourcemap'
 import { cleanUrl, unwrapId, wrapId } from '../../../shared/utils'
 
diff --git a/packages/vite/src/node/server/middlewares/proxy.ts b/packages/vite/src/node/server/middlewares/proxy.ts
index 17f6d7a23..44afb7722 100644
--- a/packages/vite/src/node/server/middlewares/proxy.ts
+++ b/packages/vite/src/node/server/middlewares/proxy.ts
@@ -1,3 +1,8 @@
+import { HttpServer } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/_createServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/restartServer';
 import type * as http from 'node:http'
 import type * as net from 'node:net'
 import httpProxy from 'http-proxy'
@@ -6,7 +11,6 @@ import type { HttpProxy } from 'dep-types/http-proxy'
 import colors from 'picocolors'
 import { createDebugger } from '../../utils'
 import type { CommonServerOptions, ResolvedConfig } from '../..'
-import type { HttpServer } from '..'
 
 const debug = createDebugger('vite:proxy')
 
diff --git a/packages/vite/src/node/server/middlewares/transform.ts b/packages/vite/src/node/server/middlewares/transform.ts
index 12a440d4c..9b088d2d3 100644
--- a/packages/vite/src/node/server/middlewares/transform.ts
+++ b/packages/vite/src/node/server/middlewares/transform.ts
@@ -1,9 +1,17 @@
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isDirectCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { isCSSRequest } from 'packages/vite/src/node/plugins/css/cssAnalysisPlugin';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
+import { transformRequest } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { ERR_LOAD_URL } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
 import path from 'node:path'
 import fsp from 'node:fs/promises'
 import type { Connect } from 'dep-types/connect'
 import colors from 'picocolors'
 import type { ExistingRawSourceMap } from 'rollup'
-import type { ViteDevServer } from '..'
 import {
   createDebugger,
   fsPathFromId,
@@ -17,15 +25,9 @@ import {
   urlRE,
 } from '../../utils'
 import { send } from '../send'
-import { ERR_LOAD_URL, transformRequest } from '../transformRequest'
 import { applySourcemapIgnoreList } from '../sourcemap'
 import { isHTMLProxy } from '../../plugins/html'
 import { DEP_VERSION_RE, FS_PREFIX } from '../../constants'
-import {
-  isCSSRequest,
-  isDirectCSSRequest,
-  isDirectRequest,
-} from '../../plugins/css'
 import {
   ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR,
   ERR_OPTIMIZE_DEPS_PROCESSING_ERROR,
diff --git a/packages/vite/src/node/server/moduleGraph.ts b/packages/vite/src/node/server/moduleGraph.ts
index 442ece308..773008a9c 100644
--- a/packages/vite/src/node/server/moduleGraph.ts
+++ b/packages/vite/src/node/server/moduleGraph.ts
@@ -1,6 +1,9 @@
+import { isDirectCSSRequest } from 'packages/vite/src/node/plugins/css/cssPostPlugin';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation';
 import { extname } from 'node:path'
 import type { ModuleInfo, PartialResolvedId } from 'rollup'
-import { isDirectCSSRequest } from '../plugins/css'
 import {
   normalizePath,
   removeImportQuery,
@@ -8,7 +11,6 @@ import {
 } from '../utils'
 import { FS_PREFIX } from '../constants'
 import { cleanUrl } from '../../shared/utils'
-import type { TransformResult } from './transformRequest'
 
 export class ModuleNode {
   /**
diff --git a/packages/vite/src/node/server/pluginContainer.ts b/packages/vite/src/node/server/pluginContainer.ts
index 3251790d1..e3122cf47 100644
--- a/packages/vite/src/node/server/pluginContainer.ts
+++ b/packages/vite/src/node/server/pluginContainer.ts
@@ -29,6 +29,8 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
 
+import { PluginHookUtils } from 'packages/vite/src/node/config/resolveConfig';
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import fs from 'node:fs'
 import { join } from 'node:path'
 import { performance } from 'node:perf_hooks'
@@ -77,7 +79,6 @@ import {
   timeFrom,
 } from '../utils'
 import { FS_PREFIX } from '../constants'
-import type { PluginHookUtils, ResolvedConfig } from '../config'
 import { createPluginHookUtils, getHookHandler } from '../plugins'
 import { cleanUrl, unwrapId } from '../../shared/utils'
 import { buildErrorMessage } from './middlewares/error'
diff --git a/packages/vite/src/node/server/transformRequest.ts b/packages/vite/src/node/server/transformRequest.ts
index dc98c1795..665002a2c 100644
--- a/packages/vite/src/node/server/transformRequest.ts
+++ b/packages/vite/src/node/server/transformRequest.ts
@@ -1,3 +1,20 @@
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { transformRequest } from 'packages/vite/src/node/server/transformRequest';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/doTransform';
+import { doTransform } from 'packages/vite/src/node/server/transformRequest/doTransform';
+import { doTransform } from 'packages/vite/src/node/server/transformRequest';
+import { ERR_LOAD_URL } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { ERR_LOAD_PUBLIC_URL } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { debugLoad } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { debugTransform } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformOptions } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { loadAndTransform } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { loadAndTransform } from 'packages/vite/src/node/server/transformRequest';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation';
+import { handleModuleSoftInvalidation } from 'packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation';
+import { handleModuleSoftInvalidation } from 'packages/vite/src/node/server/transformRequest';
 import fsp from 'node:fs/promises'
 import path from 'node:path'
 import { performance } from 'node:perf_hooks'
@@ -29,173 +46,8 @@ import {
 } from './sourcemap'
 import { isFileServingAllowed } from './middlewares/static'
 import { throwClosedServerError } from './pluginContainer'
-
-export const ERR_LOAD_URL = 'ERR_LOAD_URL'
-export const ERR_LOAD_PUBLIC_URL = 'ERR_LOAD_PUBLIC_URL'
-
-const debugLoad = createDebugger('vite:load')
-const debugTransform = createDebugger('vite:transform')
 const debugCache = createDebugger('vite:cache')
 
-export interface TransformResult {
-  code: string
-  map: SourceMap | { mappings: '' } | null
-  etag?: string
-  deps?: string[]
-  dynamicDeps?: string[]
-}
-
-export interface TransformOptions {
-  ssr?: boolean
-  html?: boolean
-}
-
-export function transformRequest(
-  url: string,
-  server: ViteDevServer,
-  options: TransformOptions = {},
-): Promise<TransformResult | null> {
-  if (server._restartPromise && !options.ssr) throwClosedServerError()
-
-  const cacheKey = (options.ssr ? 'ssr:' : options.html ? 'html:' : '') + url
-
-  // This module may get invalidated while we are processing it. For example
-  // when a full page reload is needed after the re-processing of pre-bundled
-  // dependencies when a missing dep is discovered. We save the current time
-  // to compare it to the last invalidation performed to know if we should
-  // cache the result of the transformation or we should discard it as stale.
-  //
-  // A module can be invalidated due to:
-  // 1. A full reload because of pre-bundling newly discovered deps
-  // 2. A full reload after a config change
-  // 3. The file that generated the module changed
-  // 4. Invalidation for a virtual module
-  //
-  // For 1 and 2, a new request for this module will be issued after
-  // the invalidation as part of the browser reloading the page. For 3 and 4
-  // there may not be a new request right away because of HMR handling.
-  // In all cases, the next time this module is requested, it should be
-  // re-processed.
-  //
-  // We save the timestamp when we start processing and compare it with the
-  // last time this module is invalidated
-  const timestamp = Date.now()
-
-  const pending = server._pendingRequests.get(cacheKey)
-  if (pending) {
-    return server.moduleGraph
-      .getModuleByUrl(removeTimestampQuery(url), options.ssr)
-      .then((module) => {
-        if (!module || pending.timestamp > module.lastInvalidationTimestamp) {
-          // The pending request is still valid, we can safely reuse its result
-          return pending.request
-        } else {
-          // Request 1 for module A     (pending.timestamp)
-          // Invalidate module A        (module.lastInvalidationTimestamp)
-          // Request 2 for module A     (timestamp)
-
-          // First request has been invalidated, abort it to clear the cache,
-          // then perform a new doTransform.
-          pending.abort()
-          return transformRequest(url, server, options)
-        }
-      })
-  }
-
-  const request = doTransform(url, server, options, timestamp)
-
-  // Avoid clearing the cache of future requests if aborted
-  let cleared = false
-  const clearCache = () => {
-    if (!cleared) {
-      server._pendingRequests.delete(cacheKey)
-      cleared = true
-    }
-  }
-
-  // Cache the request and clear it once processing is done
-  server._pendingRequests.set(cacheKey, {
-    request,
-    timestamp,
-    abort: clearCache,
-  })
-
-  return request.finally(clearCache)
-}
-
-async function doTransform(
-  url: string,
-  server: ViteDevServer,
-  options: TransformOptions,
-  timestamp: number,
-) {
-  url = removeTimestampQuery(url)
-
-  const { config, pluginContainer } = server
-  const ssr = !!options.ssr
-
-  if (ssr && isDepsOptimizerEnabled(config, true)) {
-    await initDevSsrDepsOptimizer(config, server)
-  }
-
-  let module = await server.moduleGraph.getModuleByUrl(url, ssr)
-  if (module) {
-    // try use cache from url
-    const cached = await getCachedTransformResult(
-      url,
-      module,
-      server,
-      ssr,
-      timestamp,
-    )
-    if (cached) return cached
-  }
-
-  const resolved = module
-    ? undefined
-    : ((await pluginContainer.resolveId(url, undefined, { ssr })) ?? undefined)
-
-  // resolve
-  const id = module?.id ?? resolved?.id ?? url
-
-  module ??= server.moduleGraph.getModuleById(id)
-  if (module) {
-    // if a different url maps to an existing loaded id,  make sure we relate this url to the id
-    await server.moduleGraph._ensureEntryFromUrl(url, ssr, undefined, resolved)
-    // try use cache from id
-    const cached = await getCachedTransformResult(
-      url,
-      module,
-      server,
-      ssr,
-      timestamp,
-    )
-    if (cached) return cached
-  }
-
-  const result = loadAndTransform(
-    id,
-    url,
-    server,
-    options,
-    timestamp,
-    module,
-    resolved,
-  )
-
-  if (!ssr) {
-    // Only register client requests, server.waitForRequestsIdle should
-    // have been called server.waitForClientRequestsIdle. We can rename
-    // it as part of the environment API work
-    const depsOptimizer = getDepsOptimizer(config, ssr)
-    if (!depsOptimizer?.isOptimizedDepFile(id)) {
-      server._registerRequestProcessing(id, () => result)
-    }
-  }
-
-  return result
-}
-
 async function getCachedTransformResult(
   url: string,
   module: ModuleNode,
@@ -223,283 +75,3 @@ async function getCachedTransformResult(
     return cached
   }
 }
-
-async function loadAndTransform(
-  id: string,
-  url: string,
-  server: ViteDevServer,
-  options: TransformOptions,
-  timestamp: number,
-  mod?: ModuleNode,
-  resolved?: PartialResolvedId,
-) {
-  const { config, pluginContainer, moduleGraph } = server
-  const { logger } = config
-  const prettyUrl =
-    debugLoad || debugTransform ? prettifyUrl(url, config.root) : ''
-  const ssr = !!options.ssr
-
-  const file = cleanUrl(id)
-
-  let code: string | null = null
-  let map: SourceDescription['map'] = null
-
-  // load
-  const loadStart = debugLoad ? performance.now() : 0
-  const loadResult = await pluginContainer.load(id, { ssr })
-  if (loadResult == null) {
-    // if this is an html request and there is no load result, skip ahead to
-    // SPA fallback.
-    if (options.html && !id.endsWith('.html')) {
-      return null
-    }
-    // try fallback loading it from fs as string
-    // if the file is a binary, there should be a plugin that already loaded it
-    // as string
-    // only try the fallback if access is allowed, skip for out of root url
-    // like /service-worker.js or /api/users
-    if (options.ssr || isFileServingAllowed(file, server)) {
-      try {
-        code = await fsp.readFile(file, 'utf-8')
-        debugLoad?.(`${timeFrom(loadStart)} [fs] ${prettyUrl}`)
-      } catch (e) {
-        if (e.code !== 'ENOENT') {
-          if (e.code === 'EISDIR') {
-            e.message = `${e.message} ${file}`
-          }
-          throw e
-        }
-      }
-      if (code != null) {
-        ensureWatchedFile(server.watcher, file, config.root)
-      }
-    }
-    if (code) {
-      try {
-        const extracted = await extractSourcemapFromFile(code, file)
-        if (extracted) {
-          code = extracted.code
-          map = extracted.map
-        }
-      } catch (e) {
-        logger.warn(`Failed to load source map for ${file}.\n${e}`, {
-          timestamp: true,
-        })
-      }
-    }
-  } else {
-    debugLoad?.(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`)
-    if (isObject(loadResult)) {
-      code = loadResult.code
-      map = loadResult.map
-    } else {
-      code = loadResult
-    }
-  }
-  if (code == null) {
-    const isPublicFile = checkPublicFile(url, config)
-    let publicDirName = path.relative(config.root, config.publicDir)
-    if (publicDirName[0] !== '.') publicDirName = '/' + publicDirName
-    const msg = isPublicFile
-      ? `This file is in ${publicDirName} and will be copied as-is during ` +
-        `build without going through the plugin transforms, and therefore ` +
-        `should not be imported from source code. It can only be referenced ` +
-        `via HTML tags.`
-      : `Does the file exist?`
-    const importerMod: ModuleNode | undefined = server.moduleGraph.idToModuleMap
-      .get(id)
-      ?.importers.values()
-      .next().value
-    const importer = importerMod?.file || importerMod?.url
-    const err: any = new Error(
-      `Failed to load url ${url} (resolved id: ${id})${
-        importer ? ` in ${importer}` : ''
-      }. ${msg}`,
-    )
-    err.code = isPublicFile ? ERR_LOAD_PUBLIC_URL : ERR_LOAD_URL
-    throw err
-  }
-
-  if (server._restartPromise && !ssr) throwClosedServerError()
-
-  // ensure module in graph after successful load
-  mod ??= await moduleGraph._ensureEntryFromUrl(url, ssr, undefined, resolved)
-
-  // transform
-  const transformStart = debugTransform ? performance.now() : 0
-  const transformResult = await pluginContainer.transform(code, id, {
-    inMap: map,
-    ssr,
-  })
-  const originalCode = code
-  if (
-    transformResult == null ||
-    (isObject(transformResult) && transformResult.code == null)
-  ) {
-    // no transform applied, keep code as-is
-    debugTransform?.(
-      timeFrom(transformStart) + colors.dim(` [skipped] ${prettyUrl}`),
-    )
-  } else {
-    debugTransform?.(`${timeFrom(transformStart)} ${prettyUrl}`)
-    code = transformResult.code!
-    map = transformResult.map
-  }
-
-  let normalizedMap: SourceMap | { mappings: '' } | null
-  if (typeof map === 'string') {
-    normalizedMap = JSON.parse(map)
-  } else if (map) {
-    normalizedMap = map as SourceMap | { mappings: '' }
-  } else {
-    normalizedMap = null
-  }
-
-  if (normalizedMap && 'version' in normalizedMap && mod.file) {
-    if (normalizedMap.mappings) {
-      await injectSourcesContent(normalizedMap, mod.file, logger)
-    }
-
-    const sourcemapPath = `${mod.file}.map`
-    applySourcemapIgnoreList(
-      normalizedMap,
-      sourcemapPath,
-      config.server.sourcemapIgnoreList,
-      logger,
-    )
-
-    if (path.isAbsolute(mod.file)) {
-      let modDirname
-      for (
-        let sourcesIndex = 0;
-        sourcesIndex < normalizedMap.sources.length;
-        ++sourcesIndex
-      ) {
-        const sourcePath = normalizedMap.sources[sourcesIndex]
-        if (sourcePath) {
-          // Rewrite sources to relative paths to give debuggers the chance
-          // to resolve and display them in a meaningful way (rather than
-          // with absolute paths).
-          if (path.isAbsolute(sourcePath)) {
-            modDirname ??= path.dirname(mod.file)
-            normalizedMap.sources[sourcesIndex] = path.relative(
-              modDirname,
-              sourcePath,
-            )
-          }
-        }
-      }
-    }
-  }
-
-  if (server._restartPromise && !ssr) throwClosedServerError()
-
-  const result =
-    ssr && !server.config.experimental.skipSsrTransform
-      ? await server.ssrTransform(code, normalizedMap, url, originalCode)
-      : ({
-          code,
-          map: normalizedMap,
-          etag: getEtag(code, { weak: true }),
-        } satisfies TransformResult)
-
-  // Only cache the result if the module wasn't invalidated while it was
-  // being processed, so it is re-processed next time if it is stale
-  if (timestamp > mod.lastInvalidationTimestamp)
-    moduleGraph.updateModuleTransformResult(mod, result, ssr)
-
-  return result
-}
-
-/**
- * When a module is soft-invalidated, we can preserve its previous `transformResult` and
- * return similar code to before:
- *
- * - Client: We need to transform the import specifiers with new timestamps
- * - SSR: We don't need to change anything as `ssrLoadModule` controls it
- */
-async function handleModuleSoftInvalidation(
-  mod: ModuleNode,
-  ssr: boolean,
-  timestamp: number,
-  server: ViteDevServer,
-) {
-  const transformResult = ssr ? mod.ssrInvalidationState : mod.invalidationState
-
-  // Reset invalidation state
-  if (ssr) mod.ssrInvalidationState = undefined
-  else mod.invalidationState = undefined
-
-  // Skip if not soft-invalidated
-  if (!transformResult || transformResult === 'HARD_INVALIDATED') return
-
-  if (ssr ? mod.ssrTransformResult : mod.transformResult) {
-    throw new Error(
-      `Internal server error: Soft-invalidated module "${mod.url}" should not have existing transform result`,
-    )
-  }
-
-  let result: TransformResult
-  // For SSR soft-invalidation, no transformation is needed
-  if (ssr) {
-    result = transformResult
-  }
-  // For client soft-invalidation, we need to transform each imports with new timestamps if available
-  else {
-    await init
-    const source = transformResult.code
-    const s = new MagicString(source)
-    const [imports] = parseImports(source, mod.id || undefined)
-
-    for (const imp of imports) {
-      let rawUrl = source.slice(imp.s, imp.e)
-      if (rawUrl === 'import.meta') continue
-
-      const hasQuotes = rawUrl[0] === '"' || rawUrl[0] === "'"
-      if (hasQuotes) {
-        rawUrl = rawUrl.slice(1, -1)
-      }
-
-      const urlWithoutTimestamp = removeTimestampQuery(rawUrl)
-      // hmrUrl must be derived the same way as importAnalysis
-      const hmrUrl = unwrapId(
-        stripBase(removeImportQuery(urlWithoutTimestamp), server.config.base),
-      )
-      for (const importedMod of mod.clientImportedModules) {
-        if (importedMod.url !== hmrUrl) continue
-        if (importedMod.lastHMRTimestamp > 0) {
-          const replacedUrl = injectQuery(
-            urlWithoutTimestamp,
-            `t=${importedMod.lastHMRTimestamp}`,
-          )
-          const start = hasQuotes ? imp.s + 1 : imp.s
-          const end = hasQuotes ? imp.e - 1 : imp.e
-          s.overwrite(start, end, replacedUrl)
-        }
-
-        if (imp.d === -1 && server.config.server.preTransformRequests) {
-          // pre-transform known direct imports
-          server.warmupRequest(hmrUrl, { ssr })
-        }
-
-        break
-      }
-    }
-
-    // Update `transformResult` with new code. We don't have to update the sourcemap
-    // as the timestamp changes doesn't affect the code lines (stable).
-    const code = s.toString()
-    result = {
-      ...transformResult,
-      code,
-      etag: getEtag(code, { weak: true }),
-    }
-  }
-
-  // Only cache the result if the module wasn't invalidated while it was
-  // being processed, so it is re-processed next time if it is stale
-  if (timestamp > mod.lastInvalidationTimestamp)
-    server.moduleGraph.updateModuleTransformResult(mod, result, ssr)
-
-  return result
-}
diff --git a/packages/vite/src/node/server/transformRequest/doTransform.ts b/packages/vite/src/node/server/transformRequest/doTransform.ts
new file mode 100644
index 000000000..5f1085fc9
--- /dev/null
+++ b/packages/vite/src/node/server/transformRequest/doTransform.ts
@@ -0,0 +1,84 @@
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { removeTimestampQuery } from 'packages/vite/src/node/utils';
+import { isDepsOptimizerEnabled } from 'packages/vite/src/node/config';
+import { initDevSsrDepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+import { getDepsOptimizer } from 'packages/vite/src/node/optimizer/index';
+
+
+export interface TransformOptions {
+  ssr?: boolean
+  html?: boolean
+}
+
+export async function doTransform(
+  url: string,
+  server: ViteDevServer,
+  options: TransformOptions,
+  timestamp: number,
+) {
+  url = removeTimestampQuery(url)
+
+  const { config, pluginContainer } = server
+  const ssr = !!options.ssr
+
+  if (ssr && isDepsOptimizerEnabled(config, true)) {
+    await initDevSsrDepsOptimizer(config, server)
+  }
+
+  let module = await server.moduleGraph.getModuleByUrl(url, ssr)
+  if (module) {
+    // try use cache from url
+    const cached = await getCachedTransformResult(
+      url,
+      module,
+      server,
+      ssr,
+      timestamp,
+    )
+    if (cached) return cached
+  }
+
+  const resolved = module
+    ? undefined
+    : ((await pluginContainer.resolveId(url, undefined, { ssr })) ?? undefined)
+
+  // resolve
+  const id = module?.id ?? resolved?.id ?? url
+
+  module ??= server.moduleGraph.getModuleById(id)
+  if (module) {
+    // if a different url maps to an existing loaded id,  make sure we relate this url to the id
+    await server.moduleGraph._ensureEntryFromUrl(url, ssr, undefined, resolved)
+    // try use cache from id
+    const cached = await getCachedTransformResult(
+      url,
+      module,
+      server,
+      ssr,
+      timestamp,
+    )
+    if (cached) return cached
+  }
+
+  const result = loadAndTransform(
+    id,
+    url,
+    server,
+    options,
+    timestamp,
+    module,
+    resolved,
+  )
+
+  if (!ssr) {
+    // Only register client requests, server.waitForRequestsIdle should
+    // have been called server.waitForClientRequestsIdle. We can rename
+    // it as part of the environment API work
+    const depsOptimizer = getDepsOptimizer(config, ssr)
+    if (!depsOptimizer?.isOptimizedDepFile(id)) {
+      server._registerRequestProcessing(id, () => result)
+    }
+  }
+
+  return result
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation.ts b/packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation.ts
new file mode 100644
index 000000000..13f566b20
--- /dev/null
+++ b/packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation.ts
@@ -0,0 +1,113 @@
+import getEtag from 'etag'
+import MagicString from 'magic-string'
+import { init, parse as parseImports } from 'es-module-lexer'
+import { ModuleNode } from 'packages/vite/src/node/index';
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { removeTimestampQuery } from 'packages/vite/src/node/utils';
+import { removeImportQuery } from 'packages/vite/src/node/utils';
+import { stripBase } from 'packages/vite/src/node/utils';
+import { injectQuery } from 'packages/vite/src/node/utils';
+import { unwrapId } from 'packages/vite/src/shared/utils';
+import type { PartialResolvedId, SourceDescription, SourceMap } from 'rollup'
+
+
+export interface TransformResult {
+  code: string
+  map: SourceMap | { mappings: '' } | null
+  etag?: string
+  deps?: string[]
+  dynamicDeps?: string[]
+}
+
+/**
+ * When a module is soft-invalidated, we can preserve its previous `transformResult` and
+ * return similar code to before:
+ *
+ * - Client: We need to transform the import specifiers with new timestamps
+ * - SSR: We don't need to change anything as `ssrLoadModule` controls it
+ */
+export async function handleModuleSoftInvalidation(
+  mod: ModuleNode,
+  ssr: boolean,
+  timestamp: number,
+  server: ViteDevServer,
+) {
+  const transformResult = ssr ? mod.ssrInvalidationState : mod.invalidationState
+
+  // Reset invalidation state
+  if (ssr) mod.ssrInvalidationState = undefined
+  else mod.invalidationState = undefined
+
+  // Skip if not soft-invalidated
+  if (!transformResult || transformResult === 'HARD_INVALIDATED') return
+
+  if (ssr ? mod.ssrTransformResult : mod.transformResult) {
+    throw new Error(
+      `Internal server error: Soft-invalidated module "${mod.url}" should not have existing transform result`,
+    )
+  }
+
+  let result: TransformResult
+  // For SSR soft-invalidation, no transformation is needed
+  if (ssr) {
+    result = transformResult
+  }
+  // For client soft-invalidation, we need to transform each imports with new timestamps if available
+  else {
+    await init
+    const source = transformResult.code
+    const s = new MagicString(source)
+    const [imports] = parseImports(source, mod.id || undefined)
+
+    for (const imp of imports) {
+      let rawUrl = source.slice(imp.s, imp.e)
+      if (rawUrl === 'import.meta') continue
+
+      const hasQuotes = rawUrl[0] === '"' || rawUrl[0] === "'"
+      if (hasQuotes) {
+        rawUrl = rawUrl.slice(1, -1)
+      }
+
+      const urlWithoutTimestamp = removeTimestampQuery(rawUrl)
+      // hmrUrl must be derived the same way as importAnalysis
+      const hmrUrl = unwrapId(
+        stripBase(removeImportQuery(urlWithoutTimestamp), server.config.base),
+      )
+      for (const importedMod of mod.clientImportedModules) {
+        if (importedMod.url !== hmrUrl) continue
+        if (importedMod.lastHMRTimestamp > 0) {
+          const replacedUrl = injectQuery(
+            urlWithoutTimestamp,
+            `t=${importedMod.lastHMRTimestamp}`,
+          )
+          const start = hasQuotes ? imp.s + 1 : imp.s
+          const end = hasQuotes ? imp.e - 1 : imp.e
+          s.overwrite(start, end, replacedUrl)
+        }
+
+        if (imp.d === -1 && server.config.server.preTransformRequests) {
+          // pre-transform known direct imports
+          server.warmupRequest(hmrUrl, { ssr })
+        }
+
+        break
+      }
+    }
+
+    // Update `transformResult` with new code. We don't have to update the sourcemap
+    // as the timestamp changes doesn't affect the code lines (stable).
+    const code = s.toString()
+    result = {
+      ...transformResult,
+      code,
+      etag: getEtag(code, { weak: true }),
+    }
+  }
+
+  // Only cache the result if the module wasn't invalidated while it was
+  // being processed, so it is re-processed next time if it is stale
+  if (timestamp > mod.lastInvalidationTimestamp)
+    server.moduleGraph.updateModuleTransformResult(mod, result, ssr)
+
+  return result
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/transformRequest/loadAndTransform.ts b/packages/vite/src/node/server/transformRequest/loadAndTransform.ts
new file mode 100644
index 000000000..2550308d7
--- /dev/null
+++ b/packages/vite/src/node/server/transformRequest/loadAndTransform.ts
@@ -0,0 +1,229 @@
+import fsp from 'node:fs/promises'
+import path from 'node:path'
+import { performance } from 'node:perf_hooks'
+import getEtag from 'etag'
+import type { PartialResolvedId, SourceDescription, SourceMap } from 'rollup'
+import colors from 'picocolors'
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { ModuleNode } from 'packages/vite/src/node/index';
+import { timeFrom } from 'packages/vite/src/node/utils';
+import { ensureWatchedFile } from 'packages/vite/src/node/utils';
+import { isObject } from 'packages/vite/src/node/utils';
+import { prettifyUrl } from 'packages/vite/src/node/utils';
+import { checkPublicFile } from 'packages/vite/src/node/publicDir';
+import { cleanUrl } from 'packages/vite/src/shared/utils';
+import { injectSourcesContent } from 'packages/vite/src/node/server/sourcemap';
+import { applySourcemapIgnoreList } from 'packages/vite/src/node/server/sourcemap';
+import { extractSourcemapFromFile } from 'packages/vite/src/node/server/sourcemap';
+import { isFileServingAllowed } from 'packages/vite/src/node/server/middlewares/static';
+import { throwClosedServerError } from 'packages/vite/src/node/server/pluginContainer';
+import { createDebugger } from 'packages/vite/src/node/utils';
+
+
+export const ERR_LOAD_URL = 'ERR_LOAD_URL'
+
+export const ERR_LOAD_PUBLIC_URL = 'ERR_LOAD_PUBLIC_URL'
+
+const export debugLoad = createDebugger('vite:load')
+
+const export debugTransform = createDebugger('vite:transform')
+
+export interface TransformResult {
+  code: string
+  map: SourceMap | { mappings: '' } | null
+  etag?: string
+  deps?: string[]
+  dynamicDeps?: string[]
+}
+
+export interface TransformOptions {
+  ssr?: boolean
+  html?: boolean
+}
+
+export async function loadAndTransform(
+  id: string,
+  url: string,
+  server: ViteDevServer,
+  options: TransformOptions,
+  timestamp: number,
+  mod?: ModuleNode,
+  resolved?: PartialResolvedId,
+) {
+  const { config, pluginContainer, moduleGraph } = server
+  const { logger } = config
+  const prettyUrl =
+    debugLoad || debugTransform ? prettifyUrl(url, config.root) : ''
+  const ssr = !!options.ssr
+
+  const file = cleanUrl(id)
+
+  let code: string | null = null
+  let map: SourceDescription['map'] = null
+
+  // load
+  const loadStart = debugLoad ? performance.now() : 0
+  const loadResult = await pluginContainer.load(id, { ssr })
+  if (loadResult == null) {
+    // if this is an html request and there is no load result, skip ahead to
+    // SPA fallback.
+    if (options.html && !id.endsWith('.html')) {
+      return null
+    }
+    // try fallback loading it from fs as string
+    // if the file is a binary, there should be a plugin that already loaded it
+    // as string
+    // only try the fallback if access is allowed, skip for out of root url
+    // like /service-worker.js or /api/users
+    if (options.ssr || isFileServingAllowed(file, server)) {
+      try {
+        code = await fsp.readFile(file, 'utf-8')
+        debugLoad?.(`${timeFrom(loadStart)} [fs] ${prettyUrl}`)
+      } catch (e) {
+        if (e.code !== 'ENOENT') {
+          if (e.code === 'EISDIR') {
+            e.message = `${e.message} ${file}`
+          }
+          throw e
+        }
+      }
+      if (code != null) {
+        ensureWatchedFile(server.watcher, file, config.root)
+      }
+    }
+    if (code) {
+      try {
+        const extracted = await extractSourcemapFromFile(code, file)
+        if (extracted) {
+          code = extracted.code
+          map = extracted.map
+        }
+      } catch (e) {
+        logger.warn(`Failed to load source map for ${file}.\n${e}`, {
+          timestamp: true,
+        })
+      }
+    }
+  } else {
+    debugLoad?.(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`)
+    if (isObject(loadResult)) {
+      code = loadResult.code
+      map = loadResult.map
+    } else {
+      code = loadResult
+    }
+  }
+  if (code == null) {
+    const isPublicFile = checkPublicFile(url, config)
+    let publicDirName = path.relative(config.root, config.publicDir)
+    if (publicDirName[0] !== '.') publicDirName = '/' + publicDirName
+    const msg = isPublicFile
+      ? `This file is in ${publicDirName} and will be copied as-is during ` +
+        `build without going through the plugin transforms, and therefore ` +
+        `should not be imported from source code. It can only be referenced ` +
+        `via HTML tags.`
+      : `Does the file exist?`
+    const importerMod: ModuleNode | undefined = server.moduleGraph.idToModuleMap
+      .get(id)
+      ?.importers.values()
+      .next().value
+    const importer = importerMod?.file || importerMod?.url
+    const err: any = new Error(
+      `Failed to load url ${url} (resolved id: ${id})${
+        importer ? ` in ${importer}` : ''
+      }. ${msg}`,
+    )
+    err.code = isPublicFile ? ERR_LOAD_PUBLIC_URL : ERR_LOAD_URL
+    throw err
+  }
+
+  if (server._restartPromise && !ssr) throwClosedServerError()
+
+  // ensure module in graph after successful load
+  mod ??= await moduleGraph._ensureEntryFromUrl(url, ssr, undefined, resolved)
+
+  // transform
+  const transformStart = debugTransform ? performance.now() : 0
+  const transformResult = await pluginContainer.transform(code, id, {
+    inMap: map,
+    ssr,
+  })
+  const originalCode = code
+  if (
+    transformResult == null ||
+    (isObject(transformResult) && transformResult.code == null)
+  ) {
+    // no transform applied, keep code as-is
+    debugTransform?.(
+      timeFrom(transformStart) + colors.dim(` [skipped] ${prettyUrl}`),
+    )
+  } else {
+    debugTransform?.(`${timeFrom(transformStart)} ${prettyUrl}`)
+    code = transformResult.code!
+    map = transformResult.map
+  }
+
+  let normalizedMap: SourceMap | { mappings: '' } | null
+  if (typeof map === 'string') {
+    normalizedMap = JSON.parse(map)
+  } else if (map) {
+    normalizedMap = map as SourceMap | { mappings: '' }
+  } else {
+    normalizedMap = null
+  }
+
+  if (normalizedMap && 'version' in normalizedMap && mod.file) {
+    if (normalizedMap.mappings) {
+      await injectSourcesContent(normalizedMap, mod.file, logger)
+    }
+
+    const sourcemapPath = `${mod.file}.map`
+    applySourcemapIgnoreList(
+      normalizedMap,
+      sourcemapPath,
+      config.server.sourcemapIgnoreList,
+      logger,
+    )
+
+    if (path.isAbsolute(mod.file)) {
+      let modDirname
+      for (
+        let sourcesIndex = 0;
+        sourcesIndex < normalizedMap.sources.length;
+        ++sourcesIndex
+      ) {
+        const sourcePath = normalizedMap.sources[sourcesIndex]
+        if (sourcePath) {
+          // Rewrite sources to relative paths to give debuggers the chance
+          // to resolve and display them in a meaningful way (rather than
+          // with absolute paths).
+          if (path.isAbsolute(sourcePath)) {
+            modDirname ??= path.dirname(mod.file)
+            normalizedMap.sources[sourcesIndex] = path.relative(
+              modDirname,
+              sourcePath,
+            )
+          }
+        }
+      }
+    }
+  }
+
+  if (server._restartPromise && !ssr) throwClosedServerError()
+
+  const result =
+    ssr && !server.config.experimental.skipSsrTransform
+      ? await server.ssrTransform(code, normalizedMap, url, originalCode)
+      : ({
+          code,
+          map: normalizedMap,
+          etag: getEtag(code, { weak: true }),
+        } satisfies TransformResult)
+
+  // Only cache the result if the module wasn't invalidated while it was
+  // being processed, so it is re-processed next time if it is stale
+  if (timestamp > mod.lastInvalidationTimestamp)
+    moduleGraph.updateModuleTransformResult(mod, result, ssr)
+
+  return result
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/transformRequest/transformRequest.ts b/packages/vite/src/node/server/transformRequest/transformRequest.ts
new file mode 100644
index 000000000..5e9c40b91
--- /dev/null
+++ b/packages/vite/src/node/server/transformRequest/transformRequest.ts
@@ -0,0 +1,91 @@
+import { ViteDevServer } from 'packages/vite/src/node/index';
+import { removeTimestampQuery } from 'packages/vite/src/node/utils';
+import { throwClosedServerError } from 'packages/vite/src/node/server/pluginContainer';
+import type { PartialResolvedId, SourceDescription, SourceMap } from 'rollup'
+
+
+export interface TransformResult {
+  code: string
+  map: SourceMap | { mappings: '' } | null
+  etag?: string
+  deps?: string[]
+  dynamicDeps?: string[]
+}
+
+export interface TransformOptions {
+  ssr?: boolean
+  html?: boolean
+}
+
+export function transformRequest(
+  url: string,
+  server: ViteDevServer,
+  options: TransformOptions = {},
+): Promise<TransformResult | null> {
+  if (server._restartPromise && !options.ssr) throwClosedServerError()
+
+  const cacheKey = (options.ssr ? 'ssr:' : options.html ? 'html:' : '') + url
+
+  // This module may get invalidated while we are processing it. For example
+  // when a full page reload is needed after the re-processing of pre-bundled
+  // dependencies when a missing dep is discovered. We save the current time
+  // to compare it to the last invalidation performed to know if we should
+  // cache the result of the transformation or we should discard it as stale.
+  //
+  // A module can be invalidated due to:
+  // 1. A full reload because of pre-bundling newly discovered deps
+  // 2. A full reload after a config change
+  // 3. The file that generated the module changed
+  // 4. Invalidation for a virtual module
+  //
+  // For 1 and 2, a new request for this module will be issued after
+  // the invalidation as part of the browser reloading the page. For 3 and 4
+  // there may not be a new request right away because of HMR handling.
+  // In all cases, the next time this module is requested, it should be
+  // re-processed.
+  //
+  // We save the timestamp when we start processing and compare it with the
+  // last time this module is invalidated
+  const timestamp = Date.now()
+
+  const pending = server._pendingRequests.get(cacheKey)
+  if (pending) {
+    return server.moduleGraph
+      .getModuleByUrl(removeTimestampQuery(url), options.ssr)
+      .then((module) => {
+        if (!module || pending.timestamp > module.lastInvalidationTimestamp) {
+          // The pending request is still valid, we can safely reuse its result
+          return pending.request
+        } else {
+          // Request 1 for module A     (pending.timestamp)
+          // Invalidate module A        (module.lastInvalidationTimestamp)
+          // Request 2 for module A     (timestamp)
+
+          // First request has been invalidated, abort it to clear the cache,
+          // then perform a new doTransform.
+          pending.abort()
+          return transformRequest(url, server, options)
+        }
+      })
+  }
+
+  const request = doTransform(url, server, options, timestamp)
+
+  // Avoid clearing the cache of future requests if aborted
+  let cleared = false
+  const clearCache = () => {
+    if (!cleared) {
+      server._pendingRequests.delete(cacheKey)
+      cleared = true
+    }
+  }
+
+  // Cache the request and clear it once processing is done
+  server._pendingRequests.set(cacheKey, {
+    request,
+    timestamp,
+    abort: clearCache,
+  })
+
+  return request.finally(clearCache)
+}
\ No newline at end of file
diff --git a/packages/vite/src/node/server/ws.ts b/packages/vite/src/node/server/ws.ts
index d0bffcdce..29fa802f4 100644
--- a/packages/vite/src/node/server/ws.ts
+++ b/packages/vite/src/node/server/ws.ts
@@ -1,3 +1,8 @@
+import { HttpServer } from 'packages/vite/src/node/server/index/ServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/_createServer';
+import { HttpServer } from 'packages/vite/src/node/server/index/resolveServerOptions';
+import { HttpServer } from 'packages/vite/src/node/server/index/restartServer';
 import path from 'node:path'
 import type { IncomingMessage, Server } from 'node:http'
 import { STATUS_CODES, createServer as createHttpServer } from 'node:http'
@@ -14,7 +19,6 @@ import type { InferCustomEventPayload } from 'types/customEvent'
 import type { ResolvedConfig } from '..'
 import { isObject } from '../utils'
 import type { HMRChannel } from './hmr'
-import type { HttpServer } from '.'
 
 /* In Bun, the `ws` module is overridden to hook into the native code. Using the bundled `js` version
  * of `ws` will not work as Bun's req.socket does not allow reading/writing to the underlying socket.
diff --git a/packages/vite/src/node/shortcuts.ts b/packages/vite/src/node/shortcuts.ts
index 1bac57162..c19eb6854 100644
--- a/packages/vite/src/node/shortcuts.ts
+++ b/packages/vite/src/node/shortcuts.ts
@@ -1,7 +1,9 @@
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import readline from 'node:readline'
 import colors from 'picocolors'
 import { restartServerWithUrls } from './server'
-import type { ViteDevServer } from './server'
 import { isDevServer } from './utils'
 import type { PreviewServer } from './preview'
 import { openBrowser } from './server/openBrowser'
diff --git a/packages/vite/src/node/ssr/__tests__/ssrExternal.spec.ts b/packages/vite/src/node/ssr/__tests__/ssrExternal.spec.ts
index 68e753af7..3c9cb06fa 100644
--- a/packages/vite/src/node/ssr/__tests__/ssrExternal.spec.ts
+++ b/packages/vite/src/node/ssr/__tests__/ssrExternal.spec.ts
@@ -1,7 +1,7 @@
+import { resolveConfig } from 'packages/vite/src/node/config/resolveConfig';
 import { fileURLToPath } from 'node:url'
 import { describe, expect, test } from 'vitest'
 import type { SSROptions } from '..'
-import { resolveConfig } from '../../config'
 import { createIsConfiguredAsSsrExternal } from '../ssrExternal'
 
 describe('createIsConfiguredAsSsrExternal', () => {
diff --git a/packages/vite/src/node/ssr/fetchModule.ts b/packages/vite/src/node/ssr/fetchModule.ts
index 60c0cb0a4..e00062f62 100644
--- a/packages/vite/src/node/ssr/fetchModule.ts
+++ b/packages/vite/src/node/ssr/fetchModule.ts
@@ -1,7 +1,8 @@
+import { InternalResolveOptionsWithOverrideConditions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { tryNodeResolve } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptionsWithOverrideConditions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
 import { pathToFileURL } from 'node:url'
 import type { ModuleNode, TransformResult, ViteDevServer } from '..'
-import type { InternalResolveOptionsWithOverrideConditions } from '../plugins/resolve'
-import { tryNodeResolve } from '../plugins/resolve'
 import { isBuiltin, isExternalUrl, isFilePathESM } from '../utils'
 import type { FetchResult } from '../../runtime/types'
 import { unwrapId } from '../../shared/utils'
diff --git a/packages/vite/src/node/ssr/index.ts b/packages/vite/src/node/ssr/index.ts
index 3847e6954..806a2d63b 100644
--- a/packages/vite/src/node/ssr/index.ts
+++ b/packages/vite/src/node/ssr/index.ts
@@ -1,5 +1,4 @@
-import type { DepOptimizationConfig } from '../optimizer'
-
+import { DepOptimizationConfig } from 'packages/vite/src/node/optimizer/index/DepOptimizationConfig';
 export type SSRTarget = 'node' | 'webworker'
 
 export type SsrDepOptimizationOptions = DepOptimizationConfig
diff --git a/packages/vite/src/node/ssr/runtime/__tests__/utils.ts b/packages/vite/src/node/ssr/runtime/__tests__/utils.ts
index 5d8c06d4b..2de3f38cd 100644
--- a/packages/vite/src/node/ssr/runtime/__tests__/utils.ts
+++ b/packages/vite/src/node/ssr/runtime/__tests__/utils.ts
@@ -1,3 +1,7 @@
+import { InlineConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import fs from 'node:fs'
 import { dirname, resolve } from 'node:path'
 import { fileURLToPath } from 'node:url'
@@ -5,8 +9,6 @@ import type { TestAPI } from 'vitest'
 import { afterEach, beforeEach, test } from 'vitest'
 import type { ViteRuntime } from 'vite/runtime'
 import type { MainThreadRuntimeOptions } from '../mainThreadRuntime'
-import type { ViteDevServer } from '../../../server'
-import type { InlineConfig } from '../../../config'
 import { createServer } from '../../../server'
 import { createViteRuntime } from '../mainThreadRuntime'
 
diff --git a/packages/vite/src/node/ssr/runtime/mainThreadRuntime.ts b/packages/vite/src/node/ssr/runtime/mainThreadRuntime.ts
index cbb8e3d8e..e9276eb21 100644
--- a/packages/vite/src/node/ssr/runtime/mainThreadRuntime.ts
+++ b/packages/vite/src/node/ssr/runtime/mainThreadRuntime.ts
@@ -1,7 +1,9 @@
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import { existsSync, readFileSync } from 'node:fs'
 import { ESModulesRunner, ViteRuntime } from 'vite/runtime'
 import type { ViteModuleRunner, ViteRuntimeOptions } from 'vite/runtime'
-import type { ViteDevServer } from '../../server'
 import type { HMRLogger } from '../../../shared/hmr'
 import { ServerHMRConnector } from './serverHmrConnector'
 
diff --git a/packages/vite/src/node/ssr/runtime/serverHmrConnector.ts b/packages/vite/src/node/ssr/runtime/serverHmrConnector.ts
index b8bed32a8..f235dba5a 100644
--- a/packages/vite/src/node/ssr/runtime/serverHmrConnector.ts
+++ b/packages/vite/src/node/ssr/runtime/serverHmrConnector.ts
@@ -1,6 +1,8 @@
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import type { CustomPayload, HMRPayload } from 'types/hmrPayload'
 import type { HMRRuntimeConnection } from 'vite/runtime'
-import type { ViteDevServer } from '../../server'
 import type { HMRBroadcasterClient, ServerHMRChannel } from '../../server/hmr'
 
 class ServerHMRBroadcasterClient implements HMRBroadcasterClient {
diff --git a/packages/vite/src/node/ssr/ssrExternal.ts b/packages/vite/src/node/ssr/ssrExternal.ts
index 5681e0005..8ae33dc00 100644
--- a/packages/vite/src/node/ssr/ssrExternal.ts
+++ b/packages/vite/src/node/ssr/ssrExternal.ts
@@ -1,6 +1,10 @@
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePlugin';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryCleanFsResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { tryNodeResolve } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolvePackageEntry';
+import { InternalResolveOptions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
 import path from 'node:path'
-import type { InternalResolveOptions } from '../plugins/resolve'
-import { tryNodeResolve } from '../plugins/resolve'
 import {
   bareImportRE,
   createDebugger,
diff --git a/packages/vite/src/node/ssr/ssrFetchModule.ts b/packages/vite/src/node/ssr/ssrFetchModule.ts
index d0e1c98cc..eee8b36e3 100644
--- a/packages/vite/src/node/ssr/ssrFetchModule.ts
+++ b/packages/vite/src/node/ssr/ssrFetchModule.ts
@@ -1,4 +1,6 @@
-import type { ViteDevServer } from '../server'
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import type { FetchResult } from '../../runtime/types'
 import { asyncFunctionDeclarationPaddingLineCount } from '../../shared/utils'
 import { fetchModule } from './fetchModule'
diff --git a/packages/vite/src/node/ssr/ssrModuleLoader.ts b/packages/vite/src/node/ssr/ssrModuleLoader.ts
index 0de984786..a1955c9ee 100644
--- a/packages/vite/src/node/ssr/ssrModuleLoader.ts
+++ b/packages/vite/src/node/ssr/ssrModuleLoader.ts
@@ -1,11 +1,14 @@
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
+import { InternalResolveOptionsWithOverrideConditions } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { tryNodeResolve } from 'packages/vite/src/node/plugins/resolve/tryNodeResolve';
+import { InternalResolveOptionsWithOverrideConditions } from 'packages/vite/src/node/plugins/resolve/resolveDeepImport';
+import { transformRequest } from 'packages/vite/src/node/server/transformRequest/transformRequest';
 import path from 'node:path'
 import { pathToFileURL } from 'node:url'
 import colors from 'picocolors'
-import type { ViteDevServer } from '../server'
 import { isBuiltin, isExternalUrl, isFilePathESM } from '../utils'
-import { transformRequest } from '../server/transformRequest'
-import type { InternalResolveOptionsWithOverrideConditions } from '../plugins/resolve'
-import { tryNodeResolve } from '../plugins/resolve'
 import { genSourceMapUrl } from '../server/sourcemap'
 import {
   AsyncFunction,
diff --git a/packages/vite/src/node/ssr/ssrTransform.ts b/packages/vite/src/node/ssr/ssrTransform.ts
index ac5d52016..f5f1e16b8 100644
--- a/packages/vite/src/node/ssr/ssrTransform.ts
+++ b/packages/vite/src/node/ssr/ssrTransform.ts
@@ -1,3 +1,6 @@
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/transformRequest';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/loadAndTransform';
+import { TransformResult } from 'packages/vite/src/node/server/transformRequest/handleModuleSoftInvalidation';
 import path from 'node:path'
 import MagicString from 'magic-string'
 import type { SourceMap } from 'rollup'
@@ -13,7 +16,6 @@ import { extract_names as extractNames } from 'periscopic'
 import { walk as eswalk } from 'estree-walker'
 import type { RawSourceMap } from '@ampproject/remapping'
 import { parseAstAsync as rollupParseAstAsync } from 'rollup/parseAst'
-import type { TransformResult } from '../server/transformRequest'
 import { combineSourcemaps, isDefined } from '../utils'
 import { isJSONRequest } from '../plugins/json'
 import type { DefineImportMetadata } from '../../shared/ssrTransform'
diff --git a/packages/vite/src/node/utils.ts b/packages/vite/src/node/utils.ts
index 393bc3917..23b51bdc9 100644
--- a/packages/vite/src/node/utils.ts
+++ b/packages/vite/src/node/utils.ts
@@ -1,3 +1,11 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
+import { DepOptimizationConfig } from 'packages/vite/src/node/optimizer/index/DepOptimizationConfig';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/ViteDevServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/_createServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/_createServer';
+import { ResolvedServerUrls } from 'packages/vite/src/node/server/index/restartServer';
+import { ViteDevServer } from 'packages/vite/src/node/server/index/restartServer';
 import fs from 'node:fs'
 import os from 'node:os'
 import path from 'node:path'
@@ -30,9 +38,6 @@ import {
   loopbackHosts,
   wildcardHosts,
 } from './constants'
-import type { DepOptimizationConfig } from './optimizer'
-import type { ResolvedConfig } from './config'
-import type { ResolvedServerUrls, ViteDevServer } from './server'
 import type { PreviewServer } from './preview'
 import {
   type PackageCache,
diff --git a/packages/vite/src/node/watch.ts b/packages/vite/src/node/watch.ts
index d8eb128f1..71e63f37f 100644
--- a/packages/vite/src/node/watch.ts
+++ b/packages/vite/src/node/watch.ts
@@ -1,3 +1,4 @@
+import { ResolvedConfig } from 'packages/vite/src/node/config/resolveConfig';
 import { EventEmitter } from 'node:events'
 import path from 'node:path'
 import glob from 'fast-glob'
@@ -6,7 +7,6 @@ import type { OutputOptions } from 'rollup'
 import * as colors from 'picocolors'
 import { withTrailingSlash } from '../shared/utils'
 import { arraify, normalizePath } from './utils'
-import type { ResolvedConfig } from './config'
 import type { Logger } from './logger'
 
 export function getResolvedOutDirs(
